<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>SamuFlore&#39;s Dimension</title>
    <link>https://samuflore.top/</link>
    
    <atom:link href="https://samuflore.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>一人倒、衆人倒。</description>
    <pubDate>Sun, 28 Sep 2025 14:28:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[CO Pre] MIPS 汇编入门</title>
      <link>https://samuflore.top/posts/1f9d902/</link>
      <guid>https://samuflore.top/posts/1f9d902/</guid>
      <pubDate>Sat, 20 Sep 2025 08:00:25 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 MIPS 汇编部分。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 MIPS 汇编部分。</p><span id="more"></span><hr><h1 id="IDE">IDE</h1><p>MARS（MIPS ASSEMBLER AND RUNTIME SIMULATOR）<br>MARS 是一个轻量级的、用于教学的 MIPS 汇编语言集成开发环境（IDE）。它由密苏里州立大学开发，基于 Java 环境运行，完全绿色且免费。我们的课程即使用此软件来进行 MIPS 汇编语言的学习、编写和运行。</p><hr><h1 id="寄存器简介">寄存器简介</h1><h2 id="什么是寄存器？">什么是寄存器？</h2><p>寄存器是一种高速存储器，可以暂存指令、数据、地址等。CPU 中只有有限的寄存器可供使用。<br>MIPS 体系结构中，CPU 对数据的操作是基于寄存器的。内存中的数据需要先使用读取类指令（Load）保存到寄存器中才可使用；操作完成的数据也需要使用装载类指令（Store）保存到内存中。</p><h2 id="MIPS-中的-32-个通用寄存器">MIPS 中的 32 个通用寄存器</h2><p>所谓通用寄存器（General - Purpose Register, GPR），代表它没有明确规定的用途，程序员可以随意对他们赋值、取值，同时他们的值也可以直接参与到各种指令之中。<br>然而，虽然冠有通用的头衔，程序员们还是会以一定的规则来使用它们，这是为了便于程序员之间的交流，同时也是为编译器等工具定下了一定的标准。</p><table><thead><tr><th>Registers</th><th>Name</th><th>Usage</th></tr></thead><tbody><tr><td>$0</td><td>$zero</td><td>常量0</td></tr><tr><td>$1</td><td>$at</td><td>保留给汇编器使用的临时变量</td></tr><tr><td>$2-$3</td><td>$v0-$v1</td><td>函数调用返回值</td></tr><tr><td>$4-$7</td><td>$a0-$a3</td><td>函数调用参数</td></tr><tr><td>$8-$15</td><td>$t0-$t7</td><td>临时变量</td></tr><tr><td>$16-$23</td><td>$s0-$s7</td><td>需要保存的变量</td></tr><tr><td>$24-$25</td><td>$t8-$t9</td><td>临时变量</td></tr><tr><td>$26-$27</td><td>$k0-$k1</td><td>留给操作系统使用</td></tr><tr><td>$28</td><td>$gp</td><td>全局指针</td></tr><tr><td>$29</td><td>$sp</td><td>堆栈指针</td></tr><tr><td>$30</td><td>$fp</td><td>帧指针</td></tr><tr><td>$31</td><td>$ra</td><td>返回地址</td></tr></tbody></table><div class="note info">            <ul class="lvl-0"><li class="lvl-2"><p><code>%0</code> 一般不能用于赋值。即对其赋值不违反语法，但其始终保持为 0。</p></li><li class="lvl-2"><p><code>%1</code> 保留给汇编器，一般不使用它。</p></li></ul>          </div><p><a id="specialReg"></a></p><h2 id="三个特殊寄存器">三个特殊寄存器</h2><ul class="lvl-0"><li class="lvl-2"><p>PC（Program Counter）：它用于存储当前 CPU 正在执行的指令在内存中的地址。</p></li><li class="lvl-2"><p>HI：这个寄存器用于乘除法。它被用来存放每次乘法结果的高 32 位，也被用来存放除法结果的余数。</p></li><li class="lvl-2"><p>LO：HI 的孪生兄弟。它被用来存放每次乘法结果的低 32 位，也被用来存放除法结果的商。</p></li></ul><hr><h1 id="MIPS-汇编指令集架构">MIPS 汇编指令集架构</h1><h2 id="什么是指令？">什么是指令？</h2><p>指令，即是由处理器指令集架构（Instruction Set Architecture，可以理解为计算机体系结构中对程序相关的部分所做的定义）定义的处理器的独立操作，这个操作一般是运算、存储、读取等。一个指令在 CPU 中真正的存在形式是高低电平，也可以理解为由 01 序列组成的机器码。但因为机器码人类难以阅读和理解，所以指令一般由汇编语言来表示，也就是我们俗称的汇编指令。从这个角度上来说，汇编指令只是指令的一种表示形式而已，其实质是一样的。</p><h2 id="指令之格式">指令之格式</h2><p>指令一般由一个<ins>指令名</ins>开头，后跟其<ins>操作数</ins>，中间由<ins>空格</ins>或<ins>逗号</ins>隔开。操作数一般为 0 至 3 个，且每个指令名有其固定的操作数。一般来说格式如下：</p><p><em>指令名  操作数 1  操作数 2  操作数 3</em></p><p>或：</p><p><em>指令名 操作数 1, 操作数 3(操作数 2)</em></p><p>操作数可以是寄存器、立即数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>或标签<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。每个指令都有其固定的对操作数形式的要求。而标签最终会由汇编器转换为立即数。</p><p>常见指令格式样例：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>$<span class="built_in">s0</span>, $<span class="built_in">a0</span>, $<span class="built_in">a1</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="built_in">s0</span>, $<span class="built_in">a0</span>, <span class="number">12</span></span><br><span class="line"><span class="keyword">mult </span>$<span class="built_in">s1</span>, $<span class="built_in">s2</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">a1</span>, $<span class="built_in">a2</span>, loop</span><br><span class="line"><span class="keyword">blez </span>$<span class="built_in">s1</span>, -<span class="number">2</span></span><br><span class="line"><span class="keyword">jr </span>$<span class="built_in">ra</span></span><br><span class="line"><span class="keyword">j </span><span class="number">0x00003014</span></span><br></pre></td></tr></table></figure><div class="tips"><p>前文提到可以用标签代替某个地址，正如上例第 4 行的 <code>loop</code> 标签。</p></div><div class="warning"><p>注意：在 MARS 中，跳转指令只能使用标签来进行跳转，不能使用立即数！</p></div><h2 id="机器码指令">机器码指令</h2><h3 id="机器码">机器码</h3><p>计算机只能理解二进制形式的数据。而我们前面所说的汇编语言，最终就会转化为机器语言——也就是机器码指令， CPU 可以直接识别这种机器语言，从而去完成相应的操作。<br>MIPS 汇编中，所有的指令长度均为 32 位，即 4 字节，或者说 1 字。<br>一段汇编语言可以转换为一段机器码，例如下面这段汇编指令：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.global</span> main</span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="built_in">t0</span>, $<span class="number">0</span>, <span class="number">100</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">t1</span>, $<span class="number">0</span>, <span class="number">200</span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">t2</span>, $<span class="built_in">t1</span>, $<span class="built_in">t2</span></span><br><span class="line"><span class="keyword">sub </span>$<span class="built_in">t3</span>, $<span class="built_in">t2</span>, $<span class="built_in">t1</span></span><br><span class="line"><span class="keyword">lui </span>$<span class="built_in">t4</span>, <span class="number">233</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">v0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">a0</span>, <span class="number">2333</span></span><br><span class="line"><span class="keyword">mthi </span>$<span class="built_in">t1</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">loop:</span></span><br><span class="line"><span class="keyword">j </span>loop</span><br><span class="line"><span class="keyword">nop</span></span><br></pre></td></tr></table></figure><p>其转换后的结果为（16 进制）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">20080064</span><br><span class="line">340900c8</span><br><span class="line">012a5020</span><br><span class="line">01495822</span><br><span class="line">3c0c00e9</span><br><span class="line">34420001</span><br><span class="line">3484091d</span><br><span class="line">01200011</span><br><span class="line">0000000c</span><br><span class="line">00000000</span><br><span class="line">08000c0a</span><br><span class="line">00000000</span><br></pre></td></tr></table></figure><h3 id="机器码之指令格式">机器码之指令格式</h3><ul class="lvl-0"><li class="lvl-2"><p>R 型指令<br>R 型指令的操作数最多，一般用于运算指令。例如 <code>add</code>、<code>sub</code>、<code>sll</code> 等。其格式如下（左侧为高位，右侧为低位，第二行为位数）：</p></li></ul><table><thead><tr><th>op</th><th>rs</th><th>rt</th><th>rd</th><th>shamt</th><th>func</th></tr></thead><tbody><tr><td>6</td><td>5</td><td>5</td><td>5</td><td>5</td><td>6</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>I 型指令型指令的特点是有 16 位的立即数（偏移也是一样的道理）。因此，I 型指令一般用于 <code>addi</code>、<code>subi</code>、<code>ori</code> 等与立即数相运算的指令（这里需要注意：在写汇编语言的时候，需要使用负号来标记负数，而不要和机器码一样认为首位的 1 就代表负数），或 <code>beq</code>、<code>bgtz</code> 等比较跳转指令，因为它们要让两个寄存器的值相比并让 PC 偏移 offset 这么多，刚好利用了全部的字段。还有存取指令，例如 <code>sw</code>、<code>lw</code>，它们在使用时需要对地址指定一个偏移值，也会用到立即数字段。</p></li></ul><table><thead><tr><th>op</th><th>rs</th><th>rt</th><th>offset or immediate</th></tr></thead><tbody><tr><td>6</td><td>5</td><td>5</td><td>16</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-3"><p>J 型指令<br>J 型指令很少，常见的为 <code>j</code> 和 <code>jal</code>。他们需要直接跳转至某个地址，而非利用当前的 PC 值加上偏移量计算出新的地址，因此需要的位数较多。</p></li></ul><table><thead><tr><th>op</th><th>address</th></tr></thead><tbody><tr><td>6</td><td>26</td></tr></tbody></table><div class="note info">            <p>严格来说，并非所有的指令都严格遵守上面三种格式，有的如 <code>eret</code>、<code>syscall</code> 指令一样没有操作数；有的如 <code>jalr</code> 指令一样某些字段被固定为某个值。不过，就大部分指令而言，都可按上面三种格式进行解释</p>          </div><ul class="lvl-0"><li class="lvl-2"><p>表格解释</p><ul class="lvl-2"><li class="lvl-4">op：也称 opcode、操作码，用于标识指令的功能。CPU 需要通过这个字段来识别这是一条什么指令。不过，由于 op 只有 6 位，不足以表示所有的 MIPS 指令，因此在 R 型指令中，有 func 字段来辅助它的功能。</li><li class="lvl-4">func: 辅助 op 识别指令。</li><li class="lvl-4">rs, rt, rd: 通用寄存器的代号，并不单指某一寄存器。范围是 <code>$0</code>~<code>$31</code>，用机器码表示就是 00000~11111。</li><li class="lvl-4">shamt: 移位数，用于移位指令。</li><li class="lvl-4">offset: 地址偏移量。</li><li class="lvl-4">immediate: 立即数。</li><li class="lvl-4">address: 跳转目标地址，用于跳转指令。</li></ul></li></ul><div class="note info">            <p><a href="https://cscore.e1.buaa.edu.cn/assets/cscore-assets/MIPS-C%E6%8C%87%E4%BB%A4%E9%9B%86_%E6%A0%A1%E5%AF%B9%E5%AE%8C%E6%88%90%E7%89%88_-%E6%8C%87%E4%BB%A4%E6%8E%92%E5%BA%8F.pdf">MIPS-C 指令集由此查看</a>。</p>          </div><h2 id="扩展指令和伪指令">扩展指令和伪指令</h2><h3 id="扩展指令（Pseudo-Instruction）">扩展指令（Pseudo Instruction）</h3><p>对基本指令的转写（例如用标签代替立即数），或对操作数的略写等，被称作扩展指令。<br>扩展指令的功能主要是简化程序。汇编器将一些常用、但标准指令集不提供的功能封装为一条指令；或者改变现有指令的操作数的形式或个数，使其以新的形式出现。需要注意的是，它们只是形式上是一条新指令，而实际上，在汇编器将其汇编之后，还是使用标准指令来实现的。<br>最常用到的一条扩展指令是 <code>li</code> 指令，它用来为某个寄存器赋值，比如 <code>li $a0,100</code> 就是将 <code>100</code> 赋给 <code>$a0</code> 寄存器。汇编器在翻译这条扩展指令时会根据需要，将它翻译成不同的基本指令或基本指令的组合。譬如：</p><ul class="lvl-0"><li class="lvl-2"><p>所赋的值少于等于 16 位，则等价于用 <code>addiu</code> 指令，比如 <code>addiu $a0, %0, 0x00001000</code>。</p></li><li class="lvl-2"><p>所赋的值大于 16 位，则等价于用 <code>lui</code> 和 <code>ori</code> 指令，即先将高 16 位装在在寄存器的前面，再用或运算补充低 16 位，比如 <code>lui $a1, 0x00001234</code> 和 <code>ori $a0, $a1, 0x00004321</code>。</p></li></ul><p>另一条常用的扩展指令是 <code>la</code> 指令，这条指令与 <code>li</code> 指令非常类似，都是为寄存器赋值，只不过是使用标签来为寄存器赋值。经过了前面的学习，大家应该已经知道标签本质上对应一个 32 位地址，但 <code>li</code> 指令并不能直接使用标签来为寄存器赋值，必须要使用 <code>la</code>。比如 <code>la $t0, fibs</code> 这条指令就是把 <code>fibs</code> 这个标签的地址存入 <code>$t0</code> 中。</p><h3 id="伪指令（Directives）">伪指令（Directives）</h3><p>伪指令（Directives）是用来指导汇编器如何处理程序的语句，有点类似于其他语言中的预处理命令。伪指令不是指令，它并不会被编译为机器码，但他却能影响其他指令的汇编结果。常用的伪指令有以下几个：</p><ul class="lvl-0"><li class="lvl-2"><p><code>.data</code>：用于预先存储数据的伪指令的开始标志。参数为 <code>address</code>，表明数据的初始地址。若无参数，则初始地址设为默认地址。</p></li><li class="lvl-2"><p><code>.text</code>：程序代码指令开始的标志。同上</p></li><li class="lvl-2"><p><code>.word</code>：以字为单位存储数据。格式：<code>[name]: .word [data1], [data2], ...</code>，以字为单位连续存储数据 <code>data1, data2, ...</code> 初始地址保存在标签 <code>name</code> 当中。</p></li><li class="lvl-2"><p><code>.asciiz</code>：以字节为单位存储字符串。末尾自动添加 <code>\0</code>。格式：<code>[name]: .asciiz &quot;[content]&quot;</code>，以字节为单位存储字符串，末尾以 NULL 结束，初始地址保存在标签 <code>name</code> 当中。</p></li></ul><div class="tips"><p>什么是以字节为单位存储字符串呢？举个例子，<code>hello</code> 中每个字母占用一个字节，然后 <code>\0</code> 占用一个字节（0x00）。</p></div><ul class="lvl-0"><li class="lvl-2"><p><code>.space</code>：申请若干个字节的未初始化的内存空间。格式：<code>[name]: .space [n]</code>，申请 n 个字节未初始化的空间，初始地址保存在标签 <code>name</code> 当中。<br><code>.space n</code> 即申请 n 个字节的未初始化的内存空间。</p></li></ul><h2 id="MIPS-指令初步">MIPS 指令初步</h2><div class="note info">            <p>该节学习自<a href="https://kamonto.github.io/Kamonto_blog/2025/09/07/%E4%B8%80%E6%9C%AC%E4%B9%A6%E6%95%99%E4%BD%A0%E9%80%9A%E5%85%B3%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%8A%EF%BC%89/">Kamonto’s Blog《一本书教你通关计组实验》</a>。</p>          </div><h3 id="位运算">位运算</h3><blockquote><p>四则运算是更复杂程序的基石，而位运算是四则运算的基石。<br><em>——麦瑟尔夫</em></p></blockquote><p>本节介绍 <code>and or xor nor andi ori xori</code> 这几种位运算。</p><p>它们的格式都是 <code>op rs, rt, rd</code>，即把 <code>rt</code> 和 <code>rd</code> 两个寄存器的内容进行运算，运算结果存入 <code>rd</code> 寄存器。<ins>运算结果写前面</ins>。</p><p>首先是与运算、或运算、异或运算。正如其名，非常好懂。<br>然后是或非运算，有一个小技巧，就是要对一个寄存器取反，可以利用或非运算来完成（MIPS 指令集没有提供取反指令）：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nor </span>$<span class="built_in">t0</span>, $<span class="built_in">t0</span>, $<span class="number">0</span></span><br></pre></td></tr></table></figure><div class="tips"><p>别忘了 $0 永远是 0。</p></div><p>如果需要把一个寄存器的值和一个立即数进行运算，则需要用到末尾带“i”的指令（即 immediate），正如与立即数、或立即数、异或立即数。</p><div class="warning"><p>注意：使用立即数的指令，立即数必须写在第三位。</p></div><h3 id="几条扩展指令">几条扩展指令</h3><ul class="lvl-0"><li class="lvl-2"><p><code>li</code>：<code>li rs, immediate</code>，将立即数赋给寄存器。</p></li><li class="lvl-2"><p><code>move</code>: <code>move rs, rt</code>, 将后一个寄存器的值赋给前一个寄存器。</p></li><li class="lvl-2"><p><code>la</code>：<code>la rd, label</code>，将标签对应的地址（十六进制值）赋给寄存器，后续我们讨论地址和内存的细节内容。</p></li></ul><h3 id="加减法">加减法</h3><p>本节介绍 <code>add sub addu subu addi addiu</code> 几种加减法运算。</p><p>四则运算和位运算相比多了两个棘手的问题，即符号和溢出。</p><blockquote><p>首先来谈正负性的问题，其实这根本就不是个问题。如果你是补码领域大神的话，你就会发现，在不考虑位溢出的情况下（这里“不考虑位溢出”的意思是发生溢出时会将溢出位舍去，相反“考虑溢出”的意思是如果发生溢出直接报错），二进制补码的正负性其实是相同的，这也正是补码的优越之处。不信可以看看下面这些例子：</p><p>在 32 位的条件下，<code>0x3 + 0xffffffff</code> 的结果是多少？你的做法或许是这样的：首先，你发现 <code>0xffffffff</code> 的最高位是 <code>1</code> ，于是断定它是负数，将其一段操作转换成 <code>-1</code> ，再与 <code>0x3</code> 相加，得到结果 <code>0x2</code> 。但实际上，我直接把它们两个相加，结果就是 <code>0x100000002</code> ，舍去溢出的最高位，直接就得到了 <code>0x2</code> 。</p><p>再举一个例子，同样是在 32 位的条件下，<code>0xfffffffd - 0xffffffff</code> 的结果是多少？细心的你可能会将这个式子转换成 <code>(-3) - (-1)</code> ，结果是 <code>-2</code> ，也就是 <code>0xfffffffe</code> 。但是我不管正负，直接进行运算，发现被减数小于减数，我直接在被减数前面补一个溢出位 1 ，于是原式变成 <code>0x1fffffffd - 0xffffffff</code> ，结果等于 <code>0xfffffffe</code> 。</p><p><em>摘自原书</em></p></blockquote><p>这是 <code>addu</code>（无符号加） 和 <code>subu</code>（无符号减）的原理。因为它们把操作数当作无符号数直接运算，然后直接把溢出部分舍去。<ins>但是其运算结果还是有符号的！！！</ins></p><p>而 <code>add</code> 和 <code>sub</code> 则不会简单地舍去溢出位，而是在溢出时抛出异常。如果使用这种运算，需要注意判断是否溢出。</p><p>此外 <code>add</code> 和 <code>addu</code> 也有它们的立即数版本 <code>addi</code> 和 <code>addiu</code>（注意不是 <code>addui</code>），<ins>而 <code>subi</code> 和 <code>subiu</code> 是伪指令</ins>，和上面一样它们也必须把立即数放在第三位。</p><h3 id="乘除法">乘除法</h3><p>本节介绍 <code>mult div mfhi mflo mthi mtlo</code> 几种乘除法运算。</p><p>加减法至多只溢出一位，而乘除法则不然，两个 32 位数字相乘，结果可达 64 位，必须要用新的处理方法。<br>于是我们想到了之前提到的<a href="#specialReg">特殊寄存器</a> <code>HI</code> 和 <code>LO</code>，在乘法运算的时候，直接把高 32 位放到 <code>HI</code> 寄存器里面，低 32 位放到 <code>LO</code> 寄存器里面，就万事大吉了。用法 <code>mult rs, rt</code>，即把 <code>rs</code> 和 <code>rt</code> 两个寄存器的内容相乘。</p><div class="tips"><p>为什么不要指定结果保存的位置？<br>因为结果放到了 <code>HI</code> 和 <code>LO</code> 里面，自然就只需要指定两个操作数的寄存器了。</p></div><p>这两个是特殊寄存器，不能直接调用，要想使用里面的数，必须提前取出来，这就是 <code>mfhi</code> 和 <code>mflo</code> 存在的意义。用 <code>mfxx rs</code> 把 <code>HI</code> 或者 <code>LO</code> 寄存器的值存入 <code>rs</code> 寄存器。<br>当然也有反过来的用法，即手动把数字写进 <code>HI</code> 和 <code>LO</code> 寄存器。用 <code>mthi</code> 和 <code>mtlo</code> 指令。用 <code>mthi rs</code> 把 <code>rs</code> 寄存器的值存入 <code>HI</code> 寄存器，用 <code>mtlo rs</code> 把 <code>rs</code> 寄存器的值存入 <code>LO</code> 寄存器。</p><p>除法也利用这两个寄存器，不过是 <code>HI</code> 存<ins>余数</ins>而 <code>LO</code> 存<ins>商</ins>。切勿记反。切勿记反。切勿记反。<br>若除数是负数，处理方法与 C 语言中相同：被除数为正数时，余数为 0 或正数；被除数为负数时，余数为 0 或负数。如下表：</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>7</td><td>3</td><td>2</td><td>1</td></tr><tr><td>7</td><td>-3</td><td>-2</td><td>1</td></tr><tr><td>-7</td><td>3</td><td>-2</td><td>-1</td></tr><tr><td>-7</td><td>-3</td><td>2</td><td>-1</td></tr></tbody></table><h3 id="几个单位">几个单位</h3><p>自此节开始要进入内存的学习，先通过了解单位来入门。</p><ol><li class="lvl-3"><p>位（bit）: 1 位代表 1 个 二进制值（0 或 1）。比如二进制数 <code>0b10110</code> 就是 5 位。<ins>十六进制数 <code>0xabcd</code> 的每一个数字都能转换成 4 位二进制数</ins>，所以这个数是 16 位。</p></li><li class="lvl-3"><p>字节（byte）: 8 位组成 1 个字节。一个 32 位的寄存器，其大小就是 4 字节。<ins>字节是地址的基本单位</ins>。</p></li><li class="lvl-3"><p>半字（halfword）: 16 位组成 1 个半字。</p></li><li class="lvl-3"><p>字（word）: 32 位组成 1 个字。</p></li></ol><p><img src="/posts/1f9d902/address.png" alt="address"></p><p>红色：8 位，1 字节蓝色：16 位，1 半字绿色：32 位，1 字</p><h3 id="地址">地址</h3><p>内存空间连续而庞大，由于其连续，我们从 0 开始为其编号，称为地址。要注意每个地址代表的空间是 8 位，即一字节。也就是说字节是地址的基本单位。<br>举例来说，倘若要把数据 <code>0x12345678</code> 存储地址 <code>0x0</code>，那么按每个地址存入 8 位的逻辑，<code>0x0 0x1 0x2 0x3</code> 四个地址存入了 32 位，刚好存下这串数字。</p><h4 id="小端存储">小端存储</h4><p>小端存储指的是数据的低位字节保存在内存的低地址中。以上面的存储为例，数据的低位字节是 <code>0x78</code>，保存在地址 <code>0x0</code> 中、<code>0x56</code> 存储在 <code>0x1</code> 中，以此类推。</p><h4 id="大端存储">大端存储</h4><p>大端存储则相反，数据低位字节存储在内存的高地址中。此处不再举例。</p><h3 id="按字访存">按字访存</h3><p>本节介绍 <code>lw sw</code> 两个访存指令。</p><p>顾名思义，上述两个指令表示 <code>store word</code> 和 <code>load word</code>，即向内存中存储或读取一个字。<br><code>sw rt, offset(rs)</code> 表示将 <code>rt</code> 这个寄存器的内容写入 “<code>rs</code> 寄存器中储存的值 + <code>offset</code> 这个<ins>立即数</ins>或<ins>标签</ins>表示的地址”表示的地址处。<br>略微有点绕。举例而言，<code>$t1 = 0x12345678</code> <code>$t2 = 0x00000007</code>，若要把 <code>$t1</code> 的值储存到地址 <code>0x8</code> 和 <code>0x4</code> 那么分别要如何写呢？<br>答案是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sw </span>$<span class="built_in">t1</span>, <span class="number">1</span>($<span class="built_in">t2</span>)</span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t1</span>, -<span class="number">3</span>($<span class="built_in">t2</span>)</span><br></pre></td></tr></table></figure><p>这就是所谓“表示的地址 + 偏移量”表示的地址。<br>要注意，括号中只能是一个寄存器。来看以下例子：<br>想要构建一个 <code>int</code> 类型数组，首地址为标签 <code>arr</code>，那么如何将 <code>$t1</code> 存入 <code>arr[3]</code> ？<br>首先我们要明确，<code>int</code> 类型是 4 字节，即一个数要占用 4 个地址。那么 <code>arr[3]</code> 的起始地址是 <code>arr + 12</code>。那么你有可能写成下面的形式：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sw </span>$<span class="built_in">t1</span>, <span class="number">12</span>(arr)</span><br></pre></td></tr></table></figure><p>这就掉入了惯性思维的陷阱。<code>arr</code> 可以放在括号内吗？甚不然也。因为 <code>arr</code> 只是一个标签，而标签在编译时会被翻译成立即数，而立即数是不能放在括号内的。<br>正确的写法应该是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li $<span class="built_in">t2</span>, <span class="number">12</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">t1</span>, arr($<span class="built_in">t2</span>)</span><br></pre></td></tr></table></figure><p>也就是说，先用一个寄存器把偏移量 12 保存下来，再加上 <code>arr</code> 标签得到 <code>arr + 12</code>，再用这个地址作为 <code>sw</code> 指令的第二个参数。</p><div class="tips"><p>一般来说我们在括号里写基位置 <code>base</code>，括号外是偏移量 <code>offset</code>。但是这不是绝对的！上面我们就把偏移量写在内而基位置写在外，得到了一样的效果。</p></div><p><code>lw</code> 要注意的事项与上面一致，只不过作用是把后面的地址中保存的值取到了前面的寄存器中。</p><div class="warning"><p>注意：<code>lw</code> 和 <code>sw</code> 第二个参数计算出的地址必须合法（在内存范围内，且非负），且为 4 的倍数，否则会抛出异常！</p></div><h4 id="与-move-和-la-的区别">与 move 和 la 的区别</h4><p>这时候你可能会有疑惑：<code>move $t1, $t2</code> 和 <code>lw $t1, 0($t2)</code> 有区别吗？答案是有的。因为 <code>move</code> 做的是把第二个寄存器的值直接赋给第一个寄存器，而 <code>lw</code> 做的是根据第二个寄存器的值<ins>去内存空间找相应的地址保存的数据</ins>，再赋给第一个寄存器。<br><code>la</code> 也是如此，<code>la $t1, label</code> 把标签表示的地址直接赋给了第一个寄存器，而 <code>lw $t1, label($0)</code> 则是根据标签表示的地址去内存中找到数据，赋给第一个寄存器。</p><p>也就是说，要注意地址和地址保存的数的区别。地址本身也是一串数，而这串数相当于一个门牌号，门后面就是这个地址保存的数。</p><h3 id="按半字、字节访存">按半字、字节访存</h3><p>本节将介绍 <code>sh lh sb lb</code> 几个访存指令。</p><p><code>sh lh</code> 全称 <code>store halfword</code> 和 <code>load halfword</code>，用于将一个半字（2 字节，16 位）从寄存器写入内存，或反过来。<br><code>sb lb</code> 全称 <code>store byte</code> 和 <code>load byte</code>，用于将一个字节（8 位）从寄存器写入内存，或反过来。</p><p>这四条指令用法和 <code>lw sw</code> 一致，不再赘述。只有一些细节需要关注：</p><ul class="lvl-0"><li class="lvl-2"><p><code>sh lh</code> 要求计算出的地址是 2 的倍数，而 <code>sb lb</code> 没有要求。</p></li><li class="lvl-2"><p><code>sh sb</code> 指令在将第一个寄存器的值存入内存中时，倘若寄存器中的值超过了标定的位数，则会将高位舍去，只存入低位。<br>比如 <code>$t1 = 0x12345678</code>。现在执行 <code>sb $t1 offset(base)</code>，那么只有 <code>$t1</code> 中的低 8 位会被存入内存（<code>0x78</code> 小端存储），高 24 位会被舍去。</p></li><li class="lvl-2"><p><code>lh lb</code> 指令在寄存器中已经有值的情况下往里面存数据时，会从低到高存入所需的数据，其余直接置 0。<br>比如 <code>$t1 = 0x12345678</code>。现在执行 <code>lb $t1 offset(base)</code>。如果地址保存的数是 <code>0xab</code>，那么 <code>$t1</code> 的低 8 位会写入 <code>0xab</code> 而高 24 位直接置 0，即变成 <code>0x000000ab</code>。</p></li></ul><h3 id="跳转指令">跳转指令</h3><h4 id="绝对跳转">绝对跳转</h4><p>本节将介绍 <code>j jal jr jalr</code> 几条跳转指令。</p><p>跳转指令有点像 C 语言中的 <code>goto</code>，可以将程序运行的位置跳转到指定位置。</p><p><code>j</code>，即 <code>jump</code>，只有一种用法就是 <code>j label</code>，把<code>label</code> 写在目的地的前一行，就可以在运行完 <code>j</code> 指令后立即跳转到 <code>label</code> 处执行。</p><div class="warning"><p><code>j</code> 指令的目的地只能用 <code>label</code> 来表示，不能直接用立即数。</p></div><p><code>label</code> 标识了目的地这行指令的地址。也就是说每写一行指令，都会转换成机器码在内存中保存，占用一个地址。前面所说 <code>sw sh sb</code> 指令会往内存写入数据，也占用地址。储存数据区和储存指令区是分开的，前者占用 <code>0x00000000 - 0x00002fff</code> 段，被称为 <code>.data</code> 段，后者占用 <code>0x00003000</code> 往后，被称作 <code>.text</code> 段。</p><div class="tips"><p>MIPS 语言中的每条指令，转换为机器码都固定为 32 位，所以每条指令的地址 Address 也会按照顺序每条 +4 递增。</p></div><p><code>jal jr</code>，是一对指令，需要同时出现。<code>jal label</code> 同样可以跳转到 <code>label</code> 对应的位置，但它会把当前指令的<ins>下一条指令</ins>的地址写入 31 号寄存器 <code>$ra</code> 中，即 <code>PC + 4</code>，<code>PC</code> 即当前指令的地址。<code>jr $ra</code> 则又回到　<code>jal</code> 的下一行继续执行。</p><div class="note info">            <p>理论上，<code>jr</code> 后可以接任意寄存器，它的作用本质上是将寄存器中的数当作地址，实现跳转。但一般和 <code>jal</code> 搭配使用。</p>          </div><div class="tips"><p>为什么不跳回到 <code>jal</code> 的地址？<br>因为这样会导致 <code>jal</code> 再次执行，造成跳转的死循环。</p></div><p><code>jalr</code>，是 <code>jal</code> 和 <code>jr</code> 的组合指令。<code>jalr</code> 要指定两个寄存器，用来保存 目的地 和 <code>PC + 4</code>，例如 <code>jalr $t1, $t2</code> 是跳转到 <code>$t2</code> 寄存器保存的地址，并把当前指令的<ins>下一条指令</ins>的地址写入 <code>$t1</code> 寄存器中。</p><h4 id="相对跳转">相对跳转</h4><p>本节将介绍 <code>beq bne bgtz bgez bltz blez</code> 几条条件跳转指令。</p><p>条件跳转指令的特点是可以根据一定的条件选择是否跳转。</p><p><code>beq</code>，即 <code>branch equal</code>，表示当两个寄存器的值相等时，跳转到目的地。<code>beq $t0, $t1, label</code>。</p><p>相对应的是 <code>bne</code> 即 <code>branch not equal</code>，在 <code>$t0 !=  $t1</code> 时跳转。</p><p>除了等于比较，当然还有大于，小于比较。于是就有了 <code>bgt</code>（<code>branch if greater than</code>）、<code>bge</code>（<code>branch if greater or equal</code>）、<code>blt</code>（<code>branch if less than</code>）、<code>ble</code>（<code>branch if less or equal</code>）四条指令。</p><p>要注意，以上的指令是<ins>有符号</ins>比较的，如认为 <code>0x0</code> 大于 <code>0xffffffff</code>，于是又有了这四条指令的无符号变种，即 <code>bgtu</code>、<code>bgeu</code>、<code>bltu</code>、<code>bleu</code>。</p><p>有时候我们需要将寄存器的值和 0 比较，这很简单，只要把上述指令的第二个操作数用 <code>$0</code> 替换即可。但是 MIPS 提供了更优雅的处理方法：对于 <code>beq bne bgt bge blt ble</code> 这六条指令，在后面加上字母 <code>z</code> ，变成 <code>beqz bnez bgtz bgez bltz blez</code> ，就可以表示和 0 进行比较，相应地，第二个寄存器参数就被取消掉了。例如 <code>bgez $t0, label</code> 指令，就表示如果 <code>$t0</code> 寄存器中的值大于等于 0 ，则跳转到 <code>label</code> 标签所在的位置；否则不跳转。</p><blockquote><p>（你问我为什么 <code>bgtu bgeu bltu bleu</code> 后面不能加字母 <code>z</code> ？再仔细想想，你会为这个问题感到好笑的~）</p></blockquote><p>考察相对跳转指令中，<code>label</code> 被翻译成了什么：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li $<span class="built_in">s0</span>, <span class="number">1</span></span><br><span class="line">li $<span class="built_in">s1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, target3</span><br><span class="line">li $<span class="built_in">t6</span>, <span class="number">7</span></span><br><span class="line"><span class="symbol">target3:</span></span><br><span class="line">li $<span class="built_in">t7</span>, <span class="number">8</span></span><br></pre></td></tr></table></figure><p><img src="/posts/1f9d902/label.png" alt="label"></p><p>Amazing 啊，这个 <code>target3</code> 并没有像绝对跳转指令那样被翻译成了 <code>li $t7, 8</code> 这条指令的地址，而是一个神奇的 <code>0x00000001</code>。<br>原来，条件跳转指令又被叫做相对跳转指令不是没有原因的。它的目的地不是一个指令的地址，而是<ins>相对跳转指令</ins>和<ins>目的地</ins>之间的<ins>指令条数</ins>。<br>什么意思呢？上例中目的地是 <code>target3</code>，<code>beq</code> 和它中间隔了一条 <code>li $t6, 7</code> 指令，所以相对距离是 1。倘若二者中间再加一条 <code>li $t5, 5</code> 之类的指令，那么相对距离就变成 2。</p><h3 id="移位运算">移位运算</h3><p>本节将介绍 <code>sll srl sra sllv srlv srav lui</code> 几条移位运算指令。</p><p>左移只有一种，那就是 <code>shift left logical</code>，<code>sll</code>。使用 <code>sll $t1, $t0, imm5</code>，即把 <code>$t0</code> 的数左移 <code>imm5</code> 位，结果存入 <code>$t1</code>。<code>imm5</code> 表示这个立即数最高只有 5 位，即左移的位数只能是 0 到 31。</p><p>右移情况则要复杂。它分为逻辑右移（高位补 0）和算术右移（高位补符号位）。逻辑右移的指令是 <code>srl</code>（<code>shift right logical</code>），算术右移的指令是 <code>sra</code>（<code>shift right arithmetic</code>），用法和 <code>sll</code> 指令完全相同。</p><p>除了以立即数为移动位数，还可以使用寄存器中的值作为移动位数。这就需要用到 <code>sllv srlv srav</code> 指令了。在使用指令时，将 <code>imm5</code> 替换为寄存器即可。如 <code>sllv $t1, $t0, $s0</code> ，就是将 <code>$t0</code> 寄存器中的数据左移 <code>$s0</code> 寄存器中的数据这些位，存入 <code>$t1</code> 寄存器中。</p><p>倘若寄存器中的值超过了 5 位，那么会舍弃高位，只保留低 5 位作为移动位数。</p><p>最后是 <code>lui</code> 即 <code>load upper immediate</code>。它把一个立即数左移 16 位然后再写入寄存器，用法 <code>lui $t0, imm16</code> 。例如 <code>lui $t0, 0x1234</code> 的结果就是向 <code>$t0</code> 寄存器中写入 <code>0x12340000</code> 。</p><h3 id="条件赋值">条件赋值</h3><p>本节将介绍 <code>slt sltu slti sltiu</code> 几条条件赋值指令。</p><p><code>slt</code> (<code>set less than</code>) 指令表示如果 <code>$t0</code> 中的值小于 <code>$t1</code> 中的值，则将 <code>$t2</code> 中的值设置为 1，否则设置为 0。<br>用法：<code>slt $t2, $t0, $t1</code>。</p><p>当然这也是有符号的比较，无符号变种是 <code>sltu</code>。除此之外还有和立即数比较的变种 <code>slti</code> 和 <code>sltiu</code>。</p><hr><h1 id="MIPS-语法">MIPS 语法</h1><h2 id="条件语句">条件语句</h2><p>对于下面这个简单的 C 语言条件语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以巧妙地利用跳转指令来在 MIPS 中实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bgt </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, <span class="keyword">branch1 </span><span class="comment"># bgt: branch greater than, $s0 = a, $s1 = b</span></span><br><span class="line"><span class="keyword">j </span><span class="keyword">branch2 </span><span class="comment"># else</span></span><br><span class="line"><span class="keyword">branch1:</span></span><br><span class="line"><span class="keyword"></span>  li $<span class="built_in">s0</span>, <span class="number">0</span> <span class="comment"># a = 0</span></span><br><span class="line">  <span class="keyword">j </span>end <span class="comment"># end of if statement</span></span><br><span class="line"><span class="keyword">branch2:</span></span><br><span class="line"><span class="keyword"></span>  li $<span class="built_in">s1</span>, <span class="number">0</span> <span class="comment"># b = 0</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">li $<span class="built_in">s2</span>, <span class="number">0</span> <span class="comment"># c = 0</span></span><br></pre></td></tr></table></figure><p>简单来说，我们把 <code>if</code> 换成了 <code>b</code> 型跳转指令（相对跳转，因为 <code>if</code> 和其一样包含了条件判断），而 <code>else</code> 换成了 <code>j</code> 型跳转指令（前面已经做过条件判断了），从而实现分支的分离。</p><p>要注意，branch1 的结尾我们使用 <code>j end</code> 来强制脱离条件块，否则会进入 branch2。</p><p>如果增加一个分支，让 <code>a == b</code> 时把 <code>a b</code> 均设为 0，要如何写呢？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bgt </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, <span class="keyword">branch1 </span><span class="comment"># $s0 = a, $s1 = b</span></span><br><span class="line"><span class="keyword">blt </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, <span class="keyword">branch2 </span><span class="comment"># else if a &lt; b</span></span><br><span class="line"><span class="keyword">j </span><span class="keyword">branch3 </span><span class="comment"># else</span></span><br><span class="line"><span class="keyword">branch1:</span></span><br><span class="line"><span class="keyword"></span>  li $<span class="built_in">s0</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">j </span>end</span><br><span class="line"><span class="keyword">branch2:</span></span><br><span class="line"><span class="keyword"></span>  li $<span class="built_in">s1</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">j </span>end</span><br><span class="line"><span class="keyword">branch3:</span></span><br><span class="line"><span class="keyword"></span>  li $<span class="built_in">s0</span>, <span class="number">0</span></span><br><span class="line">  li $<span class="built_in">s1</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">  li $<span class="built_in">s2</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure><p>倘若条件判断更复杂，比如要同时满足两个条件（<code>&amp;&amp;</code>，与）或者至少满足一个条件（<code>||</code>，或）该怎么处理？</p><p>其实不难，如果要至少满足一个条件才能进入的代码块，我们可以让这几个条件满足时跳转到同一个分支：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b || b &gt; c)</span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>对应的 MIPS 代码如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bgt </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, <span class="keyword">branch1</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bgt </span>$<span class="built_in">s1</span>, $<span class="built_in">s2</span>, <span class="keyword">branch1 </span><span class="comment"># or</span></span><br><span class="line"><span class="keyword">j </span><span class="keyword">branch2 </span><span class="comment"># else</span></span><br><span class="line"><span class="keyword">branch1:</span></span><br><span class="line"><span class="keyword"></span>  li $<span class="built_in">s0</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">j </span>end</span><br><span class="line"><span class="keyword">branch2:</span></span><br><span class="line"><span class="keyword"></span>  li $<span class="built_in">s1</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">  li $<span class="built_in">s2</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果是逻辑与，要怎么实现呢？毕竟一条指令只能判断一个条件，不能同时判断多个，比如下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b &amp;&amp; b &gt; c)</span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>其实我们不是非要把逻辑与写成 <code>&amp;&amp;</code> 的样子，在 C 语言中我们要讲求代码编写的优雅，而在这里我们需要明晰其本质：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">  &#123;</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>就是说，两个条件只有都满足才能使 <code>a</code> = 0，其余情况都是 <code>b</code> = 0。用一个条件语句的嵌套来实现了这个效果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bgt </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, <span class="keyword">branch1 </span><span class="comment"># if outside</span></span><br><span class="line"><span class="keyword">j </span><span class="keyword">branch2 </span><span class="comment"># else outside</span></span><br><span class="line"><span class="keyword">branch1: </span></span><br><span class="line">  <span class="keyword">bgt </span>$<span class="built_in">s1</span>, $<span class="built_in">s2</span>, <span class="keyword">branch3 </span><span class="comment"># if inside</span></span><br><span class="line">  <span class="keyword">j </span><span class="keyword">branch2 </span><span class="comment"># else inside = else outside !!!</span></span><br><span class="line"><span class="symbol">  branch3:</span></span><br><span class="line">    li $<span class="built_in">s0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">j </span>end</span><br><span class="line"><span class="keyword">branch2:</span></span><br><span class="line"><span class="keyword"></span>  li $<span class="built_in">s1</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">  li $<span class="built_in">s2</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="循环语句">循环语句</h2><h3 id="While">While</h3><p>while 循环有两种写法，譬如下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">  b = a;</span><br><span class="line">  a++;</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>一种是“进入循环时条件跳转，离开循环时绝对跳转”：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">li $<span class="built_in">s0</span>, <span class="number">0</span> <span class="comment"># a = 0 循环变量</span></span><br><span class="line">li $<span class="built_in">s1</span>, <span class="number">5</span> <span class="comment"># 循环次数</span></span><br><span class="line"><span class="symbol">while:</span></span><br><span class="line">  <span class="keyword">blt </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, loop <span class="comment"># a &lt; 5</span></span><br><span class="line">  <span class="keyword">j </span>end <span class="comment"># a &gt;= 5</span></span><br><span class="line"><span class="symbol">  loop:</span></span><br><span class="line">    <span class="keyword">move </span>$<span class="built_in">s1</span>, $<span class="built_in">s0</span> <span class="comment"># b = a</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">s0</span>, $<span class="built_in">s0</span>, <span class="number">1</span> <span class="comment"># a++</span></span><br><span class="line">    <span class="keyword">j </span>while <span class="comment"># 循环</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">  li $<span class="built_in">s0</span>, <span class="number">0</span> <span class="comment"># a = 0</span></span><br></pre></td></tr></table></figure><p>这种写法在循环条件用 <code>||</code> 连接时很方便修改，只需要增加一个到 <code>loop</code> 的条件跳转指令即可。</p><p>一种是“进入循环时不跳转，离开循环时条件跳转”：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">li $<span class="built_in">s0</span>, <span class="number">0</span> <span class="comment"># a = 0 循环变量</span></span><br><span class="line">li $<span class="built_in">s1</span>, <span class="number">5</span> <span class="comment"># 循环次数</span></span><br><span class="line"><span class="symbol">while:</span></span><br><span class="line">  <span class="keyword">bge </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, end <span class="comment"># a &gt;= 5, break</span></span><br><span class="line">    <span class="keyword">move </span>$<span class="built_in">s1</span>, $<span class="built_in">s0</span> <span class="comment"># b = a</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">s0</span>, $<span class="built_in">s0</span>, <span class="number">1</span> <span class="comment"># a++</span></span><br><span class="line">    <span class="keyword">j </span>while <span class="comment"># 循环</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">  li $<span class="built_in">s0</span>, <span class="number">0</span> <span class="comment"># a = 0</span></span><br></pre></td></tr></table></figure><p>这种写法在循环条件用 <code>&amp;&amp;</code> 连接时很方便修改，只需要增加一个到 <code>end</code> 的条件跳转指令即可。</p><div class="tips"><p>这种写法相当于给循环条件取了个反。</p></div><h3 id="For">For</h3><p>for 循环可以等价转换成 while 循环，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i * i &lt; n; i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i * i &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组">数组</h2><h3 id="一维数组">一维数组</h3><p>我们可以在 <code>.data</code> 段中开辟一段连续的内存空间作为数组存储数据。比如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">.data</span></span><br><span class="line"><span class="symbol">array1:</span> <span class="meta">.space</span> <span class="number">20</span></span><br><span class="line"><span class="symbol">array2:</span> <span class="meta">.space</span> <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line">li $<span class="built_in">s0</span>, <span class="number">1</span>   <span class="comment"># $s0 = 1</span></span><br><span class="line">li $<span class="built_in">s1</span>, <span class="number">2</span>   <span class="comment"># #s1 = 2</span></span><br><span class="line">li $<span class="built_in">t0</span>, <span class="number">0</span></span><br><span class="line">li $<span class="built_in">t1</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">s0</span>, array1($<span class="built_in">t0</span>)   <span class="comment"># array1[0] = $s0</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">s1</span>, array1($<span class="built_in">t1</span>)   <span class="comment"># array1[1] = $s1</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">s0</span>, array2($<span class="built_in">t0</span>)   <span class="comment"># array2[0] = $s0</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">s1</span>, array2($<span class="built_in">t1</span>)   <span class="comment"># array2[1] = $s1</span></span><br></pre></td></tr></table></figure><p>首先要注意 <code>.space</code> 开辟的空间是以<ins>字节</ins>为单位的。因此这里 <code>array1</code> 的大小为 20 字节，如果存储 int 类型的数据只能存储 5 个。</p><div class="note warning">            <p>我们要存储的每个数据都要占据 4 个字节的空间（哪怕是只占据 1 字节的 <code>char</code> 型数据也建议直接用 4 字节来存储，我们的内存足够多，不需要担心不够用，使用 4 字节存储和寄存器的位数一致，也可以非常方便地使用 sw 和 lw 指令直接进行存取，也可以降低出错的概率。</p>          </div><p><code>array1</code> 和 <code>array2</code> 两个标签在用 <code>lw</code> 或 <code>sw</code> 的时候都会被翻译成立即数，作为地址。实际上，它们代表的正是数组的首地址。在上面的例子中，若 <code>.data</code> 段是从 <code>0x00000000</code> 开始，那么 <code>array1</code> 就是 <code>0x00000000</code>，而 <code>array2</code> 就是 <code>0x00000014</code>（即十进制的 20）。因为 <code>array1</code> 占据了 <code>0x00000000</code> 到 <code>0x00000013</code> 的 20 字节空间，<code>array2</code> 就顺延下来了。</p><div class="warning"><p>重申一次，最好保证在申请数组时，申请的字节数永远都能够被 4 整除！</p></div><p>要注意，访问数组中的值时，我们往往需要一个寄存器来保存数组的索引，这时候寄存器的值不应当是数组的下标，而是下标乘以 4 的结果。为简便计算，我们一般用位运算来计算，比如 <code>sll $t1, $t0, 2</code> 就可以将 <code>$t0</code> 中的值乘以 4 放入 <code>$t1</code> 中。</p><h3 id="二维数组">二维数组</h3><p>我们知道二维数组在存储时其实是按照一位数组的格式来存的，即第一行、第二行、第三行……紧密排列。例如在一个 m 行 n 列的二维数组 <code>matrix</code> 中，<code>matrix[i][j]</code> 和 <code>matrix[i * n + j]</code> 并没有什么区别。所以 <code>(i * n + j) * 4</code> 就是访问 <code>matrix[i][j]</code> 的地址，即寄存器中保存的值。</p><h2 id="字符串">字符串</h2><p>字符以 ASCII 码的形式存储。</p><p>在内存中，字符是按照顺序从低地址到高地址排列的。比如 <code>hello</code> 这个字符串，其中 <code>h</code> 最先写入，并写入到这个字（即 4 字节）的最低位，假定为 0x00，那么 <code>h e l l</code> 分别就是 <code>0x00 0x01 0x02 0x03</code>，<code>o</code> 被保存到下一个字去，为 <code>0x04</code>。</p><p>有两条伪指令来写入字符串：</p><ul class="lvl-0"><li class="lvl-2"><p>.asciiz<br>在字符数组末尾自动添加 <code>\0</code>。</p></li><li class="lvl-2"><p>.ascii<br>不会自动添加 <code>\0</code>。</p></li></ul><p>和 C 语言一样，MIPS 字符串也要以 <code>\0</code> 结尾。</p><div class="tips"><blockquote><p>在 <code>.data</code> 段要同时声明数组和字符串的情况，请记住一定要先声明数组，再声明字符串！道理其实很简单，因为如果先声明字符串的话，如果字符串的字节数不能被 4 整除，数组的首地址就又跑到不能被 4 整除的地方去了（叹气）。</p></blockquote></div><div class="tips"><p>一般地，能用 <code>.asciiz</code> 就别用 <code>.ascii</code>。</p></div><h2 id="宏">宏</h2><h3 id="宏的基本用法">宏的基本用法</h3><p>宏定义用于把重复的代码简化成一条语句，比如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> exit <span class="comment"># or .macro exit()</span></span><br><span class="line">li $<span class="built_in">v0</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line"></span><br><span class="line">exit <span class="comment"># or exit()</span></span><br></pre></td></tr></table></figure><p>调用宏的时候只需要使用宏名即可，若无参数，则有无括号都可以，但你也可以为其添加参数：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> getoffset(%ans, %i, %<span class="keyword">j)</span></span><br><span class="line"><span class="keyword"></span>  <span class="keyword">sll </span>%ans, %i, <span class="number">3</span> <span class="comment"># %ans = %i * 8</span></span><br><span class="line">  <span class="keyword">add </span>%ans, %ans, %<span class="keyword">j </span><span class="comment"># %ans += %j</span></span><br><span class="line">  <span class="keyword">sll </span>%ans, %ans, <span class="number">2</span> <span class="comment"># %ans *= 4</span></span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure><p>这是一个计算每行 8 列的二维数组中第 i 行第 j 列的元素地址的宏。由于关于数组的代码需要大量地获取元素地址，这样的宏就可以大幅节约代码量。</p><p>事实上，宏中带 <code>%</code> 的参量可以表示一条指令的任何一个部分，比如立即数：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> store(%p)</span><br><span class="line">  <span class="keyword">sw </span>$<span class="built_in">s1</span>, %p($<span class="number">0</span>)</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">li $<span class="built_in">s1</span>, <span class="number">1</span></span><br><span class="line">store(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>或者标签：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span></span><br><span class="line"><span class="symbol">str:</span> .asciiz <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> print(%str)</span><br><span class="line">  li $<span class="built_in">v0</span>, <span class="number">4</span></span><br><span class="line">  la $<span class="built_in">a0</span>, %str</span><br><span class="line">  <span class="keyword">syscall</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line"></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure><p>甚至指令名：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> <span class="keyword">instr(%i)</span></span><br><span class="line"><span class="keyword"></span>  %i $<span class="built_in">s2</span>, $<span class="built_in">s3</span>, $<span class="built_in">s4</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="keyword">instr(add)</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">instr(sub)</span></span><br></pre></td></tr></table></figure><div class="tips"><p>当然，指令格式与宏定义的有差别的指令就不能用了，否则会报错。</p></div><p>还有宏内部的跳转：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> <span class="keyword">branch(%d)</span></span><br><span class="line"><span class="keyword"></span>  <span class="keyword">beqz </span>%d, iszero</span><br><span class="line">  <span class="keyword">j </span>end</span><br><span class="line"><span class="symbol">  iszero:</span></span><br><span class="line">    li %d, <span class="number">114514</span></span><br><span class="line"><span class="symbol">  end:</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">li $<span class="built_in">s0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">branch($s0)</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">branch($s1)</span></span><br></pre></td></tr></table></figure><div class="warning"><p>不可从宏内跳到宏外，反之亦然。</p></div><p>甚至可以嵌套：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> para(%p)</span><br><span class="line">  <span class="keyword">instr(add)</span></span><br><span class="line"><span class="keyword"></span>  <span class="keyword">sw </span>$<span class="built_in">s1</span>, %p($<span class="built_in">s2</span>)</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> <span class="keyword">instr(%i)</span></span><br><span class="line"><span class="keyword"></span>  %i $<span class="built_in">s2</span>, $<span class="built_in">s3</span>, $<span class="built_in">s4</span></span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">li $<span class="built_in">s1</span>, <span class="number">1</span></span><br><span class="line">li $<span class="built_in">s3</span>, <span class="number">3</span></span><br><span class="line">para(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><div class="warning"><p>宏出现循环调用（比如 <code>para</code> 调用自己，或 <code>para</code> 调用 <code>instr</code>，而 <code>instr</code> 又调用 <code>para</code>），就会报错。</p></div><h3 id="宏实现函数">宏实现函数</h3><p>一般来说，我们约定俗成的参数寄存器是 <code>$a0 $a1 $a2 $a3</code> 这四个寄存器，分别存储函数的第 1、2、3、4 个参数。</p><p>若函数有返回值，我们有两种方法来用宏定义它：</p><ol><li class="lvl-3"><p>要求一个参数填入寄存器来保存返回值。</p></li><li class="lvl-3"><p>宏定义内写死返回值保存的位置，外部用 <code>move</code> 指令提取之。</p></li></ol><p>第一种比如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> my_add(%a, %<span class="keyword">b, </span>%c)</span><br><span class="line">  <span class="keyword">add </span>%c, %a, %<span class="keyword">b</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line"></span><br><span class="line">li $<span class="built_in">s0</span>, <span class="number">1</span></span><br><span class="line">li $<span class="built_in">s1</span>, <span class="number">2</span></span><br><span class="line">my_add($<span class="built_in">s0</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span>) <span class="comment"># s2 = s0 + s1</span></span><br><span class="line">my_add($<span class="built_in">s0</span>, $<span class="built_in">s1</span>, $<span class="number">0</span>) <span class="comment"># no return</span></span><br></pre></td></tr></table></figure><div class="tips"><p>小技巧：<code>$0</code> 永远是 0，让它保存返回值，相当于没有返回值。</p></div><p>第二种：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> my_add(%a, %<span class="keyword">b)</span></span><br><span class="line"><span class="keyword"></span>  <span class="keyword">add </span>$<span class="built_in">v0</span>, %a, %<span class="keyword">b</span></span><br><span class="line"><span class="keyword"></span>.end_macro</span><br><span class="line"></span><br><span class="line">li $<span class="built_in">s0</span>, <span class="number">1</span></span><br><span class="line">li $<span class="built_in">s1</span>, <span class="number">2</span></span><br><span class="line">my_add($<span class="built_in">s0</span>, $<span class="built_in">s1</span>) <span class="comment"># v0 = s0 + s1</span></span><br><span class="line"><span class="keyword">move </span>$<span class="built_in">s2</span>, $<span class="built_in">v0</span> <span class="comment"># s2 = v0</span></span><br></pre></td></tr></table></figure><h3 id="宏实现递归">宏实现递归</h3><p>首先明确一点，要在不同的函数栈上实现跳转，我们应该使用 <code>jal jr</code> 这对指令。在跳转时使用 <code>jal</code>，执行完后使用 <code>jr</code> 跳转回来。但是 <code>jr</code> 的目的地是 <code>$ra</code> 这个寄存器，专门保存 <code>jal</code> 的下一条指令的地址，让我们设想这样一个场景：</p><ul class="lvl-0"><li class="lvl-2"><p>进入函数 <code>f</code></p></li><li class="lvl-2"><p><code>f</code> 中再次调用 <code>f</code></p></li><li class="lvl-2"><p>第二层 <code>f</code> 满足结束条件，回到第一层 <code>f</code></p></li><li class="lvl-2"><p>第一层 <code>f</code> 满足结束条件，回到主程序</p></li></ul><p><code>f</code> 的结构大致是这样的：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jal </span>f <span class="comment"># 主程序调用 f</span></span><br><span class="line">下一条指令</span><br><span class="line"></span><br><span class="line">f:</span><br><span class="line">  满足条件则跳转到 f_end</span><br><span class="line">  函数逻辑</span><br><span class="line">  <span class="keyword">jal </span>f</span><br><span class="line">  <span class="keyword">jr </span>$<span class="built_in">ra</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">f_end:</span></span><br><span class="line">  <span class="keyword">jr </span>$<span class="built_in">ra</span></span><br></pre></td></tr></table></figure><p>乍一看非常之正确：主程序调用 <code>f</code>，<code>f</code> 执行到 jal <code>f</code> 后回到 <code>f</code> 的开头，满足条件跳转到 <code>f_end</code>，<code>f_end</code> 回到 <code>jal</code> 后一句，即 <code>jr $ra</code>，然后回到主程序。</p><p>对……对吗（</p><p>仔细一想，两个 <code>jr</code> 真能如愿跳转吗？实则不然。因为 <code>$ra</code> 只有一个，也就是说 <code>$ra</code> 的值是会被覆写的！！！</p><p>让我们再次分析：<code>f</code> 中第一次执行 <code>jal</code> 时，<code>$ra</code> 保存的是第一层中 <code>jr $ra</code> 这条指令的地址。第二层 <code>f</code> 中满足条件跳转到 <code>f_end</code>，然后回到了通过 <code>jr $ra</code> 回到了第一层的 <code>jr $ra</code>（有点绕），这里的 <code>$ra</code> 保存的仍然是第一层 <code>jr $ra</code> 的地址，也就是说原地 tp。<br>倘若递归次数更多，那么最后出现的情况就是 <code>jr $ra</code> 只能返回到最后一次调用 <code>f</code> 的位置，而不能如我们所想层层跳出。</p><p>所以我们需要用到栈来保存每层跳出的位置。</p><p>观察 MARS 界面右下角的寄存器界面，我们能够找到一个名为 <code>$sp</code> 的寄存器，它就是栈寄存器。和大多数寄存器不一样，它的初始值不是 0 ，而是 <code>0x00002ffc</code>。</p><p>操作系统中，栈是一个<ins>自顶向下</ins>的空间，先入栈的数据所在的地址反而大，后入栈的则小。</p><p>入栈实际上做了这么一件事：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, -<span class="number">4</span> <span class="comment"># 栈顶指针向下移动 4 字节</span></span><br><span class="line"><span class="keyword">sw </span>$<span class="built_in">s0</span>, <span class="number">0</span>($<span class="built_in">sp</span>) <span class="comment"># 保存 $s0 到栈顶</span></span><br></pre></td></tr></table></figure><p>出栈则是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lw </span>$<span class="built_in">s0</span>, <span class="number">0</span>($<span class="built_in">sp</span>) <span class="comment"># 从栈顶取出 $s0</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">4</span> <span class="comment"># 栈顶指针向上移动 4 字节</span></span><br></pre></td></tr></table></figure><p>在调用函数时，我更喜欢这样的出入栈方式：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> push(%r)</span><br><span class="line">  <span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, -<span class="number">4</span></span><br><span class="line">  <span class="keyword">sw </span>%r, <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line"><span class="meta">.macro</span> pop(%r)</span><br><span class="line">  <span class="keyword">lw </span>%r, <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">  <span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">4</span></span><br><span class="line">.end_macro</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">loop:</span></span><br><span class="line">  push($<span class="built_in">s0</span>)</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">jal </span>loop</span><br><span class="line">  ......</span><br><span class="line">  pop($<span class="built_in">s0</span>)</span><br><span class="line">  <span class="keyword">jr </span>$<span class="built_in">ra</span></span><br></pre></td></tr></table></figure><p>即刚进入函数时就入栈，准备跳出函数前出栈。这样就能保证 <code>$ra</code> 始终保存的是正确的地址。</p><h2 id="系统调用">系统调用</h2><p>根据 <code>$v0</code> 的值不同，使用 <code>syscall</code> 命令的效果不同。以下是常用的调用命令：</p><table><thead><tr><th>$v0</th><th>功能</th><th>要求或结果</th></tr></thead><tbody><tr><td>1</td><td>print integer</td><td><code>$a0</code> = 要打印的数</td></tr><tr><td>4</td><td>print string</td><td><code>$a0</code> = 要打印的字符串（<code>\0</code> 结尾）地址</td></tr><tr><td>5</td><td>read integer</td><td><code>$v0</code> = 读入的数</td></tr><tr><td>10</td><td>exit program</td><td>/</td></tr><tr><td>11</td><td>print character</td><td><code>$a0</code> = 要打印的字符</td></tr><tr><td>12</td><td>read character</td><td><code>$v0</code> = 读入的字符</td></tr></tbody></table><div class="note info">            <p>详见<a href="https://p0ach1l.github.io/2025/03/04/MIPS%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/#MIPS%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%A0%81">《MIPS 基础入门》——能打八个攻城狮</a>。</p>          </div><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>指令中设定好的常数，可以直接参与运算，一般为 16 位 二进制。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>用于使程序更简单清晰。标签用于表示一个地址，以供指令来引用。一般用于表示一个数据存取的地址（类似于数组名）、或者一个程序跳转的地址（类似于函数名，或者 C 语言中 <code>goto</code> 的跳转目标）。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/CO-Pre/">CO Pre</category>
      
      <category domain="https://samuflore.top/tags/MIPS/">MIPS</category>
      
      <category domain="https://samuflore.top/tags/MARS/">MARS</category>
      
      <category domain="https://samuflore.top/tags/Assembly-Language/">Assembly Language</category>
      
      
      <comments>https://samuflore.top/posts/1f9d902/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[轉載]新川大陆文化史</title>
      <link>https://samuflore.top/posts/10425c0c/</link>
      <guid>https://samuflore.top/posts/10425c0c/</guid>
      <pubDate>Tue, 09 Sep 2025 02:34:17 GMT</pubDate>
      
      <description>&lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;本文转载自神皇枫秀，敬请留意。&lt;/p&gt;
          &lt;/div&gt;
&lt;h1 id=&quot;新川大陆文化史&quot;&gt;新川大陆文化史&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;新川大陆的文明发展史是一部多元文化交融的史诗。从远古人类的起源分化，到各文明的兴衰更迭，这片土地见证了种族迁徙、技术革新、宗教演变与政治制度的不断创新。本书记述了从公元前2000年至公元1000年间，除川帝国外主要文明的发展历程，展现了斯特人、瓦伦人、伊塞尔人、米亚人等多个族群在探索、融合与抗争中共同谱写的文明篇章。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="note info">            <p>本文转载自神皇枫秀，敬请留意。</p>          </div><h1 id="新川大陆文化史">新川大陆文化史</h1><h2 id="引言">引言</h2><p>新川大陆的文明发展史是一部多元文化交融的史诗。从远古人类的起源分化，到各文明的兴衰更迭，这片土地见证了种族迁徙、技术革新、宗教演变与政治制度的不断创新。本书记述了从公元前2000年至公元1000年间，除川帝国外主要文明的发展历程，展现了斯特人、瓦伦人、伊塞尔人、米亚人等多个族群在探索、融合与抗争中共同谱写的文明篇章。</p><span id="more"></span><h2 id="第一章：人类起源与早期迁徙（公元前2000年之前）">第一章：人类起源与早期迁徙（公元前2000年之前）</h2><h3 id="1-1-人类共同祖先的分化">1.1 人类共同祖先的分化</h3><p>新川大陆的人类起源可追溯至远古时期的古人猿进化。根据《新川大陆民族发展简史》记载，古人猿主要分化为两个方向：</p><p>• <strong>兽向进化</strong>：形成<strong>林人</strong>，身形矫健，擅长山林间穿梭游居</p><p>• <strong>人向进化</strong>：形成<strong>山人</strong>，依靠智慧聚居于山洞，发展出早期社会组织</p><p>山人与林人的生存竞争构成了大陆文明的第一个重要分水岭。山人凭借更先进的工具使用能力和社会组织形式，在竞争中占据优势，迫使林人开始大规模迁徙，进而开启了新川大陆文明多样性的序幕。</p><h3 id="1-2-林人的三大迁徙路线">1.2 林人的三大迁徙路线</h3><p><strong>公元前2000年前后</strong>，山人与林人爆发决定性争斗，山人胜利后，林人被迫分为三大支系向不同方向迁徙：</p><p>• <strong>北迁支系</strong>：向寒冷的北方极地进发，逐渐适应严寒气候</p><p>• <strong>西南迁支系</strong>：进入干旱的沙漠戈壁地区，发展出耐旱生存技能</p><p>• <strong>西北迁支系</strong>：深入原始森林密布的西北山地，与野兽和复杂地形抗争</p><p>这一迁徙过程不仅是地理空间的拓展，更是文化多样性形成的关键阶段，为后来各文明的独特发展奠定了基础。</p><h3 id="1-3-山人的内部发展">1.3 山人的内部发展</h3><p>占据东部肥沃土地的山人，随着人口增长也开始分化为三支：</p><p>• <strong>海人</strong>：向东迁至沿海地区，发展渔业和航海文化</p><p>• <strong>川人</strong>：向平原地带发展，建立早期农业社会</p><p>• <strong>米亚人</strong>：沿河流建村，发展出与水资源密切相关的文化</p><p>山人与林人的分化与迁徙，构成了新川大陆文明发展的基本格局，为后续的文明碰撞与融合埋下了伏笔。</p><h2 id="第二章：远古探索时期（公元前2000年-公元前400年）">第二章：远古探索时期（公元前2000年-公元前400年）</h2><h3 id="2-1-北境文明的奠基：斯特人与斯尔吉亚雏形">2.1 北境文明的奠基：斯特人与斯尔吉亚雏形</h3><p><strong>公元前1700年前后</strong>，向北迁徙的林人分支在&quot;神之息&quot;山谷定居，逐渐演变为<strong>斯特人</strong>。他们选择的定居点位于摩尔吉亚河下游，这片山谷土地肥沃，四周环山，既提供了防御优势，又便于农业发展。斯特人在此建立了早期城镇<strong>坤达帖木儿</strong>，标志着北境第一个文明雏形的诞生。</p><p>斯特人发展出独特的山地农业技术，适应了北境较短的生长季节，并形成了以部落长老为核心的社会结构。他们崇拜山神，认为山脉是神灵的化身，这种信仰后来与川人的游牧文化融合，形成了斯尔吉亚文明的精神基础。</p><h3 id="2-2-西南沙漠的适应：瓦伦人的迁徙与定居">2.2 西南沙漠的适应：瓦伦人的迁徙与定居</h3><p><strong>公元前1600年前后</strong>，向西南迁徙的林人分支演变为<strong>瓦伦人</strong>。他们最初进入的裂空山谷地区气候干旱，生存条件恶劣，族群数量急剧减少。经过多年探索，瓦伦人最终穿越裂空山，发现了水源充沛、土地肥沃的<strong>裂龙山谷</strong>，并在此建立了<strong>拜亚城</strong>。</p><p>瓦伦人在裂龙山谷发展出独特的节水农业技术，他们建造了复杂的引水渠系统，将山泉水引入农田，成功在沙漠边缘开辟出绿洲。这种对水资源的精细管理能力，成为后来瓦伦迪亚商业文明的重要特征。</p><h3 id="2-3-西北山地的开拓者：伊塞尔人的分支发展">2.3 西北山地的开拓者：伊塞尔人的分支发展</h3><p><strong>公元前1400年前后</strong>，向西北迁徙的林人演变为<strong>伊塞尔人</strong>，并进一步分为两支：</p><p>• <strong>向西分支</strong>：约50年后抵达伊塞尔河上游，建立<strong>伊塞尔城</strong>。该城东南北三面环山，形成天然防御屏障，伊塞尔人在此发展出以农业为主的定居文明。</p><p>• <strong>向北分支</strong>：抵达寒冷的<strong>霜狼高原</strong>，开启了长达数百年的流浪生活。在与严酷自然环境的抗争中，他们与当地狼群形成了独特的共生关系，逐渐产生了对<strong>霜狼的信仰</strong>，这种信仰成为他们精神生活的核心。</p><p>伊塞尔人的两支发展路径，体现了同一族群在不同环境压力下的文化适应策略，为后来新川大陆文明的多样性做出了重要贡献。</p><h3 id="2-4-山人的分化与融合">2.4 山人的分化与融合</h3><p><strong>公元前1800年前后</strong>，占据东部肥沃土地的山人逐渐分化为三个支系：<strong>川人</strong>、<strong>海人</strong>和<strong>米亚人</strong>。这三支在发展过程中命运各异：</p><p><strong>海人</strong>因海洋资源有限和环境变化，于<strong>公元前1100年前后</strong>逐渐消亡，其土地被川人兼并。这一事件成为新川大陆文明发展史上第一次记录的民族消亡事件，反映了环境适应对文明存续的重要性。</p><p><strong>公元前1000年前后</strong>，<strong>川人</strong>发起对<strong>米亚人</strong>的兼并战争。战争导致米亚人分化为两支：一支被川人兼并，逐渐演变为<strong>兰川人</strong>；另一支则开始大规模迁徙，史称&quot;米亚远行&quot;，这一迁徙对后来多个文明的发展产生了深远影响。</p><h2 id="第三章：古典农业时期（公元前400年-公元400年）">第三章：古典农业时期（公元前400年-公元400年）</h2><h3 id="3-1-水利技术的传播与文明革新">3.1 水利技术的传播与文明革新</h3><p><strong>公元前800年前后</strong>，远行的米亚人与瓦伦人在裂龙山谷相遇。米亚人带来的先进水利技术与瓦伦人的沙漠生存经验相结合，促成了<strong>拜亚城</strong>的重建。这次重建不仅是城市物理空间的改造，更是一次深刻的文化融合，标志着<strong>瓦伦迪亚文明</strong>的正式形成。</p><p>米亚人带来的水利技术包括：</p><p>• 复杂的引水渠系统设计</p><p>• 水坝和水库的建造技术</p><p>• 农田灌溉的高效分配方法</p><p>这些技术使裂龙山谷的农业产量大幅提高，支持了人口增长和城市扩张，为瓦伦迪亚后来的商业繁荣奠定了物质基础。</p><h3 id="3-2-霜狼高原的文明融合：蒙里米亚的诞生">3.2 霜狼高原的文明融合：蒙里米亚的诞生</h3><p><strong>公元前700年前后</strong>，另一支远行的米亚人抵达<strong>霜狼高原</strong>，与在此流浪数百年的伊塞尔人北迁分支相遇。米亚人带来的水利技术使高原农业成为可能，他们在河流源头建立了<strong>蒙德里城</strong>，标志着<strong>蒙里米亚文明</strong>的诞生。</p><p>蒙里米亚文明的独特之处在于：</p><p>• <strong>霜狼信仰与米亚人宗教观念的融合</strong>：形成了独特的萨满教体系</p><p>• <strong>高原农业技术</strong>：开发出适应高寒环境的作物品种和种植技术</p><p>• <strong>政教合一的社会结构</strong>：宗教领袖同时掌握政治权力</p><p><strong>公元前307年</strong>，在伊塞尔人入侵的压力下，大先知蒙完成了对宗教的系统诠释，确立了以霜狼为核心的神学体系。<strong>公元前110年</strong>，蒙的第十一代孙统一霜狼高原各部，正式建立政教合一的<strong>蒙里米亚</strong>国家，使蒙里米亚成为古典农业时期最具影响力的文明之一。</p><h3 id="3-3-北境的民族融合：斯尔人的崛起">3.3 北境的民族融合：斯尔人的崛起</h3><p><strong>公元前500年前后</strong>，川人内部因生产方式差异发生分裂。从事游牧的一支因与农耕文明的冲突被边缘化，向北迁移。<strong>公元前400年前后</strong>，这支游牧川人与北境的斯特人相遇并逐渐融合，形成了新的民族——<strong>斯尔人</strong>。</p><p>斯尔人继承了：</p><p>• 斯特人的北境适应能力和骑射技术</p><p>• 川人的社会组织能力和军事战略思想</p><p>• 双方的文化传统和宗教信仰</p><p><strong>公元101年</strong>，斯尔人凭借军事优势占领<strong>坤达帖木儿</strong>，建立<strong>斯尔吉亚</strong>政权。斯尔吉亚实行军事贵族制度，形成了少数精英统治多数斯特人的社会结构，这种结构后来成为北境政治的典型模式。</p><h3 id="3-4-伊塞尔文明的动荡与变革">3.4 伊塞尔文明的动荡与变革</h3><p><strong>公元前309年</strong>，伊塞尔人向南扩张，大举进攻霜狼高原的蒙里米亚。然而，不适应高原环境的伊塞尔军队遭遇惨败，这场战争引发了伊塞尔内部的长期混乱。</p><p>战争失败后，伊塞尔社会陷入危机：</p><p>• 军事贵族与传统祭司的权力斗争加剧</p><p>• 资源分配不均引发社会矛盾</p><p>• 外部威胁与内部动荡交织</p><p><strong>公元前307年</strong>，在战争阴影下，大先知蒙完成宗教改革，而伊塞尔内部则出现了<strong>铁器技术</strong>引发的社会变革。铁器的传入改变了战争形态和生产方式，导致旧贵族与新兴军事阶层的冲突。旧贵族虽然在权力斗争中暂时获胜，但社会矛盾的积累为后来的动荡埋下了伏笔。</p><h2 id="第四章：帝国封建时期（公元400年-公元1000年）">第四章：帝国封建时期（公元400年-公元1000年）</h2><h3 id="4-1-双丹的独立与商业文明的兴起">4.1 双丹的独立与商业文明的兴起</h3><p><strong>公元404年</strong>，<strong>切丹</strong>宣布独立，这一事件成为帝国封建时期的开端。切丹家族虽身处川人政权体系，却保留着部分瓦伦人的血脉。他们利用瓦伦迪亚民众的暴乱，扩充私军，最终脱离川人统治，建立独立政权。</p><p>切丹政权的成功得益于：</p><p>• <strong>战略地理位置</strong>：在沿海地区建立双海港（赤丹港和乌丹港）</p><p>• <strong>灵活的外交策略</strong>：利用瓦伦迪亚与川帝国的矛盾，实行中立政策</p><p>切丹家族为避免内战，将双海港分别交给两个儿子治理，形成了赤丹港侧重金属加工业、乌丹港专注奢侈品贸易的分工格局。这种模式不仅促进了经济繁荣，也为后来的联邦制度提供了早期实践经验。</p><h3 id="4-2-瓦伦迪亚的统一与联邦共和制的诞生">4.2 瓦伦迪亚的统一与联邦共和制的诞生</h3><p><strong>公元409年</strong>，受双丹独立的鼓舞，瓦伦迪亚各城邦通过条约完成统一，创立了独特的<strong>联邦共和制</strong>。这一政治制度的创新包括：</p><p>• <strong>城邦代表制度</strong>：各城邦根据人口比例选派代表</p><p>• <strong>议会决策机制</strong>：重要事务由城邦代表组成的议会投票决定</p><p>• <strong>法律面前平等</strong>：确立了超越城邦界限的公民权利</p><p>瓦伦迪亚的统一并非通过军事征服，而是基于共同商业利益的自愿联合。这种和平统一模式在新川大陆文明史上独树一帜，反映了商业文明对政治制度的深刻影响。</p><h3 id="4-3-斯尔吉亚的军事扩张与北境霸权">4.3 斯尔吉亚的军事扩张与北境霸权</h3><p>斯尔吉亚在建立后迅速发展成为北境强国，其成功的关键因素包括：</p><p><strong>军事制度创新</strong>：</p><p>• 建立专业化的骑兵部队，职业军队就此诞生</p><p>• 发展先进的弓箭技术和战术</p><p>• 高效的信仰提供强力的军事动员</p><p><strong>战略资源控制</strong>：</p><p>• 占领万通港口，控制东西贸易的北方海上通道</p><p>• 开发东部草原作为战马繁育基地</p><p>• 建立覆盖北境的军事要塞网络</p><p>斯尔吉亚的军事扩张使其成为强大的军事帝国，其骑兵部队在大陆北部所向披靡，形成了独特的军事文化和贵族统治体系。</p><h3 id="4-4-伊塞尔的统一与现代化">4.4 伊塞尔的统一与现代化</h3><p>在经历了长达数百年的分裂与动荡后，<strong>艾</strong>于公元1世纪末崛起，通过军事征服和外交联盟，重新统一了伊塞尔各割据势力。艾的统一不仅结束了内乱，还：</p><p>• 建立了中央集权的行政体系</p><p>• 改革军事制度，吸收先进战术</p><p>• 发展与周边文明的贸易关系</p><p>艾的统一标志着<strong>现代伊塞尔文明</strong>的确立，使伊塞尔重新成为大陆西部的重要力量。伊塞尔文明在经历长期分裂后，吸收了多元文化元素，形成了独特的社会结构和文化传统。</p><h2 id="第五章：跨文明专题研究">第五章：跨文明专题研究</h2><h3 id="5-1-技术传播与文明互动">5.1 技术传播与文明互动</h3><p>新川大陆文明发展的重要特征是技术的跨文明传播，其中<strong>水利技术</strong>和<strong>金属冶炼技术</strong>的传播最为关键：</p><p><strong>水利技术传播路线</strong>：</p><p>• 起源：米亚人</p><p>• 传播路径：向西传入瓦伦，随后北上穿越沙漠传入霜狼高原和伊塞尔；</p><p>向北被川人吸纳，随后再次向北传入斯尔吉亚。</p><p>• 技术演变：从河流治理到水利灌溉，再到水力工业。</p><p><strong>金属冶炼技术传播</strong>：</p><p>• 起源：川人的善于冶炼的一支</p><p>• 传入路径：自被发现，迅速在川人文化普及，随后向四周辐射，向北进入斯尔吉亚，向西进入伊塞尔，向西南进入瓦伦迪亚。</p><p>• 社会影响：改变军事格局，促成新贵族崛起，引发社会结构变革</p><p>技术传播不仅是工具和方法的转移，更是知识体系和思维方式的交流，促进了各文明的创新与发展。</p><h3 id="5-2-宗教演变与精神文化">5.2 宗教演变与精神文化</h3><p>新川大陆各文明发展出丰富的宗教体系，这些宗教既反映了各民族的生存环境，也塑造了他们的文化特征：</p><p><strong>霜狼信仰</strong>：</p><p>• 起源：伊塞尔人北迁分支在霜狼高原的生存体验</p><p>• 发展：与米亚人宗教观念融合，形成蒙里米亚国教</p><p>• 特征：自然崇拜与祖先崇拜结合，动物图腾（霜狼）为核心象征</p><p><strong>山神信仰</strong>：</p><p>• 起源：斯特人在&quot;神之息&quot;山谷的定居经历</p><p>• 演变：与川人游牧文化融合，形成斯尔吉亚的军事神学</p><p>• 影响：强化了军事贵族的统治合法性</p><p>宗教不仅是精神寄托，也是社会整合的工具，在蒙里米亚的政教合一和斯尔吉亚的军事动员中发挥了关键作用。</p><p>两种信仰均在极度寒冷的自然条件压迫下产生，或许信仰能成为人类在危难面前支撑活下去的精神源泉。</p><h3 id="5-3-政治制度的多样性与创新">5.3 政治制度的多样性与创新</h3><p>帝国封建时期，新川大陆各文明发展出多样化的政治制度，反映了不同的社会结构和文化传统：</p><p><strong>蒙里米亚的政教合一制</strong>：</p><p>• 权力结构：宗教领袖同时担任政治首脑</p><p>• 治理方式：以宗教律法为基础，祭司阶层参与行政管理</p><p>• 优势与局限：强化社会凝聚力，但限制思想创新</p><p><strong>瓦伦迪亚的联邦共和制</strong>：</p><p>• 权力结构：城邦代表组成的议会为最高权力机构</p><p>• 决策机制：多数投票制，城邦享有高度自治权</p><p>• 优势与局限：促进商业发展和文化多元，但决策效率较低</p><p><strong>斯尔吉亚的军事贵族制</strong>：</p><p>• 权力结构：军事精英组成的贵族会议掌握实权</p><p>• 社会流动：基于军功的晋升体系，保持军事活力</p><p>• 优势与局限：形成强大军事力量，但容易引发对外扩张</p><p><strong>双丹的商业寡头制</strong>：</p><p>• 权力结构：富裕商人组成的寡头集团控制政治</p><p>• 治理特点：以商业利益为导向，灵活的外交政策</p><p>• 优势与局限：促进经济繁荣，但可能忽视社会公平</p><p>这些政治制度的多样性反映了新川大陆文明发展的丰富性，也为不同环境下的社会治理提供了多样化的解决方案。</p><h2 id="第六章：文明互动与历史影响">第六章：文明互动与历史影响</h2><h3 id="6-1-贸易网络的构建与文化交流">6.1 贸易网络的构建与文化交流</h3><p><strong>公元500年后</strong>，新川大陆形成了以覆盖多帝国的贸易网络：</p><p><strong>主要贸易路线</strong>：</p><p>• 沙漠商路：自川帝国京师一路向西，穿越沙漠，连接各个大型城市，最终抵达伊塞尔城。这条商路是大陆最重要的陆地贸易。</p><p>• 双丹商路：双丹港口作为贸易基站，东连川帝国东海岸五大港口，西连瓦伦，西门。（西帝国唯一港口，西帝国是川文化的扩张）</p><p>• 北方航道：自万通港至米亚基斯，是东西贸易最为高效的商路。</p><p>• 东部丝绸之路：川帝国盛产的丝绸等奢饰品向北连接斯尔吉亚，进入万通港，向东进入五大港，向西南进入瓦伦，是最重要的奢侈品贸易路线。</p><p>贸易不仅促进了商品流通，也带来了文化交流：</p><p>• 语言的相互影响：各文明词汇的借用与语法结构的趋同</p><p>• 科技知识的传播：农业技术、手工业方法的跨文明交流</p><h3 id="6-2-军事冲突与文明融合">6.2 军事冲突与文明融合</h3><p>军事冲突虽然带来破坏，但也促进了文明间的融合：</p><p>古典时期三大战争</p><p><strong>伊塞尔-蒙里米亚战争（公元前309年）</strong>：</p><p>• 直接结果：伊塞尔失败，蒙里米亚巩固高原统治</p><p>• 长远影响：促进军事技术交流，伊塞尔内乱为艾的统一创造条件</p><p><strong>斯尔吉亚扩张（公元100-200年）</strong>：</p><p>• 军事策略：骑兵部队的灵活运用，要塞体系的建设</p><p>• 文化影响：斯特人与川人文化的深度融合，形成新的文化认同</p><p>• 长远影响：夺取万通港，占据东部大草原，为斯尔吉亚的强盛奠定基础</p><p><strong>双丹独立战争（公元404年）</strong>：</p><p>• 政治影响：打破川人霸权，开启联邦共和实验</p><p>• 经济影响：促进商业网络形成，改变大陆权力格局</p><h3 id="6-3-主要文明的历史地位与贡献">6.3 主要文明的历史地位与贡献</h3><p><strong>蒙里米亚文明</strong>：</p><p>• 独特贡献：政教合一制度的实践，高原农业技术的创新</p><p>• 文化遗产：丰富的宗教典籍，独特的艺术风格，水利工程技术</p><p><strong>瓦伦迪亚文明</strong>：</p><p>• 独特贡献：联邦共和制度的早期实践，商业文化的发展</p><p>• 文化遗产：法律体系，商业契约传统，城市规划理念</p><p><strong>斯尔吉亚文明</strong>：</p><p>• 独特贡献：骑兵战术的革新，游牧与农耕文化的融合</p><p>• 文化遗产：军事训练体系，马术技术，多元文化融合模式</p><p><strong>双丹文明</strong>：</p><p>• 独特贡献：商业网络的构建，城邦联盟的治理经验</p><p>• 文化遗产：航海技术，金融制度，国际贸易规范</p><p><strong>伊塞尔文明</strong>：</p><p>• 独特贡献：在分裂与统一中探索社会整合的路径</p><p>• 文化遗产：铁器制造技术，行政管理体系，文学传统</p><h2 id="第七章：终论">第七章：终论</h2><p>新川大陆的文明发展史是一部多元文化互动、冲突与融合的史诗。从远古时期山人与林人的分化，到古典农业时期的技术传播，再到帝国封建时期的政治创新，各文明在适应环境、应对挑战的过程中，发展出独特的文化特征和社会结构。</p><p>蒙里米亚的宗教整合、瓦伦迪亚的商业智慧、斯尔吉亚的军事创新、双丹的贸易网络、伊塞尔的社会变革，共同构成了新川大陆文明的丰富图景。这些文明虽然发展路径各异，但都对大陆的整体发展做出了独特贡献。</p><p>新川大陆文明发展的历史启示：</p><p>1. 环境适应是文明存续的基础，各文明都发展出适应特定环境的生存策略</p><p>2. 技术创新和传播是文明进步的关键驱动力</p><p>3. 文化融合能够创造新的文明形态，增强社会活力</p><p>4. 政治制度的多样性反映了不同社会结构的适应性需求</p><p>5. 贸易网络的构建促进了物质与文化的交流，推动整体发展</p><p>新川大陆的文明发展史表明，文明的进步不是单一模式的复制，而是多元文化在互动中共同演进的过程。这种多元一体的发展模式，为理解人类文明的多样性和统一性提供了重要视角。</p><h2 id="附录：新川大陆文明年表">附录：新川大陆文明年表</h2><p>• <strong>公元前2000年</strong>：山人与林人爆发争斗，林人被迫迁徙</p><p>• <strong>公元前1800年</strong>：山人分化为川人、海人、米亚人</p><p>• <strong>公元前1700年</strong>：斯特人建立坤达帖木儿，北境文明诞生</p><p>• <strong>公元前1600年</strong>：瓦伦人建立拜亚城，西南文明奠基</p><p>• <strong>公元前1400年</strong>：伊塞尔人分化，西支建立伊塞尔城</p><p>• <strong>公元前1100年</strong>：海人消亡，土地被川人兼并</p><p>• <strong>公元前1000年</strong>：川人兼并米亚人，引发米亚远行</p><p>• <strong>公元前800年</strong>：米亚人与瓦伦人融合，瓦伦迪亚文明形成</p><p>• <strong>公元前700年</strong>：米亚人抵达霜狼高原，蒙里米亚文明萌芽</p><p>• <strong>公元前500年</strong>：川人与兰川人融合，形成新川人</p><p>• <strong>公元前400年</strong>：川人游牧分支与斯特人融合，形成斯尔人</p><p>• <strong>公元前309年</strong>：伊塞尔进攻霜狼高原失败，陷入内乱</p><p>• <strong>公元前307年</strong>：大先知蒙完成宗教改革</p><p>• <strong>公元前110年</strong>：蒙里米亚完成政教合一</p><p>• <strong>公元前77年左右</strong>：艾统一伊塞尔，伊塞尔文明确立</p><p>• <strong>公元101年</strong>：斯尔人占领坤达帖木儿，建立斯尔吉亚</p><p>• <strong>公元404年</strong>：切丹独立，双丹文明兴起</p><p>• <strong>公元409年</strong>：瓦伦迪亚完成统一，联邦共和制确立</p><p>• <strong>公元500年后</strong>：新川大陆跨文明贸易网络形成</p>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%BD%89%E8%BC%89/">轉載</category>
      
      
      <category domain="https://samuflore.top/tags/History/">History</category>
      
      <category domain="https://samuflore.top/tags/Repost/">Repost</category>
      
      
      <comments>https://samuflore.top/posts/10425c0c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CO Pre]Verilog 入门</title>
      <link>https://samuflore.top/posts/c9f56abd/</link>
      <guid>https://samuflore.top/posts/c9f56abd/</guid>
      <pubDate>Mon, 01 Sep 2025 08:50:18 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Verilog 部分。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Verilog 部分。</p><span id="more"></span><hr><h1 id="IDE">IDE</h1><p>本文使用 ISE 开发与仿真。</p><hr><h1 id="Verilog-语法">Verilog 语法</h1><h2 id="模块的定义方法">模块的定义方法</h2><p>模块（module）是 Verilog HDL 的基本功能单元，它实际上代表了具有一定功能的电路实体。通俗来讲，其代表了电路中被导线连接的各个功能模块（子电路）。</p><p>以一个与门为例：<br>方法一：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AndGate(</span><br><span class="line">    <span class="keyword">input</span> i1,</span><br><span class="line">    <span class="keyword">input</span> i2,</span><br><span class="line">    <span class="keyword">output</span> o</span><br><span class="line">);<span class="comment">// 模块名定义、端口定义及IO说明</span></span><br><span class="line">    <span class="keyword">assign</span> o = i1 &amp; i2; <span class="comment">// 模块功能定义</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">// 结束模块定义</span></span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AndGate(i1,i2,o); <span class="comment">// 模块名定义及端口定义</span></span><br><span class="line">    <span class="keyword">input</span> i1;</span><br><span class="line">    <span class="keyword">input</span> i2; <span class="comment">// 也可合并为一句: input i1,i2;</span></span><br><span class="line">    <span class="keyword">output</span> o;</span><br><span class="line">    <span class="comment">// 上为IO说明</span></span><br><span class="line">    <span class="keyword">assign</span> o = i1 &amp; i2; <span class="comment">// 模块功能定义</span></span><br><span class="line"><span class="keyword">endmodule</span> <span class="comment">// 结束模块定义</span></span><br></pre></td></tr></table></figure><p>两种方法没有实质上的区别，只是形式上有所不同：方法 1 对方法 2 中的端口定义及 IO 说明进行了合并。<br>模块以 <code>module</code> 开始，<code>endmodule</code> 结束，中间包括模块名、端口定义、I/O 说明等部分。<ins>模块中的语句除了顺序执行的语句块以外都是并行的</ins>；输入输出端口若不特别说明类型及位宽，<ins>默认为 1 位 <code>wire</code> 型</ins>。</p><h2 id="常用数据类型">常用数据类型</h2><h3 id="Wire-型">Wire 型</h3><p><code>wire</code> 型数据属于线网 <code>nets</code> 型数据，通常用于表示组合逻辑信号，可以将它类比为电路中的导线。它本身并不能存储数据，需要有输入才有输出（这里输入的专业术语叫驱动器），且输出随着输入的改变而即时改变。一般使用 <code>assign</code> 语句对 <code>wire</code> 型数据进行驱动（<code>assign</code> 语句将在下一节中进行讲解）。</p><p><code>wire</code> 型的数据分为标量（1 位）和向量（多位）两种。可以在声明过程中使用范围指示器指明位数，如 <code>wire [31:0] a</code>;。冒号两侧分别代表最高有效位（MSB, Most Significant Bit）和最低有效位（LSB, Least Significant Bit）。在访问时，可以使用形如 <code>a[7:4]</code> 的方式取出 <code>a</code> 的第 7-4 位数据。</p><div class="tips"><p>声明位宽时，如果写作 <code>wire [0:31] a</code> 也是可以的。此时高位被指定为第 0 位，低位被指定为第 31 位。为其赋值时 <code>a = 32'h1234_5678</code> 1 会实际存储在首位，而 8 会存储在末位，与正常相反。</p></div><div class="note warning">            <p>信号定义好之后，不仅决定了位宽还决定了方向，例如定义为 <code>[4:7]</code> 的 <code>b</code> 信号，四个管脚分别为 4，5，6，7，在使用中只能正向接，不能反向接。因此接 <code>b[4:7]</code> 是合法的，而 <code>b[7:4]</code> 是不合法的；同理接 <code>c[8:11]</code> 是合法的，接 <code>c[11:8]</code> 是不合法的。（“接”指赋值操作）</p>          </div><div class="note info">            <p>在 Verilog 里，信号的位宽可以通过 <code>in[a:b]</code> 这样的语法来取一部分:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> out = in[<span class="number">7</span>:<span class="number">4</span>];<span class="comment">//取 in 的第 7-4 位</span></span><br></pre></td></tr></table></figure><p>这里的 <code>a</code> 和 <code>b</code> 都必须是<ins>常量</ins>，不能包含变量。比如写成 <code>assign out = in[m * 4 + 3:m * 4]</code> 就会报错，因为 <code>m</code> 是一个变量。<br>但是，Verilog-2001/SystemVerilog 提供了一种叫 part-select with variable index 的写法:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> out = in[start +: width];<span class="comment">//从 start 位开始往高位取 width 位</span></span><br><span class="line"><span class="keyword">assign</span> out = in[start -: width];<span class="comment">//从 start 位开始往低位取 width 位</span></span><br></pre></td></tr></table></figure><p>这里的 start 则可以是变量，而 width 必须是常量。</p>          </div><h3 id="Reg-型">Reg 型</h3><p><code>reg</code> 型是寄存器数据类型，具有存储功能。它也分为标量和向量，类似 <code>wire</code> 型，可以类比前面的教程。一般在 <code>always</code> 块内使用 <code>reg</code> 型变量（<code>always</code> 块将在本章后面提到），通过赋值语句来改变寄存器中的值。为了确定何时进行赋值，我们经常需要用到各种控制结构，包括 <code>while</code>、<code>for</code>、<code>switch</code> 等，这与 C 语言中的做法十分相似。</p><p>需要注意的是，<code>reg</code> 型变量<ins>不能使用 <code>assign</code> 赋值</ins>。而且，<code>reg</code> 型<ins>并不一定被综合成寄存器</ins>，它也可和 <code>always</code> 关键字配合（下一节会讲到），建模组合逻辑。</p><p>我们可以通过对 <code>reg</code> 型变量建立数组来对存储器建模，例如 <code>reg [31:0] mem [0:1023]</code>;，其中前面的中括号内为位宽，后面的中括号内为存储器数量。这种写法在我们开始搭建CPU后会用到。<br>我们可以通过引用操作访问存储器型数据元素，类似于位选择操作，例如 <code>mem[2]</code> 就是访问 <code>mem</code> 中的第 3 个元素。</p><div class="tips"><p>Verilog HDL 中<ins>没有</ins>多维数组。</p></div><h3 id="数字字面量">数字字面量</h3><p>Verilog 中的数字字面量可以按二进制（b 或 B）、八进制（o 或 O）、十六进制（h 或 H）、十进制（d 或 D）表示。</p><p>数字的完整表达为 <code>&lt;位宽&gt;'&lt;进制&gt;&lt;值&gt;</code>，如 <code>10'd100</code>。省略位宽时采用默认位宽（与机器有关，一般为 <ins>32 位</ins>），省略进制时默认为<ins>十进制</ins>，值部分可以用下划线分开提高可读性，如 <code>16'b1010_1011_1111_1010</code>。</p><p>Verilog 中除了普通的数字以外，还有两个特殊的值：<code>x</code> 和 <code>z</code>。<code>x</code> 为不定值，当某一二进制位的值不能确定时出现，变量的默认初始值为 <code>x</code>。<code>z</code> 为高阻态，代表没有连接到有效输入上。对于位宽大于 1 的数据类型，<code>x</code> 与 <code>z</code> 均可只在部分位上出现。</p><div class="warning"><p>注意数字的位宽决定了数字的最大值。比如 <code>3'd101</code> 就是一个非法的数字，因为 3 位宽的数字最大值为 7。</p></div><div class="warning"><p>Verilog 数字本身并不能添加负号，但写作类似于 <code>-8'd5</code> 这样的形式可以看作是对数字的运算，是合法的。</p></div><h3 id="Integer-型">Integer 型</h3><p><code>integer</code> 数据类型一般为 32 位，与 C 语言中的 <code>int</code> 类似，默认为有符号数，在我们的实验中主要用于 <code>for</code> 循环（将在本章后面提到）。</p><h3 id="Parameter-型">Parameter 型</h3><p><code>parameter</code> 类型用于在编译时确认值的常量，通过形如 <code>parameter 标识符 = 表达式</code>; 的语句进行定义，如：<code>parameter width = 8</code>;。在实例化模块时，可通过参数传递改变在被引用模块实例中已定义的参数（模块的实例化将在后面的章节进行介绍）。<code>parameter</code> 虽然看起来可变，但它属于常量，在编译时会有一个确定的值。</p><p><code>parameter</code> 可以用于在模块实例化时指定数据位宽等参数，便于在结构相似、位宽不同的模块之间实现代码复用。</p><h2 id="组合逻辑建模常用语法">组合逻辑建模常用语法</h2><h3 id="Assign-语句">Assign 语句</h3><p><code>assign</code> 语句是连续赋值语句，是组合逻辑的建模利器，其作用是用一个信号来驱动另一个信号。如 <code>assign a = b</code>;，其中 <code>a</code> 为 <code>wire</code> 型（也可由位拼接得到，见运算符部分），<code>b</code> 是由数据和运算符组成的表达式。</p><p><code>assign</code> 语句与 C 语言的赋值语句有所不同，这里“驱动”的含义类似于电路的连接，也就是说，<code>a</code> 的值<ins>时刻</ins>等于 <code>b</code>。这也解释了 <code>assign a = a + 1</code>; 这样的语句为什么是不合法的。由于这样的特性，<code>assign</code> 语句不能在 <code>always</code> 和 <code>initial</code> 块中使用。</p><p><code>assign</code> 语句经常与三目运算符配合使用建模组合逻辑。一般来说，<code>assign</code> 语句综合出来的电路是右侧表达式化简后所对应的逻辑门组合。</p><div class="note warning">            <ul class="lvl-0"><li class="lvl-2"><p><code>reg</code> 类型不能被 <code>assign</code> 赋值。</p></li><li class="lvl-2"><p>未被 <code>assign</code> 赋值（驱动）过的 <code>wire</code> 类型数据不能被赋给其他的 <code>wire</code> 类型数据。未被 <code>assign</code> 过的 <code>wire</code> 类型就好比什么都没连接的导线，它和其它导线连接是没有意义的。</p></li><li class="lvl-2"><p>1 位的变量，不可以被两次 <code>assign</code>，多位的变量，每一位只能被一次 <code>assign</code>。比如 <code>wire [3:0] output; assign output[1:0] = 2'b01; assign output[3:2] = 2'b10;</code> 这是合法的。而 <code>assign output = 4'b0; assign output[1:0] = 2'b01;</code> 是不合法的，因为 0 位和 1 位被两次赋值。</p></li></ul>          </div><h3 id="运算符">运算符</h3><p>这里只介绍和 C 语言有差异的运算符。</p><ul class="lvl-0"><li class="lvl-2"><p>Verilog 中没有自增和自减运算符。</p></li><li class="lvl-2"><p>操作数中有不定值 <code>x</code> 和高阻态 <code>z</code> 时，结果中也可能出现。</p></li><li class="lvl-2"><p>逻辑右移 <code>&gt;&gt;</code> 和算术右移 <code>&gt;&gt;&gt;</code></p><ul class="lvl-2"><li class="lvl-6">它们的区别主要在于前者在最高位补 0，而后者在最高位补符号位。</li></ul></li><li class="lvl-2"><p>相等比较运算符 <code>==</code> 和 <code>===</code>、不等比较运算符 <code>!=</code> 和 <code>!==</code></p><ul class="lvl-2"><li class="lvl-6"><code>==</code> 和 <code>!=</code> 可能由于不定值 <code>x</code> 和高阻值 <code>z</code> 的出现导致结果为不定值 <code>x</code>，而 <code>===</code> 和 <code>!==</code> 的结果一定是确定的 0 或 1（<code>x</code> 与 <code>z</code> 也参与比较）。</li></ul></li><li class="lvl-2"><p>阻塞赋值 <code>=</code> 和非阻塞赋值 <code>&lt;=</code></p><ul class="lvl-2"><li class="lvl-6">不同于 <code>assign</code> 语句，这两种赋值方式被称为过程赋值，通常出现在 <code>initial</code> 和 <code>always</code> 块中，<ins>为 <code>reg</code> 型变量赋值</ins>。这种赋值类似 C 语言中的赋值，不同于 <code>assign</code> 语句，赋值仅会在一个时刻执行。由于 Verilog 描述硬件的特性，Verilog 程序内会有大量的并行，因而产生了这两种赋值方式。这两种赋值方式的详细区别会在<a href="#assignment">之后的小节内</a>介绍，这里暂时只需记住一点：为了写出正确、可综合的程序，<ins>在描述时序逻辑时要使用非阻塞式赋值 <code>&lt;=</code></ins>。</li></ul></li><li class="lvl-2"><p>位拼接运算符 <code>&#123;&#125;</code></p><ul class="lvl-2"><li class="lvl-6">这个运算符可以将几个信号的某些位拼接起来，例如 <code>&#123;a, b[3:0], w, 3'b101&#125;</code>;；可以简化重复的表达式，如 <code>&#123;4&#123;w&#125;&#125;</code> 等价于 <code>&#123;w,w,w,w&#125;</code>；还可以嵌套，<code>&#123;b, &#123;3&#123;a, b&#125;&#125;&#125;</code> 等价于 <code>&#123;b, &#123;a, b, a, b, a, b&#125;&#125;</code>，也就等价于 <code>&#123;b, a, b, a, b, a, b&#125;</code>。</li></ul></li><li class="lvl-2"><p>缩减运算符</p><ul class="lvl-2"><li class="lvl-6">运算符 <code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）等作为<em>单目运算符</em>是对操作数的<strong>每一位汇总运算</strong>，如对于 <code>reg[31:0] B</code>; 中的 <code>B</code> 来说，<code>&amp;B</code> 代表将 <code>B</code> 的<em>每一位</em>与起来得到的结果。</li></ul></li></ul><h2 id="时序逻辑建模常用语法">时序逻辑建模常用语法</h2><h3 id="Always-块">Always 块</h3><p><code>always</code> 块有如下两种用法：</p><ul class="lvl-0"><li class="lvl-2"><p>若 <code>always</code> 之后紧跟 <code>@(...)</code>，其中括号内是敏感条件列表，表示当括号中的条件满足时，将会执行 <code>always</code> 之后紧跟的语句或顺序语句块（和 C 语言中的语句块类似，只是将大括号用 <code>begin</code> 和 <code>end</code> 替换了）。这种用法主要用于<ins>建模时序逻辑</ins>。<br>例如：</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)  <span class="comment">// 表示在 clk 上升沿触发后面的语句块</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">// 一些操作</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>若 <code>always</code> 之后紧跟 <code>@ *</code> 或 <code>@(*)</code>，则表示对<ins>其后紧跟的语句或语句块</ins>内<ins>所有信号</ins>的变化敏感。这种用法主要用于与 reg 型数据和阻塞赋值配合，建模组合逻辑。</p></li><li class="lvl-2"><p>若 <code>always</code> 紧跟语句，则表示在该语句执行完毕之后立刻再次执行。这种用法主要配合后面提到的时间控制语句使用，来产生一些周期性的信号。</p></li></ul><p><code>always</code> 的敏感条件列表中，条件使用变量名称表示，例如 <code>always @(a)</code> 表示当变量 <code>a</code> <ins>发生变化</ins>时执行之后的语句；若条件前加上 <code>posedge</code> 关键字，如 <code>always @(posedge a)</code>，表示当 <code>a</code> 达到<ins>上升沿</ins>，即从 0 变为 1 时触发条件，下降沿不触发；加上 <code>negedge</code> 则是下降沿触发条件，上升沿不触发。每个条件使用逗号 , 或 <code>or</code> 隔开，只要有其中一个条件被触发，<code>always</code> 之后的语句都会被执行。</p><div class="tips"><p>敏感条件是变量时，该变量只要变化就会触发执行，没有对高低电平的要求。</p></div><div class="warning"><p>多个 <code>always</code> 块中对同一个变量进行赋值会导致无法综合。</p></div><h3 id="Initial-块">Initial 块</h3><p><code>initial</code> 块后面紧跟的语句或顺序语句块在硬件仿真开始时就会运行，且仅会运行一次，一般用于对 <code>reg</code> 型变量的取值进行初始化。<code>initial</code> 块通常仅用于仿真，是<em>不可综合的</em>。下面的代码用于给寄存器 <code>a</code> 赋初始值 0：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><div class="note warning">            <p><code>wire</code> 型数据不能在 <code>always</code> 和 <code>initial</code> 块中赋值。<br><code>wire</code> 类型本质上模拟硬件电路中的物理导线，它本身不具备存储功能，仅用于传递信号（从驱动源到接收端）。导线的特性是 “即时响应驱动源”—— 驱动源的信号变化会立即通过导线传递，没有时间延迟或状态保持。<br>而 <code>always</code> 块描述的是时序逻辑或组合逻辑的 “计算过程”，通常包含条件判断、状态跳转等逻辑，其赋值对象需要具备 “根据逻辑计算结果更新状态” 的能力。<code>wire</code> 作为导线，无法承载这种 “计算后更新” 的语义，因此不能作为 <code>always</code> 块的赋值目标。</p>          </div><blockquote><p><strong>语句块</strong><br>块语句的作用是将多条语句合并成一组，使它们像一条语句那样。在使用上一节提到的各种控制语句或者要使用 <code>always</code>/<code>initial</code> 过程块时，如果要执行多条语句，就可以使用块语句，这就类似于 C 语言中大括号里的语句。块语句有两种：顺序块和并行块。顺序块的关键字是 <code>begin</code> - <code>end</code>，并行块的关键字是 <code>fork</code> - <code>join</code>，关键字位于块语句的起始位置和结束位置，相当于 C 语言中的左大括号和右大括号。块语句也可以嵌套。</p><ol><li class="lvl-3">顺序块中的语句是一条接一条按顺序执行的，只有前面的语句执行完成之后才能执行后面的语句，除非是带有内嵌延迟控制的非阻塞赋值语句。</li><li class="lvl-3">如果语句包括延迟，那么延迟总是相对于前面那条语句执行完成的仿真时间的。</li></ol></blockquote><h3 id="If-语句">If 语句</h3><p>Verilog 中 <code>if</code> 语句的语法和 C 语言基本相同，也有 <code>else if</code>、<code>else</code> 这样的用法。但是，<ins><code>if</code> 语句只能出现在顺序块中</ins>，其后的分支也只能是语句或顺序块。举例如下（下面的例子也使用了 <code>always</code> 建模组合逻辑）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @ * <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">begin</span></span><br><span class="line">        out = a;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        out = b;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Case-语句">Case 语句</h3><p>Verilog 中的 <code>case</code> 语句与 C 语言的写法略有区别，详见下方的示例。<code>case</code> 语句同样只能出现在<ins>顺序块</ins>中，其中的分支也只能是语句或顺序块。与 C 语言不同，<ins><code>case</code> 语句在分支执行结束后不会落入下一个分支</ins>，而会<ins>自动退出</ins>。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">case</span>(data)</span><br><span class="line">      <span class="number">0</span>: out &lt;= <span class="number">4</span>;</span><br><span class="line">      <span class="number">1</span>: out &lt;= <span class="number">5</span>;</span><br><span class="line">      <span class="number">2</span>: out &lt;= <span class="number">2</span>;</span><br><span class="line">      <span class="number">3</span>: <span class="keyword">begin</span></span><br><span class="line">          out &lt;= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">default</span>: ;</span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><div class="tips"><p>Verilog 中的 <code>case</code> 语句默认做的是全等比较，即所有位都相等（包括 <code>x</code> 和 <code>z</code>）。上例中 <code>data === 0</code> 时 <code>out</code> 才会赋值为 4。</p></div><h3 id="For-语句">For 语句</h3><p><code>for</code> 语句和 C 语言中的类似。</p><h4 id="循环变量">循环变量</h4><p><code>integer</code> 类型和 <code>reg</code> 类型的变量均可以作为循环变量，但 <code>reg</code> 型需要注意位宽的设置以免造成<ins>死循环</ins>，譬如：</p><div class="note danger">            <p>以下代码会造成 Isim 崩溃。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] tmp;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (tmp = <span class="number">2&#x27;h0</span>; tmp &lt;= <span class="number">2&#x27;h3</span>; tmp = tmp + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;tmp = %d&quot;</span>, tmp);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Finished.&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>          </div><p>这是因为 <code>tmp</code> 位宽为 2，最大只能到 2’h3，当 <code>tmp</code> 等于 2’h3 时，下一轮循环 <code>tmp</code> 溢出，回到 2’h0，如此往复导致死循环。</p><h3 id="While-语句">While 语句</h3><p><code>while</code> 语句和 C 语言中的类似。</p><div class="tips"><p>在 Verilog 中所有的循环语句只能在 always 或 initial 块中使用。</p></div><h2 id="模块实例化">模块实例化</h2><p>对于一个已经存在的模块 <code>Sample</code>，以及其定义好的接口 <code>input a</code>, <code>input b</code>, <code>output c</code>，我们可以通过以下方法进行实例化：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> x;</span><br><span class="line"><span class="keyword">wire</span> y;</span><br><span class="line"><span class="keyword">wire</span> z;</span><br><span class="line">Sample sample_instance1 (x, y, z);<span class="comment">//这里，x, y, z 会自动匹配 Sample 模块定义时的形参顺序。</span></span><br><span class="line">Sample sample_instance2 (<span class="variable">.b</span>(x), <span class="variable">.a</span>(y), <span class="variable">.c</span>(z));<span class="comment">//这里，.b, .a, .c 是为形参指定了匹配的实参。</span></span><br></pre></td></tr></table></figure><p><a id="assignment"></a></p><h2 id="非阻塞赋值和阻塞赋值">非阻塞赋值和阻塞赋值</h2><p>考察以下代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> blocked_and_non_blocked(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> b_blocked,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> c_blocked,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> b_non_blocked,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> c_non_blocked</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞赋值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        b_non_blocked &lt;= a;</span><br><span class="line">        c_non_blocked &lt;= b_non_blocked;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 阻塞赋值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        b_blocked = a;</span><br><span class="line">        c_blocked = b_blocked;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="非阻塞赋值">非阻塞赋值</h3><p><code>clk</code> 上升沿到来的时候，可以认为仿真器为 <code>&lt;=</code> 右侧的变量做了一次“快照”，即存储了它们的值。然后将“快照”值赋给了 <code>&lt;=</code> 左侧的变量。在上述代码中，<code>b_non_blocked</code> 值变为 <code>a</code> 的值，而 <code>c_non_blocked</code> 值变为原来的 <code>b_non_blocked</code> 值。</p><div class="tips"><p>处在一个 <code>always</code> 块中的非阻塞赋值是在块结束时同时并发执行的。</p></div><h3 id="阻塞赋值">阻塞赋值</h3><p>阻塞赋值是<ins>顺序执行</ins>的。在 <code>begin</code> - <code>end</code> 顺序块中，前一句阻塞赋值完成后，后一句阻塞赋值才会开始。在上述代码中，上升沿到来时，<code>b_blocked</code> 值变为 <code>a</code> 的值，然后 <code>c_blocked</code> 值才变为新的 <code>b_blocked</code> 值，即 <code>a</code> 的值。</p><div class="warning"><p>在时序逻辑中的阻塞赋值可能是不可综合的。</p></div><h2 id="有符号数的处理">有符号数的处理</h2><p><code>wire</code>, <code>reg</code> 等类型的数据默认是<ins>无符号</ins>的。</p><p>若要声明该数据是有符号的，需要使用 <code>$signed()</code>，例如 <code>$signed(a)</code>。</p><h3 id="一个简单的例子">一个简单的例子</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> comparator(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> res</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> res = a &gt;= b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>我们编写一个 Testbench 来测试，令 <code>a</code> 和 <code>b</code> 的初始值都为 1，100 ns 后令 <code>b</code> 为 -1。<br>我们期望看到 <code>res</code> 的值恒为 1，但是实际观测到 100 ns 后 <code>res</code> 的值变为 0。<br>这正是因为我们没有声明 <code>b</code> 是有符号数。Verilog 默认其为无符号数，当 <code>b</code> = -1 时，其补码为 4’b1111，会被认为是 15。<br>将比较代码修改为 <code>assign res = $signed(a) &gt; $signed(b);</code>，程序即可达到预期结果。</p><p>值得一提的是，假如将比较代码修改为 <code>assign res = a &gt; $signed(b);</code>，得到的结果也达不到预期效果。</p><p>在对无符号数和符号数同时操作时，Verilog 会自动地做数据类型匹配，将符号数向无符号数转化。因为在执行 <code>a &gt; $signed(b)</code> 时，<code>a</code> 是无符号数，<code>$signed(b)</code> 是符号数，Verilog 默认向无符号类型转化，得到的结果仍是无符号数的比较结果。</p><p>关于符号数和无符号数的原理，您可参考<a href="https://cscore.e1.buaa.edu.cn/tutorial/verilog/verilog-3/verilog-3-7/#_3">这里</a>。简单地概括，<ins>一个表达式，只要其子表达式中有任一表达式是无符号，则该表达式就是无符号的</ins>。</p><h3 id="一些注意事项">一些注意事项</h3><ul class="lvl-0"><li class="lvl-2"><p>对于<ins>移位运算符</ins>，其<ins>右侧的操作数总是被视为无符号数</ins>，并且<ins>不会对运算结果的符号性产生任何影响</ins>。结果的符号由运算符左侧的操作数和表达式的其余部分共同决定。</p></li><li class="lvl-2"><p>对于<ins>三目运算符</ins>，其 <code>?</code> 前的布尔表达式是自决定的表达式，不会对最外层表达式的符号造成影响。</p></li><li class="lvl-2"><p>算术右移在<ins>左操作数无符号时</ins>高位仍然补 <ins>0</ins>，与逻辑右移效果相同。</p></li><li class="lvl-2"><p>未指定位宽和进制的 0 的有无符号性是根据上下文决定的。而指定了位宽和进制的 0（比如 4’b0000）的符号是确定的。</p></li></ul><h2 id="宏定义">宏定义</h2><p>宏定义格式如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> WORDSIZE 8</span></span><br><span class="line"><span class="comment">// 省略模块定义</span></span><br><span class="line"> <span class="keyword">reg</span>[<span class="number">1</span>:`WORDSIZE] data;</span><br><span class="line"><span class="comment">// 相当于定义 reg[1:8] data;</span></span><br></pre></td></tr></table></figure><p>定义时，需要以反引号（<code>`</code>）开头。使用时，也需要加上反引号。</p><hr><h1 id="Verilog-例题">Verilog 例题</h1><h2 id="电梯调度">电梯调度</h2><h3 id="简介">简介</h3><p>一栋大楼有一部运行的电梯，你需要根据乘客请求和电梯状态来输出。</p><h3 id="电梯的具体信息">电梯的具体信息</h3><ul class="lvl-0"><li class="lvl-2"><p>在最开始或者每次 reset 后，电梯默认初始楼层为一楼。保证在输入到来前先进行 reset。</p></li><li class="lvl-2"><p>初始运行方向：每次 reset 后，电梯默认向上运行。</p></li><li class="lvl-2"><p>运行范围：1 至 7 层。</p></li><li class="lvl-2"><p>调度规则：</p><ul class="lvl-2"><li class="lvl-6">如果当前周期没有乘客请求 (乘客请求详细信息见下文)，则电梯将会按照当前的运行方向运动一层，并在下一周期更新楼层；如果位于边界楼层且运行方向越界，则反转运行方向并运动一层。</li><li class="lvl-6">如果当前周期有乘客请求，且乘客请求楼层与当前电梯所在楼层不相同，则电梯将会向乘客请求楼层方向移动一层，并在下一周期更新楼层，电梯运行方向也调整为向乘客请求楼层运行的方向 (若与原来方向一致则不用调整) 。</li><li class="lvl-6">如果当前周期有乘客请求，且乘客请求楼层与当前电梯所在楼层相同，则电梯将保持不动，并在下一周期维持楼层，电梯运行方向不改变。</li></ul></li></ul><h3 id="乘客请求">乘客请求</h3><ul class="lvl-0"><li class="lvl-2"><p>存在乘客请求的条件：</p><ul class="lvl-2"><li class="lvl-6">若 from = 0 并且<ins>不存在未完成的乘客请求</ins>，则视为当前周期没有乘客请求。反之，如果 from != 0 或者+存在未完成的乘客请求++，则视为当前周期有乘客请求。</li><li class="lvl-6">若 from != 0，则视为当前周期有新到来的乘客请求。该乘客请求将会一直存在直到满足取消条件 ( 即使后续周期 from = 0 ) ，在此期间内视为：存在一个未完成的乘客请求。</li><li class="lvl-6">若 from = 0 并且<ins>存在一个未完成的乘客请求</ins>，则该乘客请求继续存在直至满足取消条件。</li></ul></li><li class="lvl-2"><p>取消乘客请求的条件：</p><ul class="lvl-2"><li class="lvl-6">若当前周期的乘客请求楼层和电梯的当前所在楼层相同，则视为满足该请求的取消条件，在下一个周期开始时取消该请求。</li><li class="lvl-6">若当前周期有 reset 信号，则在下一周期取消该乘客请求。</li></ul></li><li class="lvl-2"><p>其他规则：输入数据保证在上一个乘客请求满足取消条件之前，不会输入下一个乘客请求。 也就是当 from != 0 时，当前一定不存在未完成的乘客请求。</p></li></ul><h3 id="输出要求">输出要求</h3><p>当乘客请求楼层和电梯的当前所在楼层相同时，输出 1 ；否则输出 0 。</p><h3 id="样例">样例</h3><p><img src="/posts/c9f56abd/elevator.png" alt="样例"><br>如图，在 reset 后电梯默认从一楼向上运行。<br>在电梯运行到三楼时，输入了一楼的乘客请求，于是下个周期电梯向乘客请求楼层 (一楼) 方向运行，回到了二楼。然后再下个周期电梯到了一楼，此时电梯楼层和乘客请求楼层相同，因此输出 out 置为 1 ,同时下个周期电梯保留楼层和运行方向。再下个周期输入为 0，电梯掉头向上运行，同时取消上一个乘客请求。</p><p>当电梯继续运行到五楼时，输入了同层五楼的乘客请求，输出 out <ins>立刻</ins>置为 1 ，同时下一周期电梯保留原楼层和运行方向，同时取消乘客请求。再下个周期输入为 0，电梯正常向上运行至六楼。</p><div class="warning"><p>请认真阅读波形图，一切逻辑以波形图所示为准！</p></div><h3 id="分析">分析</h3><p>本题适合用时序逻辑来解决。按照题意，在没有乘客请求的时候，电梯全自动运行，故首先我们需要解决这个问题。我们应当维护两个变量，它们分别是当前的楼层和电梯运行方向，记作 <code>cur_floor</code> 和 <code>direction</code>。简单起见，由于楼层只有七层，可以用一个 3 位二进制数表示（001 至 111），方向则用 0 和 1 表示上与下，简略代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span><span class="comment">//初始化在一楼，向上</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset == <span class="number">1</span>) <span class="keyword">begin</span><span class="comment">//reset逻辑</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="number">0</span>) <span class="keyword">begin</span><span class="comment">//上</span></span><br><span class="line">            <span class="keyword">if</span> (cur_floor == <span class="number">3&#x27;b111</span>) <span class="keyword">begin</span><span class="comment">//顶楼</span></span><br><span class="line">                direction &lt;= <span class="number">1</span>;</span><br><span class="line">                cur_floor &lt;= cur_floor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span><span class="comment">//未到顶楼</span></span><br><span class="line">                cur_floor &lt;= cur_floor + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span><span class="comment">//下</span></span><br><span class="line">            ...<span class="comment">//类似逻辑</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果有乘客请求，其实有两种情况需要考虑：</p><ul class="lvl-0"><li class="lvl-2"><p>当 <code>from</code> 信号出现的时候，电梯尚未到该楼层。</p></li><li class="lvl-2"><p>当 <code>from</code> 信号出现的时候，电梯已经到该楼层。</p></li></ul><p>如果电梯还没到，则需要想办法保存下这个乘客请求的楼层号，然后及时调整电梯运行方向。当某个上升沿确认 <code>cur_floor</code> 等于 <code>from</code> 的楼层（当然这个 <code>from</code> 是一个副本，因为 <code>from</code> 输入可能只持续一个周期就归零了，接下来将把这个副本叫做 <code>request</code>）时，让下一个周期保持运行方向和楼层不变。<ins>这是样例中 30ns 时发出 1 楼请求的情况</ins>。可以看到，45ns 的上升沿电梯刚好到 1 楼，同时 <code>request</code> 等于 <code>cur_floor</code>，<code>out</code> 置为 1，下一个周期（55ns - 65ns）电梯保持在 1 楼。</p><p>如果发出乘客请求时，电梯正好处于该楼层，则情况稍微会复杂些。按照样例的解释（一切逻辑以样例为准！），100ns 发出 5 楼的请求，此时时钟信号正处于<ins>下降沿</ins>，而 <code>out</code> 被<ins>立刻</ins>置为 1。很明显 <code>out</code> 的输出采用的组合逻辑的 <code>assign</code> 语句，一检测到 <code>from</code> 或 <code>request</code> 与 <code>cur_floor</code> 相匹配就立刻置为 1（对于第一种情况，当然是检测 <code>request</code> 的信号，第二种则是 <code>from</code>）。再看电梯停留在 5 楼的时间。105ns 时电梯本准备往 6 楼去，而实际上停留在 5 楼，这就说明 105ns - 115ns 是电梯停留的一周期。也就是说，95ns - 105ns 发生了 <code>cur_floor</code> 和 <code>from</code> 的判定，即在第二种情况下判定并不是发生在上升沿的，而是立即判定！</p><p>我们如果想要电梯停留在某一层一个周期，可以这样写：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) <span class="keyword">begin</span></span><br><span class="line">    cur_floor &lt;= cur_floor;</span><br><span class="line">    direction &lt;= direction;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>无论怎么说，使用非阻塞赋值就决定了这一逻辑一定会在某个上升沿激活。对于第一种情况，我们可以大胆地让 <code>cur_floor == request</code> 作为条件，根据“乘客请求-其他规则”，<code>request</code> 尚未解决时不会有新的 <code>from</code> 出现。可以预见的是一定会在某个上升沿满足条件，然后下一个上升沿执行上述的等待逻辑。对于第二种情况，则大有不同了，接受 <code>from</code> 信号后将其赋给 <code>request</code> 必定也使用非阻塞赋值，那么 <code>request</code> 的赋值要等到 <code>from</code> 信号来临的下一个上升沿，即二者会出现一定的时间差。这对于 <code>out</code> 的输出，以及电梯的等待，都是不可接受的。具体到样例中，如果接到 <code>from</code> 信号后立刻赋给 <code>request</code>，那么 105ns 时 <code>request</code> 才会被置为 1。如果还用 <code>cur_floor == request</code> 作为条件，5 楼的等待时间将会延长到 115ns - 125ns 周期，这就错了。而且 <code>out</code> 与 <code>from</code> 和 <code>request</code> 挂钩，如果在 <code>request</code> 已经被赋值（105ns），再用条件判断将其归零，也许要等到下一个上升沿（115ns），这样， <code>out</code> 就会从 100ns 一直激活到 115ns。</p><p>总的来说，面对第二种情况，等待逻辑的判定条件必须是 <code>cur_floor == from</code>，而且如果满足该条件，就要立刻发出 <code>request</code> 归零的命令，让 <code>request</code> 赶在下一个上升沿（105ns）就归零，相当于“反悔给 <code>request</code> 赋值”（这样做从波形上来看，<code>request</code> 不会被赋值，因为赋值和归零都是在上升沿以外的地方进行的），避免 <code>out</code> 激活时间过长。</p><hr><h1 id="Verilog-工程的设计开发调试">Verilog 工程的设计开发调试</h1><h2 id="编写可综合代码">编写可综合代码</h2><div class="warning"><p>以下规则不适用于 Testbench。</p></div><ul class="lvl-0"><li class="lvl-2"><p>勿使用 Initial 块、勿为 Reg 型（寄存器）赋初值。</p></li><li class="lvl-2"><p>一个寄存器只能在<ins>一个</ins> <code>always</code> 块中赋值<ins>一次</ins>。<br>以下代码不可综合：</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> a;</span><br><span class="line"><span class="keyword">wire</span> b, c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_1) <span class="keyword">begin</span></span><br><span class="line">    a &lt;= b;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_2) <span class="keyword">begin</span></span><br><span class="line">    a &lt;= c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>实际上，Reg 型一般会被综合为 D 触发器，只有一个时钟输入，而上述代码让该触发器处于两个时钟域中。</p><p>何谓赋值一次？如果使用 <code>if</code> / <code>else</code> / <code>case</code> 语句进行条件判断，在不同且互斥的情况下对同一个寄存器进行赋值，是完全合法的。而其他情况是不可被综合的。</p>          </div><ul class="lvl-0"><li class="lvl-2"><p>尽量避免综合后的奇怪故障</p><ol><li class="lvl-7">在时序逻辑中，永远使用非阻塞赋值（<code>&lt;=</code>）；在组合逻辑中，永远使用阻塞赋值（<code>=</code>）；</li><li class="lvl-7">每个组合逻辑运算结果仅在一个 <code>always @(*)</code> 中修改；</li><li class="lvl-7">在 <code>always @(*)</code> 中，为每个运算结果赋初值，避免 latch<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 的产生。</li><li class="lvl-7">使用位运算代替乘除法。</li></ol></li></ul><h2 id="Verilog-代码规范">Verilog 代码规范</h2><h3 id="命名">命名</h3><ol><li class="lvl-3"><p>信号名采用 <code>snake_case</code>，<code>PascalCase</code> 或者 <code>camelCase</code>。全工程采用统一命名方式。</p><ul class="lvl-2"><li class="lvl-6"><code>snake_case</code>：变量名全小写，单词间以下划线连接。</li><li class="lvl-6"><code>PascalCase</code>：首字母全大写。</li><li class="lvl-6"><code>camelCase</code>：第一个字母小写，后续首字母大写。</li></ul></li><li class="lvl-3"><p>低电平有效信号用 <code>_n</code> 后缀。</p></li><li class="lvl-3"><p>多路选择器标明规格。例如 4 选 1 的 32 位 MUX可记作 <code>MUX4_1_32</code>。</p></li><li class="lvl-3"><p>对于状态机，各状态一定要命名，避免在代码中出现不知所云的数字。</p></li></ol><h3 id="组合逻辑的编写">组合逻辑的编写</h3><ol><li class="lvl-3"><p>一个信号只在一个 <code>always</code> 块中赋值。</p></li><li class="lvl-3"><p>组合逻辑用 <code>always @(*)</code> 块或者 <code>assign</code>。</p></li><li class="lvl-3"><p>组合逻辑的 <code>always</code> 块只用阻塞赋值。</p></li><li class="lvl-3"><p>确保所有分支都赋值，否则出现锁存器<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>。</p></li></ol><h3 id="时序逻辑">时序逻辑</h3><ol><li class="lvl-3"><p>时序逻辑用 <code>always @(posedge clock)</code>。</p></li><li class="lvl-3"><p>时序逻辑的 <code>always</code> 块只用非阻塞赋值。</p></li><li class="lvl-3"><p>通常情况下，不要用下降沿触发。</p></li><li class="lvl-3"><p>除了 <code>always</code> 敏感列表外，不要用时钟信号。</p></li><li class="lvl-3"><p>使用<ins>同步复位</ins>而非异步复位<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p></li></ol><h3 id="代码风格">代码风格</h3><ol><li class="lvl-3"><p>单目运算符与变量间<ins>不</ins>添加空格。</p></li><li class="lvl-3"><p>同一逻辑，但表达式复杂的语句，使用换行进行切割：</p></li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line"><span class="keyword">assign</span> d = (op == <span class="number">0</span>) ? a + b :</span><br><span class="line">           (op == <span class="number">1</span>) ? a - b :</span><br><span class="line">           (op == <span class="number">2</span>) ? a &amp; b :</span><br><span class="line">                       a | b;</span><br><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="keyword">assign</span> d = (op == <span class="number">0</span>) ? a + b :(op == <span class="number">1</span>) ? a - b :(op == <span class="number">2</span>) ? a &amp; b : a | b;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>显式声明数字位宽。</p></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>如果没有初值，编译器会认为需要保持上一次该变量的值不变，这是符合锁存器（Latch）定义的。 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><ins>同步复位（Synchronous Reset）</ins>：复位信号的生效与时钟同步，只有时钟的有效沿到来时才生效。<br><ins>异步复位（Asynchronous Reset）</ins>：复位信号的生效与时钟无关，只要复位信号有效，立即执行复位操作，无需等待时钟沿。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/CO-Pre/">CO Pre</category>
      
      <category domain="https://samuflore.top/tags/Verilog/">Verilog</category>
      
      <category domain="https://samuflore.top/tags/ISE/">ISE</category>
      
      
      <comments>https://samuflore.top/posts/c9f56abd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CO Pre]One-Hot 编码</title>
      <link>https://samuflore.top/posts/9707d4af/</link>
      <guid>https://samuflore.top/posts/9707d4af/</guid>
      <pubDate>Tue, 19 Aug 2025 14:06:21 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;独热编码&lt;/strong&gt;（One-Hot Encoding），又称&lt;strong&gt;一位有效编码&lt;/strong&gt;，是一种将分类变量转换为数值形式的常用方法。其核心思想是，将一个具有 N 个不同类别的分类特征转换为 N 个二元（0 或 1）特征，其中每个新特征对应原始特征中的一个类别。对于每一个样本，只有代表其原始类别的那个新特征值为 1，其余所有新特征值均为0。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p><strong>独热编码</strong>（One-Hot Encoding），又称<strong>一位有效编码</strong>，是一种将分类变量转换为数值形式的常用方法。其核心思想是，将一个具有 N 个不同类别的分类特征转换为 N 个二元（0 或 1）特征，其中每个新特征对应原始特征中的一个类别。对于每一个样本，只有代表其原始类别的那个新特征值为 1，其余所有新特征值均为0。</p><span id="more"></span><h1 id="原来的问题">原来的问题</h1><p>对于一个人，ta 会具有多种属性，比如性别、职业、国籍等等。现在假设有一组人的样本，他们的属性在如下范围内：</p><ul class="lvl-0"><li class="lvl-2"><p>性别：男、女</p></li><li class="lvl-2"><p>职业：医生、律师、程序员、学生</p></li><li class="lvl-2"><p>国籍：中国、美国、法国</p></li></ul><p>如果将上述属性用数字进行表示，会更有利于计算机处理，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;男&quot;, &quot;医生&quot;, &quot;中国] -&gt; [0, 0, 0]</span><br><span class="line">[&quot;女&quot;, &quot;程序员&quot;, &quot;法国&quot;] -&gt; [1, 2, 2]</span><br></pre></td></tr></table></figure><p>但是，这是不适合机器学习的。<br>在机器学习中，许多算法，特别是线性模型（如线性回归、逻辑回归）和距离度量相关的算法（如K近邻），都是基于数值计算的。如果直接将“医生”、“律师”、“程序员”用数字0、1、2来表示（这种方法称为标签编码 Label Encoding），模型可能会错误地学习到这些类别之间存在有序关系。比如“程序员”是“律师”的 2 倍，这是荒谬的。</p><p>因此，我们需要新的方法。</p><h1 id="One-Hot-编码">One-Hot 编码</h1><p>对于性别这一属性，二者天然是互斥的，所以我们可以用一个二维向量来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 0] 男</span><br><span class="line">[0, 1] 女</span><br></pre></td></tr></table></figure><p>对于职业，则可以用四维向量来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 0, 0, 0] 医生</span><br><span class="line">[0, 1, 0, 0] 律师</span><br><span class="line">[0, 0, 1, 0] 程序员</span><br><span class="line">[0, 0, 0, 1] 学生</span><br></pre></td></tr></table></figure><p>独热编码通过将每个类别独立表示为一个特征，完美地解决了这个问题。每个类别都处于一个正交的向量空间中，它们（例如 [1, 0, 0]、[0, 1, 0] 和 [0, 0, 1]）之间的距离是相等的，从而消除了标签编码可能引入的虚假顺序关系，让模型能够更准确地学习特征与目标之间的关系。<br>正如其名“One-Hot”，在每一行数据中，只有一个新特征是“热”的（值为 1）。</p>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/CO-Pre/">CO Pre</category>
      
      <category domain="https://samuflore.top/tags/One-Hot-Encoding/">One-Hot Encoding</category>
      
      
      <comments>https://samuflore.top/posts/9707d4af/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CO Pre]Logisim 入门</title>
      <link>https://samuflore.top/posts/e7ebcfa7/</link>
      <guid>https://samuflore.top/posts/e7ebcfa7/</guid>
      <pubDate>Thu, 14 Aug 2025 14:53:54 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Logisim 部分。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Logisim 部分。</p><span id="more"></span><hr><h1 id="什么是-Logisim？">什么是 Logisim？</h1><blockquote><p>Logisim 是一款非常优秀的用于数字电路设计与仿真的教育软件。它提供了丰富的电路库与元件的抽象表示，生成的电路图也比较美观，还提供了时序的模拟功能，能够让我们对 CPU 的结构和运行情况有更直观的理解，并且在开发一些小电路时还有一些其他辅助功能。<br><a href="https://cscore.e1.buaa.edu.cn/tutorial/logisim/logisim-1/logisim-1-1/">为什么要学习 Logisim？</a></p></blockquote><hr><h1 id="这里有什么？">这里有什么？</h1><ul class="lvl-0"><li class="lvl-2"><p>Logisim 门电路</p></li><li class="lvl-2"><p>Logisim 组合电路</p></li><li class="lvl-2"><p>Logisim 时序电路</p></li><li class="lvl-2"><p>Logisim 仿真与调试</p></li><li class="lvl-2"><p>应用与挑战</p></li></ul><hr><h1 id="Logisim-门电路">Logisim 门电路</h1><h2 id="界面认识">界面认识</h2><p>打开 Logisim 后，我们会看到如下的界面：<br><img src="/posts/e7ebcfa7/logisim%E7%95%8C%E9%9D%A2.png" alt="界面"><br>Logisim 提供图形界面，可以通过长按拖动的形式新建部件以及进行连线。也可通过 <code>Ctrl + D</code> 快速部署选中的部件。</p><h2 id="元件概览">元件概览</h2><h3 id="Wirings（线路）">Wirings（线路）</h3><p><img src="/posts/e7ebcfa7/wiring.png" alt="wiring"></p><p><a id="tunnel"></a></p><h4 id="Tunnel（隧道）">Tunnel（隧道）</h4><p>​Tunnel 部件是在整个 Logisim 实验中简化电路布线复杂度效果最好的一个部件，可以让你在纷繁复杂的接线中解脱出来，让你能够更加专心的关注于各个部件的设计，而不被复杂的接线所打扰。<br>​Tunnel 名为隧道，即它可以将标签<strong>相同</strong> Tunnel 之间的数据，通过一个不可见的“隧道”进行传输，在使用过程中，可以链接数据的输入端和输出端，使得数据可以方便简单的传输。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p><img src="/posts/e7ebcfa7/Tunnel.png" alt="Tunnel"></p><p>拥有不同标签的 Tunnel 之间，数据传输是独立的。</p><h4 id="Probe（探针）">Probe（探针）</h4><p>​Probe 作为一个显示线路数据值的部件，可以对多位宽数据进行实时监控，简而言之，就是可以直接显示接线的数值，并且不影响整个电路的运行。<br>Probe 有点类似于输出引脚，可以显示数值，它可以显示<strong>多位宽数据</strong>。</p><p><img src="/posts/e7ebcfa7/Probe.png" alt="Probe"></p><p><a id="splitter"></a></p><h4 id="Splitter（分叉器）">Splitter（分叉器）</h4><p>​Splitter 是一个多路分叉器，可以将一个数据输入端分成多个输出端，可以将数据进行分流，使得数据可以分别处理。每条岔路都会注明数据来源的<strong>位编号</strong>，位编号从 0 开始，对应数据源最靠右的位，例如：</p><p><img src="/posts/e7ebcfa7/Splitter.png" alt="Splitter"></p><p>要注意，Splitter 分流后，数据的位宽会相应的发生改变，因此输出引脚的位宽也需要改变。</p><div class="note info">            <p>Splitter 的输出引脚也可以当输入来用，这时，原先的输入引脚会输出此时输入的数据的组合（按照位次顺序）。</p>          </div><h4 id="Bit-Extender（位扩展）">Bit Extender（位扩展）</h4><p>Bit Extender 有三个主要的参数：</p><ul class="lvl-0"><li class="lvl-2"><p><code>Bit Width In</code>：输入数据的位宽</p></li><li class="lvl-2"><p><code>Bit Width Out</code>：输出数据的位宽</p></li><li class="lvl-2"><p><code>Extension Type</code>：扩展方式，包括 <code>Zero</code>, <code>One</code>, <code>Sign</code>, <code>Input</code>。</p></li></ul><p>当输入数据的位宽<strong>小于</strong>输出数据的位宽时，Bit Extender 保留全部输入数据，然后补充内容使得输出数据位宽达到要求。</p><ul class="lvl-0"><li class="lvl-2"><p>若 <code>Extension Type</code> 为 <code>Zero</code>，则补充 0。</p></li><li class="lvl-2"><p>若 <code>Extension Type</code> 为 <code>One</code>，则补充 1。</p></li><li class="lvl-2"><p>若 <code>Extension Type</code> 为 <code>Sign</code>，则补充符号位<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p></li></ul><p>当输入数据的位宽<strong>大于</strong>输出数据的位宽时，Bit Extender 从低到高截取需要的位数，其余的舍弃。</p><p><img src="/posts/e7ebcfa7/BE.png" alt="BE"></p><h4 id="Clock（时钟）">Clock（时钟）</h4><p>在 Simulate 菜单中开启 Ticks Enabled 选项，Clock 会自动经历周期，释放信号。<br>Clock 可以指定 <code>High Duration</code> 和 <code>Low Duration</code>，分别表示高电平持续时间和低电平持续时间。单位为 <code>Tick(s)</code>。</p><p><img src="/posts/e7ebcfa7/Clock.png" alt="Clock"></p><div class="note info">            <p>Logisim 对时钟的模拟是理想状态的：在实际电路中，多个时钟会相互漂移，并且永远不会同步移动。 但在 Logisim 中，所有时钟都以相同的速率经历滴答声。</p>          </div><p><a id="circle"></a><br>Clock 的周期：</p><p><img src="/posts/e7ebcfa7/Clock2.png" alt="Clock2"></p><h3 id="Gates（门）">Gates（门）</h3><p><img src="/posts/e7ebcfa7/gate.png" alt="gate"></p><h4 id="Odd-Parity（奇校验）">Odd Parity（奇校验）</h4><p>奇校验门和异或门在<ins>两个输入端</ins>时表现相同。但是如果有<ins>超过两个</ins>指定的输入，异或门将在刚好++只有一个 1 <ins>的时候输出 1。而奇校验门在</ins>奇数个 1 ++输入时就会输出 1。<br><img src="/posts/e7ebcfa7/OP.png" alt="OP"></p><p>第一列和第二列均为奇数个 1，则输出端的第一列和第二列均为 1。</p><div class="note info">            <p>这与异或门的 <code>Multiple-Input Behavior</code> 字段选择 <code>When an odd number are on</code> 是一致的，而其默认选项是 <code>When one input is on</code> （只有一个 1 时输出 1）。</p>          </div><h4 id="Even-Parity（偶校验）">Even Parity（偶校验）</h4><p>偶校验门在输入端有偶数个 1 时输出 1，否则输出 0。<br><img src="/posts/e7ebcfa7/EP.png" alt="EP"></p><h3 id="Plexers（复用器）">Plexers（复用器）</h3><p><img src="/posts/e7ebcfa7/plexer.png" alt="plexer"></p><h4 id="Multiplexer-MUX-（多路选择器）">Multiplexer(MUX)（多路选择器）</h4><p>在组合电路中，多路选择器（Multiplexer，简称 MUX）是非常重要的一类部件，他们在组合电路中扮演着非常重要的角色。下图是一个典型的 Logisim 中的多路选择器，左侧是多个输入，右侧是相应的输出，通过底部（黑色）的选择信号，对输入的信号进行选择后输出。另外一个端口是部件的使能端，当其为高电平（为 1）时，整个部件使能工作。</p><p><img src="/posts/e7ebcfa7/MUX.png" alt="MUX"></p><p>选择信号：当 <code>Select Bits</code> 字段为 n 时，选择信号的位宽为 n，此时输入引脚有 2<sup>n</sup> 个。选择信号的值表示选择<ins>要输出的输入信号的位次</ins>，自上而下，从 0 开始。</p><h4 id="Demultiplexer-DMX-（多路分配器）">Demultiplexer(DMX)（多路分配器）</h4><p>多路分配器和多路选择器功能恰好相反，即能够将 1 个输入数据，根据需要传送到多个输出端的任何一个输出端。</p><p><img src="/posts/e7ebcfa7/DMX.png" alt="DMX"></p><p>选择信号：当 <code>Select Bits</code> 字段为 n 时，选择信号的位宽为 n，此时输出引脚有 2<sup>n</sup> 个。选择信号的值表示选择要<ins>把输入信号复制到第几个输出引脚上</ins>，自上而下，从 0 开始。</p><h4 id="Decoder（译码器）">Decoder（译码器）</h4><p>如下图，右侧是多个输出，底部是黑色的选择信号与使能端。译码器最大的功能在于将二进制编码转换为相应的<a href="https://samuflore.top/posts/9707d4af/">独热码（one-hot）</a>，如 101 的 3 位二进制编码作为输入就会被转换成 00100000 的 8 位独热码作为输出。因而该元件得名译码器。</p><p><img src="/posts/e7ebcfa7/decd.png" alt="decd"></p><p>译码器与多路选择器不同之处有两点：</p><ol><li class="lvl-3"><p>除选择信号外，多路选择器是多输入，单输出，输出取决于输入与选择信号，译码器则是无输入，多输出，输出模式仅取决于选择信号。</p></li><li class="lvl-3"><p>译码器输出位宽每个信号仅一位，多路选择器可以有多位。</p></li></ol><h4 id="Bit-Selector（位选择器）">Bit Selector（位选择器）</h4><p>Bit Selector 有两个重要的参数：</p><ul class="lvl-0"><li class="lvl-2"><p><code>Data Bits</code>: 输入数据的位宽</p></li><li class="lvl-2"><p><code>Output Bits</code>: 输出数据的位宽<br>Bit Selector 有两个输入：data 和 dist。其中，dist 宽度为 ⌈log<sub>2</sub>(⌈data / <code>Output Bits</code>⌉)⌉。<br>一个输出为 <code>Output Bits</code> 位宽。<br>Bit Selector 根据输出数据的位宽将输入数据等分成若干段，每段为 <code>Output Bits</code> 位宽。然后根据 <code>dist</code> 指定的编号从低到高选出需要的段并输出。</p></li></ul><p><img src="/posts/e7ebcfa7/BS.png" alt="BS"></p><h3 id="Arithmetic（运算器）">Arithmetic（运算器）</h3><p><img src="/posts/e7ebcfa7/arithmetic.jpg" alt="arithmetic"></p><h4 id="Negator（取反）">Negator（取反）</h4><p>Negator 是一个单输入的运算器。名曰取反，实则求补。即<strong>取反加一</strong>。<br><img src="/posts/e7ebcfa7/negator.png" alt="negator"></p><h4 id="Shifter（移位）">Shifter（移位）</h4><p>Shifter 含有两个输入，data 和 dist，它有一个输出，这是根据 dist 位移动数据的结果。data 和输出具有相同的位宽。</p><div class="note warning">            <p>data 的位宽和 dist 的位宽需要满足下述数学关系：<br>dist = ⌈log<sub>2</sub>data⌉</p>          </div>  <p>Shifter 支持以下几种移位方式：</p><ul class="lvl-0"><li class="lvl-2"><p>Logical Left（逻辑左移）: 数据中的所有位向左移动 dist 位，底部空出的位用 0 填充。例如，11001011逻辑左移两次就是00101100（之前的右边两位丢弃）。</p></li><li class="lvl-2"><p>Logical Right（逻辑右移）: 数据中的所有位向右移动 dist 位，左端空出的位用 0 填充。例如，11001011逻辑右移两次就是00110010（之前的左边两位丢弃）。</p></li><li class="lvl-2"><p>Arithmetic Right（算术右移）: 数据中的所有位向右移动 dist 位，左端空出的位用数据中<strong>最高位</strong>重复填充。例如，11001011算术右移两次就是11110010（之前最高位为 1，所以用 1 填充）。</p></li><li class="lvl-2"><p>Rotate Left（循环左移）:   数据中的所有位都向左移动 dist 位，左边被“挤出去”的位填充到右边空出的位。例如，将11001011循环左移两次就是00101111。</p></li><li class="lvl-2"><p>Rotate Right（循环右移）:  数据中的所有位都向右移动 dist 位，右边被“挤出去”的位填充到左边空出的位。例如，将11001011循环右移两次就是11110010。</p></li></ul><p><img src="/posts/e7ebcfa7/shifter.png" alt="shifter"></p><div class="note info">            <p><a href="https://blog.csdn.net/Hi_KER/article/details/121049347">本小节摘自 CSDN</a></p>          </div><h4 id="Bit-Finder（位查找）">Bit Finder（位查找）</h4><p>Bit Finder 有一个 n 位宽的输入，有一个 1 位宽的输出，表示在输入中是否找到对应的值。对于 n 位的输入，Bit Finder 有一个 ⌈log<sub>2</sub>n⌉ 位宽的输出表示找到的值的编号。<br>Bit Finder 有一个 <code>Type</code> 参数：</p><ul class="lvl-0"><li class="lvl-2"><p>Lowest-order 1: 自<strong>最低位</strong>开始查找 1</p></li><li class="lvl-2"><p>Highest-order 1: 自<strong>最高位</strong>开始查找 1</p></li><li class="lvl-2"><p>Lowest-order 0: 自<strong>最低位</strong>开始查找 0</p></li><li class="lvl-2"><p>Highest-order 0: 自<strong>最高位</strong>开始查找 0</p></li></ul><div class="tips"><p>无论何种查找方式，返回的都是绝对位次，即从右往左数从 0 开始的位次。</p></div><p><img src="/posts/e7ebcfa7/BF.png" alt="BF"></p><h4 id="Adder（加法）">Adder（加法）</h4><p>Adder 将两个左端输入值数学相加，并在右端输出结果。</p><p><img src="/posts/e7ebcfa7/Adder.png" alt="Adder"></p><h4 id="Subtractor（减法）">Subtractor（减法）</h4><p>Subtractor 将两个左端输入值数学相减，并在右端输出结果。</p><p><img src="/posts/e7ebcfa7/Subtractor.png" alt="Subtractor"></p><div class="warning"><p>差值为负，则结果为其补码。</p></div><h4 id="Bit-Adder（位加法）">Bit Adder（位加法）</h4><p>Bit Adder 计算输入中有多少位是 1，并输出为 1 的位的数量。对于 n 位的输入，Bit Adder 有一个 ⌈log<sub>2</sub>n⌉ 位宽的输出表示 1 的位的数量。</p><div class="warning"><p>Bit Adder 可以指定至多 32 个输入。此时 n<sub>总</sub> 为所有输入的 n 之和。</p></div><p><img src="/posts/e7ebcfa7/BA.png" alt="BA"></p><h4 id="Comparator（比较）">Comparator（比较）</h4><p>Comparator 比较两个值（无符号值或两个补码值，可选）的大小。Comparator 有 3 个输出，通常，其中一个输出为1，另外两个输出为0。</p><p><img src="/posts/e7ebcfa7/Comparator.png" alt="Comparator"></p><h3 id="Memory（存储）">Memory（存储）</h3><p><img src="/posts/e7ebcfa7/memory.png" alt="memory"></p><h4 id="Register（寄存器）">Register（寄存器）</h4><p>Register 存储单个多位值，该值以<ins>十六进制</ins>形式显示在其矩形内，并在其输出端输出。当时钟信号输入满足 Register 触发条件时，存储在 Register 中的值就会在该时刻改变为 D 输入的值。时钟信号指示 Register 储存值发生改变的确切条件是通过触发属性配置的，Logisim 中一般有时钟<strong>上升沿</strong>和<strong>下降沿</strong>，<strong>高电平</strong>和<strong>低电平</strong>这四种触发方式。</p><p>使能信号：使能信号输入为 1 时，Register 开始工作，输入信号 D 有效。使能信号输入为 0 时，Register 停止工作，输入信号 D 无效。</p><p><img src="/posts/e7ebcfa7/Register.png" alt="Register"></p><p>Reset（复位）输入异步地将 Register 的值重置为0（全部为0），也就是说，只要 Reset 为 1，Register 的值就固定为 0，不管时钟和输入是什么。</p><p>关于四种触发方式在周期的位置，请看<a href="#circle">此处</a></p><h4 id="RAM（随机存取存储器）">RAM（随机存取存储器）</h4><div class="warning"><p>在我们的实验中，我们采用的是读与写相互分离的类型，所以在选择 RAM 时，请将数据接口选择为 <code>Separate load and store ports</code>。</p></div><p>RAM 组件是 Logisim 内置库中最复杂的组件，最多可存储 16,777,216 个值（在 地址位宽度/Address Bit Width 属性中指定），每个值最多可包含 32 位（在 数据位宽度/Data Bit Width 属性中指定）。RAM 可加载和存储数据。此外，用户可以通过 Poke 工具 (Poke Tool) 交互修改单个值，或者可以通过 菜单工具 (Menu Tool) 修改整个内容。<br>储存的数据值在组件中显示。地址以灰色字体形式陈列在显示区域的左边。在内部，每个值都使用十六进制格式列出。当前选定地址的值将以反色（白字黑底）显示。</p><p><img src="/posts/e7ebcfa7/RAM.png" alt="RAM"></p><div class="note info">            <p>除了 clr(Clear, 为 1 时复位整个 RAM) 信号和时钟信号，sel(Chip Select, 选择生效的 RAM，即电路中同时刻只有一个 RAM 可用), str(Store, 为 1 时允许在时钟信号为高电平时将 D 输入信号写入 RAM), ld(Load, 为 1 时允许在时钟信号为高电平时从 RAM 中读取数据) 在没有输入的情况下均默认为 1。</p>          </div><h4 id="ROM（只读存储器）">ROM（只读存储器）</h4><p>ROM 组件最多可以存储 16,777,216 个值(在地址位宽度属性中指定)，每个值最多可以包含32 位(在 数据位宽度/Address Bit Width 属性中指定)。电路可以访问 ROM 中的储存值，但不能改变它们。用户可以通过 Poke 工具交互修改单个值，或者用户可以通过菜单工具修改整个内容。<br>与 RAM 组件不同，ROM 组件的当前内容是作为组件的属性存储的。因此，如果一个包含ROM 组件的电路被使用了两次，这两个 ROM 组件都持有相同的值。也因为这种行为，ROM 的数据存储在 Logisim 创建的文件中。<br>当前值显示在组件中。显示的地址以灰色显示在显示区域的左边。在内部，每个值都使用十六进制列出。当前选定地址的值将以相反的文本(白底黑)显示。</p><p><img src="/posts/e7ebcfa7/ROM.png" alt="ROM"></p><div class="note info">            <p>ROM 的数据是存储在本地的，以一个 .txt 形式。内含非零地址及其值，第一行固定为 <code>v2.0 raw</code>。</p>          </div><h3 id="I-O（输入输出）">I/O（输入输出）</h3><p><img src="/posts/e7ebcfa7/io.png" alt="io"></p><h3 id="Base（基本组件）">Base（基本组件）</h3><p><img src="/posts/e7ebcfa7/base.png" alt="base"></p><h2 id="一位全加器">一位全加器</h2><p>一位全加器由两个输入 A 和 B，一个进位输入 Cin，一个输出 S，一个进位输出 Cout 组成。全加器的表达式为：<br><code>S = A ^ B ^ Cin; Cout = A &amp; B | Cin &amp; (A ^ B);</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><br>对于 S 的运算，我们可以作出：<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><br><img src="/posts/e7ebcfa7/S.png" alt="S">利用已有的运算结果，进一步搭建整个电路：<br><img src="/posts/e7ebcfa7/Full.png" alt="Full"></p><p><a id="swap"></a></p><h2 id="Swap-电路">Swap 电路</h2><p>现在需要你使用基础的门电路搭建这样一个电路，当输入 S 为 0（低电平）时，输出 O1 等于输入 I1，输出 O2 等于输入 I2。当输入 S 为 1（高电平）时，则交换两输出，即输出 O2 等于输入 I1，输出 O1 等于输入 I2。我们给它取名叫做 swap 电路。</p><h3 id="提交要求">提交要求</h3><p><strong>用 Logisim 完成 swap 电路</strong></p><ul class="lvl-0"><li class="lvl-2"><p>文件内模块名：<code>swap</code></p></li><li class="lvl-2"><p>输入：<code>I1</code>(1 bit), <code>I2</code>(1 bit), <code>S</code>(1 bit)</p></li><li class="lvl-2"><p>输出：<code>O1</code>(1 bit), <code>O2</code>(1 bit)</p></li><li class="lvl-2"><p><strong>注意：请从门级电路开始搭建，切勿使用 Plexers 类元件。</strong></p></li><li class="lvl-2"><p><strong>测试电路图（我们将使用下方的电路对你搭建的电路进行测试，测试的原理是将下图的 swap 模块替换为你提交文件中的 swap 模块，随后测试机会仿真运行下图中的电路图，记录其输出并与正确的输出进行对比）</strong></p></li></ul><p><img src="/posts/e7ebcfa7/test.png" alt="test"></p><p>模块样式：</p><p><img src="/posts/e7ebcfa7/swap_circuit.png" alt="swap_circuit"></p><h3 id="解">解</h3><p><strong>答案</strong><br><img src="/posts/e7ebcfa7/swap.png" alt="swap"></p><p><strong>分析</strong><br>如果 S 为 0 且 I1 为 1，则 O1 为 1，若 I1 为 0，则 O1 为 0。显然，这需要一个与门来实现。<br><img src="/posts/e7ebcfa7/swap1.png" alt="swap1"></p><p>对于 I2 与 O2，是与前者一样的逻辑<br><img src="/posts/e7ebcfa7/swap2.png" alt="swap2"></p><p>如果 S 为 1，则 I1 与 I2 的值交换再赋给 O1 与 O2。对于 I1 而言，首先必须获取其值，然后传递给 O2。由于 S 是 1，则让 S 和 I1 通过与门。考虑到 I2 到 O2 和 I1 到 O2 不会同时为 1，则将两个与门的输出用一个或门连接，再输出到 O2 即可。<br><img src="/posts/e7ebcfa7/swap3.png" alt="swap3"><br><img src="/posts/e7ebcfa7/swap4.png" alt="swap4"></p><p>到 O1 的线路如法炮制即可。</p><div class="note warning">            <p>在打包成模块时，注意按要求调整 S, I1, I2, O1, O2 的位置。<br>注意按要求命名。</p>          </div><h1 id="Logisim-组合电路">Logisim 组合电路</h1><h2 id="子电路">子电路</h2><h3 id="子电路使用流程">子电路使用流程</h3><ol><li class="lvl-3"><p>创建子电路：通过 Project 栏下的 Add Circuit；</p></li><li class="lvl-3"><p>添加子电路内容；</p></li><li class="lvl-3"><p>设置外观；</p></li><li class="lvl-3"><p>引用。</p></li></ol><p>譬如 Swap 电路，若将其封装成子电路，则可以设计出双重交换电路 2Swap。</p><p><img src="/posts/e7ebcfa7/2swap.png" alt="2swap"><br><img src="/posts/e7ebcfa7/2swap1.png" alt="2swap1"><br><img src="/posts/e7ebcfa7/2swap2.png" alt="2swap2"></p><h2 id="Wire-Bundle（线束）">Wire Bundle（线束）</h2><p><img src="/posts/e7ebcfa7/wires.png" alt="wires">​对于一个完整且正确的电路，是以深绿色，浅绿色，黑色接线构成，绿色接线可以通过深浅直接判断出取值，而黑色接线，并不能直接反映出取值，这里建议大家使用 Wiring 库中的 Probe 元器件，可以对多位数据实时显示监控。</p><p><a id="analyze"></a></p><h2 id="利用-Logisim-进行组合逻辑分析">利用 Logisim 进行组合逻辑分析</h2><p>​Logisim 中具有逻辑分析的功能，可以实现组合电路，真值表，布尔表达式三者间的两两转换。<br>​打开组合逻辑分析模块的方式：</p><ol><li class="lvl-3"><p>Window 栏目下的 Combinational Analysis;</p></li><li class="lvl-3"><p>Project 栏目下的 Analyze Circuit;</p></li></ol><p>​组合逻辑分析模块，可根据逻辑表达式得到相应的真值表。我们也可以通过输入真值表，再产生相应的表达式，或者产生相应的电路。其中真值表的选值有：0，1，x（浮动）。<br><img src="/posts/e7ebcfa7/analysis.png" alt="analysis"></p><p>并且在生成电路时，我们也可以勾选下列生成电路的附加约束：</p><ul class="lvl-0"><li class="lvl-2"><p>Use Two-Input Gates Only 只使用二输入门电路；<br><img src="/posts/e7ebcfa7/2-input.png" alt="2-input"></p></li><li class="lvl-2"><p>Use NAND Gates Only 只使用与非门；<br><img src="/posts/e7ebcfa7/nand.png" alt="nand"></p></li></ul><h2 id="排序电路（4bit-sort）">排序电路（4bit_sort）</h2><p>在前面的学习过程中，我们搭建了一个 1 位的 swap 电路。现在需要我们使用之前的 1 位 swap 电路来搭建一个 4 位 4 输入的排序电路。</p><h3 id="要求">要求</h3><p>先使用 1 位的 swap 搭建 4 位的 swap，再使用 4 位的 swap 模块和 Logisim 内置的 comparator 元件搭建排序电路（请不要使用 Plexers 类元件）。</p><ul class="lvl-0"><li class="lvl-2"><p>功能描述: 该电路具有 4 个 4 位的二进制数字作为输入和 4 个 4 位的二进制数字作为输出。它的功能是，将 4 个输入的二进制数字进行排序，从上往下数第一个输出端口输出的是 4 个数字中最小的，第二个输出端口输出的是第二小的，以此类推。</p></li><li class="lvl-2"><p>输入： A, B, C, D (4 bit)</p></li><li class="lvl-2"><p>输出： #1, #2, #3, #4 (4 bit)（#1 对应第一个输出端口，以此类推）</p></li><li class="lvl-2"><p>文件内 1 位 swap 模块名：<code>1bit_swap</code></p></li><li class="lvl-2"><p>文件内 4 位 swap 模块名：<code>4bit_swap</code></p></li><li class="lvl-2"><p>文件内排序电路模块名：<code>4bit_sort</code></p></li><li class="lvl-2"><p>Hint: 所有的二进制数字均看做是无符号的。</p></li></ul><h3 id="解-2">解</h3><p>1 位 swap 电路可以参考<a href="#swap">这里</a>。<br>要构建 4 位 swap 电路，其实就是把 4 bit 输入拆分成四个 1 bit 输入，然后分别交给 1 位 swap 电路，再将四个 1 bit 输出连接起来即可。拆分，也就是使用 Splitter 元件，交换后再用 Splitter 连接起来。有关 Splitter 您可参考<a href="#splitter">这里</a>。</p><p><img src="/posts/e7ebcfa7/4bit_swap.png" alt="4bit_swap"></p><div class="warning"><p><strong>注意</strong><br>图中已封装好的模块是 1 位 swap 模块 <code>1bit_swap</code>。</p></div><div class="note info">            <p>您可使用 Tunnel 元件简化电路。关于 Tunnel 元件您可参考<a href="#tunnel">这里</a>。</p>          </div><p>如何实现排序呢？我们可以使用<a href="https://www.runoob.com/w3cnote/bubble-sort.html">冒泡排序（Bubble Sort）</a>来完成。对于 A, B, C, D 四个输入，我们可以先比较 A 和 B 的大小，由于要求从小到大输出，那么如果 A &gt; B，则交换 A 和 B，然后比较 A 和 C，如果 A &gt; C，则交换 A 和 C，以此类推，直到比较完所有四个输入。每个输入都会与另三各完成一次比较，从而得到四者的顺序。此处我们可以充分利用 Tunnel 元件，将一次比较的结果传递给下次比较的输入。</p><p><img src="/posts/e7ebcfa7/4bit_sort.png" alt="4bit_sort"></p><div class="warning"><p><strong>注意</strong><br>图中已封装好的模块是 4 位 swap 模块 <code>4bit_swap</code>。</p></div><p>每轮比较，若结果为大于，则 Comparator 输出 1，该信号作为使能信号激活 <code>4bit_swap</code> 模块，将输入的二者交换。完成后，其结果用新的 Tunnel 传递给之后的比较轮次。</p><hr><h1 id="Logisim-时序电路">Logisim 时序电路</h1><h2 id="SR-锁存器（SR-Latch）">SR 锁存器（SR Latch）</h2><div class="note warning">            <p>部分内容选自<a href="https://zhuanlan.zhihu.com/p/1938209046684505714">知乎</a>。</p>          </div><p>我们先来讲解一种简单的电路——SR 锁存器（SR latch），它由两个交叉耦合的或非门（或者，等价地，两个反置输入的与非门）组成，整个电路的状态可以由 S（Set）和 R（Reset）输入来决定，对应得到两个相反的输出 Q 和 ~Q，它的真值表如下：</p><p><img src="/posts/e7ebcfa7/SR1.jpg" alt="SR1"></p><p>一种电路如下：<br><img src="/posts/e7ebcfa7/NOR-SR.png" alt="NOR-SR"></p><div class="tips"><p>Q 为 1 而 ~Q 为 0 时被称为锁存器的 1 状态，Q 为 0 而 ~Q 为 1 时被称为锁存器的 0 状态。</p></div><p>其中 S<sub>D</sub> 和 R<sub>D</sub> 为是电路输入的两个端口，Q<sup>n</sup> 表示电路当前的输出，Q<sup>n+1</sup> 表示电路下一个状态的输出。由真值表可以看出，这个电路的输出不仅和当前输入有关，也和上一次的输出有关。<br>观察它的功能一栏，可以看到，通过改变 S<sub>D</sub> 和 R<sub>D</sub> 为合适的值，我们可以改变电路的输出，而当 S<sub>D</sub> 和 R<sub>D</sub> 为均为 0 时，电路会一直保持原来的输出不变，这看上去很像 U 盘之类的设备（通电时能够修改存储的内容，断电时保持内容不变）。事实上，通过配合合适的外部电路，我们就可以使用这个电路来存储整个电路的状态，从而搭建起更复杂的时序电路。</p><div class="note info">            <p>简单来说，初始情况下 S 和 R 均为 0，按下 S 键，锁存器将进入 1 状态(Set)。此时，无论 S 如何变化，锁存器的输出都将不变。因为锁存器已经被设置成 1 了。再按下 R 键，锁存器重置（Reset），输出变为 0。无论 R 如何变化，锁存器的输出都将不变。因为锁存器已经被重置了。0 重置 仍然是 0。</p>          </div><p>由于复位和置位都是输入端为 1 才发生，故这种 SR 锁存器叫做<ins>高电平有效的SR锁存器</ins>。</p><p>还有一种<ins>低电平有效的SR锁存器</ins>，它的输入端 S 和 R 均为低电平有效。真值表如下：</p><p><img src="/posts/e7ebcfa7/SR2.jpg" alt="SR2"></p><p>它的电路如下：</p><p><img src="/posts/e7ebcfa7/NAND-SR.png" alt="NAND-SR"></p><h2 id="D-锁存器（D-Latch）">D 锁存器（D Latch）</h2><p>D 锁存器是最常用于在数字系统中存储数据的逻辑电路。它基于 SR 锁存器，但没有“未定义”或“无效”状态问题。</p><p><img src="/posts/e7ebcfa7/D_latch.png" alt="D_latch"></p><div class="warning"><p><strong>注意</strong><br>图中封装的电路是<ins>高电平有效的SR锁存器</ins>。</p></div><p>D 锁存器有两个输入 D 和 E，其中 E 是使能信号。当 E 为 1 时，D 锁存器将 D 输入的值存储在 Q 中，随着 D 变化而变化。当 E 为 0 时，D 锁存器保持当前的 Q 值不变。即锁存 D 输入的值。</p><div class="note info">            <p>E 也可以看作是 CLK 时钟信号。此时 D 锁存器将<ins>时间</ins>输入和<ins>数据</ins>输入明确的分隔开，而 SR 锁存器是没有区分的。<br>当 CLK 为 1 时，D 锁存器是透明的（transparent），数据 D 通过 D 锁存器流向 Q。当 CLK 为 0 时，D 锁存器是不透明的（opaque），其阻塞新数据流向 Q，Q 保持原值不变。</p>          </div><h2 id="D-触发器（D-Flip-Flop）">D 触发器（D Flip-Flop）</h2><p>D 触发器由反相时钟控制的两个 D 锁存器组成。分别为主锁存器（Master）和从锁存器（Slave）。<br>CLK 为 0 时，主锁存器透明，从锁存器不透明，D 流向从锁存器但无法流入，保持在二者连线处。CLK 为 1 时，主锁存器不透明，从锁存器透明，数据流向 Q，但新的输入无法流入主锁存器。<br>也就是说，D 触发器只会在时钟上升沿将 D 复制到 Q，在其他时间段保持原来的状态。</p><p><img src="/posts/e7ebcfa7/D_FF.png" alt="D_FF"></p><h2 id="有限状态机（FSM）">有限状态机（FSM）</h2><h3 id="有限状态机的定义和行为">有限状态机的定义和行为</h3><h4 id="有限状态机的构成和基本性质">有限状态机的构成和基本性质</h4><p>有限状态机（Finite State Machine，FSM）又称有限自动状态机，它拥有有限数量的状态，每个状态代表不同的意义，每个状态可以切换到 零-多 个状态。任意时刻状态机有且只能处在一个状态。</p><div class="note info">            <p><strong>数学定义</strong><br>构成一个有限状态机的六元组为：状态集合，输入集合，输出集合，状态转移函数，输出函数，初始状态。给定以上六个集合，函数或元素，就可以确定一个有限状态机。</p>          </div><p>据此，有限状态机具有以下特征：</p><ul class="lvl-0"><li class="lvl-2"><p>在任何时间点，状态、输入、输出均为<ins>给定的有限种情况之一</ins>。</p></li><li class="lvl-2"><p>对于一对确定的当前状态和输入，只有一个<ins>固定且唯一</ins>的次态（下一个周期的状态）。</p></li><li class="lvl-2"><p>对于一对确定的当前状态和输入，只有一种<ins>固定且唯一</ins>的输出情况。</p></li></ul><h4 id="有限状态机的时序行为">有限状态机的时序行为</h4><p>状态转移行为可以描述成如下过程：</p><ul class="lvl-0"><li class="lvl-2"><p>当第 0 周期开始，状态设定为 state<sub>0</sub>。</p></li><li class="lvl-2"><p>第 n 周期结束的瞬间，记此时刻输入为 input<sub>n</sub>。</p></li><li class="lvl-2"><p>每当第 n 周期结束，第 n + 1 周期开始时，状态变为状态转移函数给出的次态：state<sub>n+1</sub> = F<sub>next</sub>(state<sub>n</sub>, input<sub>n</sub>)。</p></li></ul><h3 id="Moore-和-Mealy-状态机的区别">Moore 和 Mealy 状态机的区别</h3><p>区分状态机类型时：当<ins>输出函数的结果会随 input 变化而改变时</ins>，该状态机为 <ins>Mealy 机</ins>，<ins>否则为 Moore 机</ins>。</p><p><img src="/posts/e7ebcfa7/FSM.png" alt="FSM"></p><h2 id="2n-mod-5">2<sup>n</sup> mod 5</h2><h3 id="要求-2">要求</h3><p>使用 Logisim 搭建电路，该电路串行输入一个二进制无符号数 B（先从高位输入，每输入一个数字就相当于之前输入的数左移一位再加上当前输入的数字），输出 “2 的 B 次幂” 模 5 的余数的电路并提交。</p><ul class="lvl-0"><li class="lvl-2"><p>输入： In（1bit 串行输入）</p></li><li class="lvl-2"><p>输出：S<sub>0</sub>, S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>, S<sub>4</sub> （独热编码，S<sub>x</sub> 为 1 时表示 2<sup>In</sup> ≡ x (mod 5)）</p></li><li class="lvl-2"><p>文件内模块名: mod5</p></li><li class="lvl-2"><p>状态机类型: Mealy 型有限状态机</p></li><li class="lvl-2"><p>注意：切勿使用内置算术器件（如加法器、除法器等）！请搭建有限状态机！</p></li><li class="lvl-2"><p>样例：输入输出样例中每一行表示相邻上升沿之间的<ins>开区间时间内</ins>的输入和期望输出。<br><img src="/posts/e7ebcfa7/mod5_example.png" alt="mod5_example"></p></li></ul><h3 id="解-3">解</h3><p>题目要求使用有限状态机来搭建，且由于输入和输出有关，是 Mealy 型状态机。<br>首先要确定状态集合。2 的幂次方模 5 所产生的余数其实只有 1 到 4，也就是说只有四种状态。我们可以用 2 位的二进制数来表示状态：</p><table><thead><tr><th>状态</th><th>余数</th></tr></thead><tbody><tr><td>00</td><td>0</td></tr><tr><td>01</td><td>1</td></tr><tr><td>10</td><td>2</td></tr><tr><td>11</td><td>3</td></tr></tbody></table><p>不难发现，1 % 5 = 1, 2 % 5 = 2, 4 % 5 = 4, 8 % 5 = 3, 16 % 5 = 1……即余数以 4 为周期进行循环。若把被除数写成二进制形式，并观察其末二位，则会发现有这样的规律：</p><table><thead><tr><th>余数</th><th>状态</th><th>末二位</th><th>被除数</th></tr></thead><tbody><tr><td>1</td><td>00</td><td>00</td><td>2<sup>0</sup></td></tr><tr><td>2</td><td>01</td><td>01</td><td>2<sup>1</sup></td></tr><tr><td>4</td><td>11</td><td>10</td><td>2<sup>2</sup></td></tr><tr><td>3</td><td>10</td><td>11</td><td>2<sup>3</sup></td></tr></tbody></table><p>现在，要改变状态，我们会进行一次输入，考察这次输入引起的变化：末二位左移一次，输入值填补在低位。输入只有 1 和 0 两种情况，而现在状态有 4 种，因此我们可以枚举出共计 8 种可能的情况：</p><div class="warning"><p>接下来，现在状态的第一位称为 ST1，第二位为 ST2；次态的第一位称为 ST1’，第二位为 ST2’；输入称为 IN；余数称为 S0 到 S4。</p></div><p>状态转移表如下：</p><table><thead><tr><th>ST1</th><th>ST2</th><th>IN</th><th>ST1’</th><th>ST2’</th><th>S0</th><th>S1</th><th>S2</th><th>S3</th><th>S4</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><div class="tips"><p>可以看出 S0 恒为 0。</p></div><p>根据 Mealy 型状态机的结构图，我们需要构建三个部分：状态转移逻辑、输出逻辑和寄存器。其顶层结构如下：<br><img src="/posts/e7ebcfa7/mod5.png" alt="mod5"></p><p>寄存器保存的是<ins>现态</ins>。在上升沿以外的时间段，可以把整个状态机的行为拆分成两步：</p><ol><li class="lvl-3"><p>现态从 Q 流向状态转移逻辑 <code>Trans</code>，和 In 一起决定次态的值。但是由于时间在上升沿以外，次态滞留在寄存器外，无法改变其值。</p></li><li class="lvl-3"><p>现态从 Q 流向输出逻辑 <code>Out</code>，和 In 一起决定输出的值。</p></li></ol><p>当时间来到上升沿，滞留的次态值进入寄存器，完成状态的转移。然后在下一个上升沿到来前，重复上述的 1 和 2 步。</p><div class="tips"><p>这正好满足了样例说的“每一行表示相邻上升沿之间的<ins>开区间时间内</ins>的输入和期望输出”，因为输出这一步骤就是在两个上升沿之间完成的。</p></div><p>状态转移逻辑和输出逻辑的实现，最简单的步骤就是根据状态转移表，使用 Logisim 的 <a href="#analyze">Analyze Circuit</a> 功能来自动生成即可。</p><h2 id="斐波那契数列">斐波那契数列</h2><h3 id="要求-3">要求</h3><p>使用 Logisim 搭建一个根据输入序号 x 计算对应序号斐波那契数 F<sub>x</sub> 的电路并提交。</p><ul class="lvl-0"><li class="lvl-2"><p>F<sub>0</sub> = 0, F<sub>1</sub> = 1, F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub> (n ≥ 2)</p></li><li class="lvl-2"><p>输入：N (3bit)</p></li><li class="lvl-2"><p>输出：Nth(4bit)</p></li><li class="lvl-2"><p>文件内模块名: main</p></li><li class="lvl-2"><p>测试要求：每次给定一个固定输入保持不变，电路在 64 个周期内计算出结果并稳定输出，在结果未计算出之前输出端口输出 0。</p></li></ul><h3 id="解-4">解</h3><h4 id="计数逻辑">计数逻辑</h4><p>要知道第 x 号斐波那契数的值，我们可以从 0 号和 1 号开始，依次计算斐波那契数，直至第 x 号时停止并输出。那么要算多少次呢？如果我们以 0 号和 1 号开始，每一个时钟周期计算一次的话，那么第一个周期算出 2 号，第二个周期算出 3 号……并且，还需要花掉一个上升沿去<ins>初始化</ins>寄存器的值，计数器达到需求时，又需等下一个上升沿才能输出结果。若要求 2 号斐波那契数，计数逻辑到第 3 个上升沿时就会发出停止运算并输出的信号。而第 1 个上升沿被用来初始化，第 2 个上升沿算出 2 号，到第 3 个上升沿算出 3 号，输出的结果就是 3 号斐波那契数了，并不符合我们的需求。因此我们可以往前推一位，以 -1 号和 0 号开始。</p><div class="tips"><p>F<sub>-1</sub> = 1, F<sub>0</sub> = 0。</p></div><p>这样，第 x 号斐波那契数需要 x 个时钟周期才能算出。换言之，当第 x 个时钟周期结束时，已经算出了第 x 号斐波那契数。而下一个时钟周期的上升沿，必须停止计次，然后输出数字，否则会多算一次。<br>控制运算次数的逻辑可以使用一个计数器（Counter）和一个比较器（Comparator）来实现。计数器从 0 开始，每到一个上升沿加 1。也就是说 x 个时钟周期结束时，计数器的值为 x，在下一个上升沿到来时，传递一个信号（output_signal）给运算斐波那契数的逻辑，令其做完运算后立刻输出结果，并且将结果锁定在寄存器中。每个上升沿，用比较器比较计数器的值和 N 的值，若计数器的值小于等于 N，则 output_signal 为 0，否则为 1。</p><div class="tips"><p>由于输入格式是 3bit，若计数器的位宽也设置成 3bit，则会在边界情况下失效。比如输入为 111，第七个周期时，计数器的值为 111。在下一个上升沿到来时，计数器的值要么回到 000，要么保持 111，始终无法让其大于输入值，output_signal 始终为 0。因此，需要设置计数器的位宽比输入值多 1 位。然后使用 Bit Extender 把输入扩展到 4bit。</p></div><div class="warning"><p>比较器的 Numeric Type 参数必须设定为 <code>Unsigned</code> 即无符号数比较。若为 <code>2's Complement</code> 即补码比较，则 output_signal 会逆转。</p></div><p><img src="/posts/e7ebcfa7/time_control.png" alt="time_control"></p><h4 id="运算逻辑">运算逻辑</h4><p>回到运算斐波那契数的逻辑。由于每个斐波那契数的值只与其前两个值（prev, cur）有关，每次算出新值 = prev + cur，可以用 cur 覆盖 prev，然后用新值覆盖 cur，以此类推就可以持续计算下去。这些步骤在上升沿完成。核心逻辑如下：</p><p><img src="/posts/e7ebcfa7/fib_cal.png" alt="fib_cal"></p><p>在上升沿以外的时刻，Cur 值流向 Prev 寄存器，但无法进入，滞留在线路中。同时 Prev 和 Cur 值在 Adder 中相加，得出下一个斐波那契数，流向 Cur 寄存器，也无法进入，滞留在线路中。<br>在上升沿，Cur 值进入 Prev 寄存器，并覆盖原有值，同时新的斐波那契数进入 Cur 寄存器，覆盖掉原有值。也就是说，最新的斐波那契数保存在 Cur 寄存器中，并且是每个上升沿到来时更新一次。</p><p>如何初始化两个寄存器呢？由于 F<sub>-1</sub> = 1, F<sub>0</sub> = 0，因此我们要把 Prev 寄存器的值设为 1，而 Cur 寄存器默认为零。我们用一个 Maximum Value 为 <code>1</code> 的<ins>计数器</ins>来实现。利用到计数器有一个 Carry 输出，当计数器达到最大值时，Carry 输出为 1，否则为 0。再搭配一个二选一 MUX，0 号输入为想要的初始值，1 号输入则是 Cur 隧道。这样就实现了如下效果：</p><ul class="lvl-0"><li class="lvl-2"><p>第一个上升沿到来前，MUX 选择初始值，但无法进入 Prev 寄存器，滞留在线路中。</p></li><li class="lvl-2"><p>第一个上升沿到来时，初始值进入 Prev 寄存器，实现初始化。MUX 选择 Cur 隧道值。</p></li></ul><p><img src="/posts/e7ebcfa7/init1.png" alt="init1"><br><img src="/posts/e7ebcfa7/init2.png" alt="init2"></p><h4 id="锁定斐波那契数">锁定斐波那契数</h4><p>很简单，传入 output_signal，当其为 1 时表示已经算出了所求的，让其通过非门，然后传给两个寄存器的使能信号端口即可。</p><h4 id="稳定输出">稳定输出</h4><p>在找到要求的斐波那契数前，输出 Nth 要求保持为 0。可以用一个二选一 MUX，0 号输入为 0，1 号输入为 Cur 隧道值。传入 output_signal，当其为 1 时自然就输出了 Cur 寄存器中保存的值。</p><p>整个运算逻辑如下：<br><img src="/posts/e7ebcfa7/fib_cal2.png" alt="fib_cal2"></p><p>顶层电路如下：<br><img src="/posts/e7ebcfa7/fibonacci.png" alt="fibonacci"></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Tunnel 需要增加标签以区分不同的数据。并且每个标签只允许有一个输入，输出的数量不做限制。但是在有较多 Tunnel 部件的时候，要特别留意标签的名字，防止出现混乱。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>将输入数据的最高位视为符号位，扩展的数值全为符号位的值。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>优先级：<code>&amp;</code> &gt; <code>^</code> &gt; <code>|</code> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>Logisim 画布上，高亮代表此线路的真值为 1，不高亮代表此线路的真值为 0。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/CO-Pre/">CO Pre</category>
      
      <category domain="https://samuflore.top/tags/Logisim/">Logisim</category>
      
      
      <comments>https://samuflore.top/posts/e7ebcfa7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>加密文章测试</title>
      <link>https://samuflore.top/posts/7e709353/</link>
      <guid>https://samuflore.top/posts/7e709353/</guid>
      <pubDate>Thu, 14 Aug 2025 04:59:28 GMT</pubDate>
      
      <description>此處已加密</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密碼錯誤，請重試。" data-whm="哈希錯誤，您可繼續查看之。">  <script id="hbeData" type="hbeData" data-hmacdigest="e51da5b86cbbc76e46e127f10949edd09b362ac81c170ab7e01736f04b5aa8c8">e55adbd63f533766c9f21930da64422ba895a6bdbe5300133465591509dc5c39</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">此處輸入密碼</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      
      
      <comments>https://samuflore.top/posts/7e709353/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CO Pre]原码、反码与补码</title>
      <link>https://samuflore.top/posts/908cc5fb/</link>
      <guid>https://samuflore.top/posts/908cc5fb/</guid>
      <pubDate>Wed, 13 Aug 2025 16:10:54 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;计组 Pre 开始了，但是我把上学期学的内容都忘了（&lt;br&gt;
所以先从&lt;strong&gt;数制&lt;/strong&gt;开始吧。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>计组 Pre 开始了，但是我把上学期学的内容都忘了（<br>所以先从<strong>数制</strong>开始吧。</p><span id="more"></span><hr><h1 id="机器数">机器数</h1><p>一个数在计算机中的二进制表示形式被称为<strong>机器数</strong>。<br>机器数是有符号的，计算机中将机器数的最高位（最左边）称为符号位，用以表示符号。0 表示正数，1 表示负数。</p><hr><h1 id="真值">真值</h1><p>机器数的<strong>真值</strong>是指该机器数对应的实际数值。<br>对于一个有符号数，它的机器数未必等于它本身。<br>譬如十进制数 -7，它的机器数为 10000111，但 10000111 如果当作二进制表示，对应的十进制数是 135。故 -7 的机器数的真值应该是 00000111。</p><hr><h1 id="原码">原码</h1><p><strong>原码</strong>就是<strong>符号位</strong>和<strong>真值</strong>的组合。即用最高位表示符号，其余位表示数字大小。</p><ul class="lvl-0"><li class="lvl-2"><p>[+1]原码：0000 0001</p></li><li class="lvl-2"><p>[-1]原码：1000 0001</p></li></ul><hr><h1 id="反码">反码</h1><p><strong>反码</strong>的表示方法如下：</p><ul class="lvl-0"><li class="lvl-2"><p>正数的反码是其原码本身。</p></li><li class="lvl-2"><p>负数的反码将其原码的符号位不变，其余各位<strong>按位取反</strong>。<br>比如：</p></li><li class="lvl-2"><p>[+1]反码：0000 0001</p></li><li class="lvl-2"><p>[-1]反码：1111 1110</p></li></ul><hr><h1 id="补码">补码</h1><p><strong>补码</strong>的表示方法如下：</p><ul class="lvl-0"><li class="lvl-2"><p>正数的补码是其原码本身。</p></li><li class="lvl-2"><p>负数的补码是其反码加 1。</p></li></ul><div class="warning"><p><strong>注意</strong><br>加 1 指的是二进制加法，注意进位。</p></div><p>比如：</p><ul class="lvl-0"><li class="lvl-2"><p>[+1]补码：0000 0001</p></li><li class="lvl-2"><p>[-1]补码：1111 1111</p></li></ul><hr><h1 id="为什么要这么复杂？">为什么要这么复杂？</h1><p>数字存储在计算机中，是需要用来运算的。根据四则运算的性质，人们只需要解决<strong>加法</strong>的运算方法就可以了。<br>可是，对于人脑而言，进行有符号数的加法是很简单的，因为大家都能一眼看出数字的符号，再根据符号决定运算。对于计算机而言，倘若要模拟人的运算，就必须拥有识别符号的能力，这无疑是增加了复杂度。<br>于是聪明的人们就想到了把符号位也纳入运算中。</p><h2 id="原码运算">原码运算</h2><p>大家都知道，1 - 1 = 0。<br>如果使用原码运算，那么 1 - 1 = 1 + (-1) = 0000 0001 + 1000 0001 = 1000 0010。<br>按照原码的定义，这显然等于 -2。因此，原码是不行的。</p><h2 id="反码运算">反码运算</h2><p>仍然是 1 - 1 = 0 这个问题。<br>1 - 1 = 1 + (-1) = 0000 0001[反码] + 1111 1110[反码] = 1111 1111[反码] = 1000 0000[原码] = -0。<br>-0，人们都知道 0 和 -0 是一样的，可如果使用反码运算，-0 和 0 就成了两个数。如果用 -0 和 0 分别进行一些运算：</p><ul class="lvl-0"><li class="lvl-2"><p>-0 + 1 = 1111 1111[反码] + 0000 0001[反码] = 1 0000 0000[反码]<br>对于反码的加法运算，倘若位数溢出，则需要把溢出的位数依次补到末尾，称之为<strong>循环进位</strong>。<br>故 1 0000 0000[反码] = 0000 0001[反码] = 0000 0001[原码] = 1。</p></li><li class="lvl-2"><p>0 + 1 = 0000 0000[反码] + 0000 0001[反码] = 0000 0001[反码] = 0000 0001[原码] = 1。</p></li></ul><p>可见，反码的运算是繁琐而有歧义的，问题就出在 0 和 -0 的区分上。</p><h2 id="补码运算">补码运算</h2><p>1 - 1 = 1 + (-1) = 0000 0001[补码] + 1111 1111[补码] = 1 0000 0000[补码]<br>补码运算中，没有循环进位，溢出位舍弃。<br>故 1 0000 0000[补码] = 0000 0000[补码] = 0000 0000[原码] = 0。<br>补码中是没有 0 和 -0 的区分的：0 就是 0000 0000，而 1000 0000 则被用来表示 -128。</p><div class="tips"><p><strong>为什么是 -128？</strong><br>-1 + (-127) = 1111 1111 + 1000 0001 = 1000 0000 = -128。</p></div><p>补码是可以解决问题的。</p><hr><p>关于原码、反码和补码的数学原理探讨，您可参考<a href="https://zhuanlan.zhihu.com/p/118432554">这篇文章</a>。</p>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/CO-Pre/">CO Pre</category>
      
      <category domain="https://samuflore.top/tags/Sign-Magnitude/">Sign-Magnitude</category>
      
      <category domain="https://samuflore.top/tags/Ones-Complement/">Ones&#39; Complement</category>
      
      <category domain="https://samuflore.top/tags/Two-s-Complement/">Two&#39;s Complement</category>
      
      
      <comments>https://samuflore.top/posts/908cc5fb/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Blog 9：[Hexo]Hexo NexT 自定义字体</title>
      <link>https://samuflore.top/posts/ec5f1055/</link>
      <guid>https://samuflore.top/posts/ec5f1055/</guid>
      <pubDate>Sat, 09 Aug 2025 12:37:06 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;三种方法为 Hexo NexT 主题自定义字体。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天我才发现我的 NexT 主题是过时已久的 7.x 版本。尝试更新到 8.x，发现变了许多，便决定继续用旧版本了。&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>三种方法为 Hexo NexT 主题自定义字体。</p><blockquote><p>今天我才发现我的 NexT 主题是过时已久的 7.x 版本。尝试更新到 8.x，发现变了许多，便决定继续用旧版本了。</p></blockquote><span id="more"></span><hr><h1 id="从-Google-Fonts-引用">从 Google Fonts 引用</h1><p>在<strong>站点配置文件</strong> <code>_config.yml</code> 中，搜索 <code>font</code> 字段，您将看到以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br></pre></td></tr></table></figure><p><code>host</code> 字段处指定字体的来源，默认使用 Google Fonts。</p><div class="tips"><p><s>由于不可抗力</s>，您可使用 Google Fonts 的镜像站来确保访问速度。例如 <code>https://fonts.loli.net</code>。</p></div><p>引用的字体可以分派到五个部分：<strong>全局默认</strong>、<strong>网站标题</strong>、<strong>博文标题</strong>、<strong>博文正文</strong>、<strong>内嵌代码和代码块</strong>。</p><div class="warning"><p>由于 <code>Yaml</code> 语法限制，此处您每个字段只能指定一种字体。</p></div><p><code>family</code> 字段指定字体的名称。譬如 <code>Noto Serif SC</code>（思源宋体简体中文）。<br>但是，如果您需要中西文分两种字体，这显然是无法满足要求的。</p><hr><h1 id="修改-Stylus-样式文件">修改 Stylus 样式文件</h1><div class="warning"><p>下文中将出现两个名为 <code>base.styl</code> 的不同文件，敬请注意区分。</p></div><p>首先我们必须知道是什么文件在控制 NexT 主题各元素的样式。<br>在 <code>themes\next\source\css\_common\scaffolding\base.styl</code> 文件中，我们可以看到类似这样的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="variable">$font</span>-family-headings;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这是用来指定 <code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code> 标签的样式的。于是我们就知道这是用来控制 NexT 主题样式的文件。注意到，这里有一个 <code>font-family</code> 字段。Stylus 是为 Node.js 构建的 CSS 预处理器，因此它具有 CSS 的性质。所以这里可以指定多种字体。我们只需在 <code>$font-family-headings</code> 前加西文字体的指定即可，比如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Times New Roman, <span class="variable">$font</span>-family-headings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就为西文指定了 Times New Roman。</p><div class="tips"><p>先指定西文字体，再指定中文字体，以确保中文字体的拉丁字符不会替换西文字体的字形。</p></div><p>可是什么是 <code>$font-family-headings</code> 呢？<br>打开 <code>themes\next\source\css\_variables\base.styl</code> 文件，我们可以看到：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Font families.</span></span><br><span class="line"><span class="variable">$font</span>-family-chinese      = <span class="string">&quot;PingFang SC&quot;</span>, <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-base         = <span class="variable">$font</span>-family-chinese, sans-serif;</span><br><span class="line"><span class="variable">$font</span>-family-base         = <span class="built_in">get_font_family</span>(<span class="string">&#x27;global&#x27;</span>), <span class="variable">$font</span>-family-chinese, sans-serif <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;global&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-logo         = <span class="variable">$font</span>-family-base;</span><br><span class="line"><span class="variable">$font</span>-family-logo         = <span class="built_in">get_font_family</span>(<span class="string">&#x27;title&#x27;</span>), <span class="variable">$font</span>-family-base <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-headings     = <span class="variable">$font</span>-family-base;</span><br><span class="line"><span class="variable">$font</span>-family-headings     = <span class="built_in">get_font_family</span>(<span class="string">&#x27;headings&#x27;</span>), <span class="variable">$font</span>-family-base <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;headings&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-posts        = <span class="variable">$font</span>-family-base;</span><br><span class="line"><span class="variable">$font</span>-family-posts        = <span class="built_in">get_font_family</span>(<span class="string">&#x27;posts&#x27;</span>), <span class="variable">$font</span>-family-base <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;posts&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-monospace    = consolas, Menlo, monospace, <span class="variable">$font</span>-family-chinese;</span><br><span class="line"><span class="variable">$font</span>-family-monospace    = <span class="built_in">get_font_family</span>(<span class="string">&#x27;codes&#x27;</span>), consolas, Menlo, monospace, <span class="variable">$font</span>-family-chinese <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;codes&#x27;</span>);</span><br></pre></td></tr></table></figure><p>原来，<code>$font-family-headings</code> 是一个变量，它先获取 <code>_config.yml</code> 中 <code>font</code> 字段的 <code>headings</code> 设置。如果没有，则使用 <code>$font-family-base</code> 作为默认值。后者获取 <code>_config.yml</code> 中 <code>font</code> 字段的 <code>global</code> 设置。如果没有，则缺省为最通用的<strong>苹方</strong>和<strong>微软雅黑</strong>。</p><p>所以，您如果希望正文中的西文字体是 Times New Roman，而中文是 Noto Serif SC，就可以在 <code>_config.yml</code> 中设置 <code>posts</code> 字段字体为 <code>Noto Serif SC</code>，然后在 <ins>控制样式</ins> 的 <code>base.styl</code> 的 <code>body</code> 处指定 <code>font-family</code> 为 <code>Times New Roman, Noto Serif SC</code>。其余也类似。</p><div class="warning"><p>像上述方法在 Stylus 中指定字体时，只填写字体名称的，当浏览网页之设备有该字体时才能正常显示。如果没有，则会显示为默认字体。</p></div><p>如果需要指定的字体在任何设备上都能正常显示，又该如何呢?</p><hr><h1 id="使用-font-face">使用 <code>@font-face</code></h1><h2 id="原始方法">原始方法</h2><p>关于 <code>@font-face</code>，您可参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">这里</a>。<br>它的格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Open Sans&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>:</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&quot;/fonts/OpenSans-Regular-webfont.woff2&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;woff2&quot;</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&quot;/fonts/OpenSans-Regular-webfont.woff&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;woff&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>font-family</code> 字段可以自定义字体的名称方便后续使用。<code>src</code> 字段指定字体文件的路径，既可以是本地路径也可以是网络路径。<code>format</code> 字段指定字体文件的格式，譬如 TTF。简单来说，您通过它可以自定义一个字体以供使用。</p><p>故您可以将一些字体文件上传到云端，然后以相对路径的形式引用，这样就能在任何设备上都能正常显示。在 <code>themes\next\source</code> 目录下新建一个 <code>fonts</code> 文件夹，然后将字体文件放入其中。然后在 <ins>控制样式</ins> 的 <code>base.styl</code> 文件中，在 <code>font-family</code> 字段前加上 <code>@font-face</code>，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Mozilla Headline&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;../fonts/MozillaHeadline-Regular.otf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tips"><p>为什么是 <code>../fonts/</code>？Hexo 博客在编译时，默认会将 <code>source</code> 目录下的所有文件复制到 <code>public</code> 目录下。所有样式会被编译到 <code>public\css</code> 目录下。对于 CSS 文件而言，OTF 文件自然是<strong>上级目录</strong>的 fonts 文件夹下的文件了。</p></div><p>然后再在 <ins>控制样式</ins> 的 <code>base.styl</code> 的 <code>body</code> 处指定 <code>font-family</code> 为 <code>Mozilla Headline, Noto Serif SC</code>。这样，所有设备都会在加载网页时加载 MozillaHeadline-Regular.otf 字体文件，然后应用样式。<br>可是，这是最优解吗？</p><p>2009 年，Web 开放字体格式出现并发展。现在正由万维网联盟的 Web 字体工作小组标准化，以求成为推荐标准。此字体格式不但能够有效利用压缩来减少档案大小，并且不包含加密也不受 DRM（数位著作权管理）限制。WOFF 本质上是包含了基于 sfnt 的字体（如 TrueType、OpenType 或开放字体格式），且这些字体均经过 WOFF 的编码工具压缩，以便嵌入网页中。这个字体格式使用zlib压缩，文件大小一般比 TTF 小 40%<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>如果能用上 WOFF 或 WOFF2 格式，岂不美哉？</p><h2 id="现代方法">现代方法</h2><p>只要能弄到 WOFF 或 WOFF2 格式的字体文件，按上述方法，就能完成速度优化。这里介绍一种从 Google Fonts 下载 WOFF 或 WOFF2 格式字体的方法。</p><p>首先，在 Google Fonts 上搜索您需要的字体。例如 Mozilla Headline。点击 Get Font，然后点击 Get embed code。</p><p><img src="/posts/ec5f1055/%E5%9B%BE%E4%B8%80.png" alt="Get embed code"></p><p>在 import 模式中找到字体的 URL。如下图的 <a href="https://fonts.googleapis.com/css2?family=Mozilla+Headline:wght@200..700&amp;display=swap">https://fonts.googleapis.com/css2?family=Mozilla+Headline:wght@200..700&amp;display=swap</a> 。</p><p><img src="/posts/ec5f1055/%E5%9B%BE%E4%BA%8C.png" alt="Get font URL"></p><p>将 URL 复制到浏览器地址栏，访问。可以得到包含 <code>@font-face</code> 的 CSS 代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* latin-ext */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Mozilla Headline&#x27;</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">200</span> <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">font-stretch</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-display</span>: swap;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(https://fonts.gstatic.com/s/mozillaheadline/v1/QGY4z-UXahmCOps4kyMKGuSA9pYt2_P-w2kFrS88o6cVYTHDYMVmJQ.woff2) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">  unicode-range: U+<span class="number">0100</span>-<span class="number">02</span>BA, U+<span class="number">02</span>BD-<span class="number">02</span>C5, U+<span class="number">02</span>C7-<span class="number">02</span>CC, U+<span class="number">02</span>CE-<span class="number">02</span>D7, U+<span class="number">02</span>DD-<span class="number">02</span>FF, U+<span class="number">0304</span>, U+<span class="number">0308</span>, U+<span class="number">0329</span>, U+<span class="number">1</span>D00-<span class="number">1</span>DBF, U+<span class="number">1</span>E00-<span class="number">1</span>E9F, U+<span class="number">1</span>EF2-<span class="number">1</span>EFF, U+<span class="number">2020</span>, U+<span class="number">20</span>A0-<span class="number">20</span>AB, U+<span class="number">20</span>AD-<span class="number">20</span>C0, U+<span class="number">2113</span>, U+<span class="number">2</span>C60-<span class="number">2</span>C7F, U+A720-A7FF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* latin */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Mozilla Headline&#x27;</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">200</span> <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">font-stretch</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-display</span>: swap;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(https://fonts.gstatic.com/s/mozillaheadline/v1/QGY4z-UXahmCOps4kyMKGuSA9pYt2_P-w2kFrS88o6cVYTHNYMU.woff2) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">  unicode-range: U+<span class="number">0000</span>-<span class="number">00</span>FF, U+<span class="number">0131</span>, U+<span class="number">0152</span>-<span class="number">0153</span>, U+<span class="number">02</span>BB-<span class="number">02</span>BC, U+<span class="number">02</span>C6, U+<span class="number">02</span>DA, U+<span class="number">02</span>DC, U+<span class="number">0304</span>, U+<span class="number">0308</span>, U+<span class="number">0329</span>, U+<span class="number">2000</span>-<span class="number">206</span>F, U+<span class="number">20</span>AC, U+<span class="number">2122</span>, U+<span class="number">2191</span>, U+<span class="number">2193</span>, U+<span class="number">2212</span>, U+<span class="number">2215</span>, U+FEFF, U+FFFD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里已经包含了两个 URL，是将该字体按照不同字符集分成的两个 WOFF2 文件。浏览器访问会自动下载。将下载的文件放到 <code>fonts</code> 文件夹中。然后把以上代码复制到 <ins>控制样式</ins> 的 <code>base.styl</code> 文件中。把 URL 改成相对路径。再在 <code>font-family</code> 字段中指定 <code>Mozilla Headline</code>，即可。</p><div class="success"><p>按照我的理解，直接将此 CSS 代码复制进去就能使用。但是考虑到某些不可抗力，还是建议将字体文件上传到云端，然后以相对路径的形式引用。</p></div><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.cnblogs.com/bianchengsanmei/p/15857883.html">TTF、TOF、WOFF 和 WOFF2 的相关概念</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/Hexo%E6%95%99%E7%A8%8B/">Hexo教程</category>
      
      
      <category domain="https://samuflore.top/tags/Hexo/">Hexo</category>
      
      <category domain="https://samuflore.top/tags/Tutorial/">Tutorial</category>
      
      <category domain="https://samuflore.top/tags/NexT/">NexT</category>
      
      <category domain="https://samuflore.top/tags/Font/">Font</category>
      
      
      <comments>https://samuflore.top/posts/ec5f1055/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Blog 8：[Hexo教程]Hexo之提交搜索引擎收录</title>
      <link>https://samuflore.top/posts/ff51cb4c/</link>
      <guid>https://samuflore.top/posts/ff51cb4c/</guid>
      <pubDate>Mon, 21 Jul 2025 11:14:08 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;利用&lt;code&gt;sitemap.xml&lt;/code&gt;来提交&lt;strong&gt;搜索引擎收录&lt;/strong&gt;，是搜索引擎优化（SEO）的重要一步。本文将介绍如何利用&lt;code&gt;sitemap.xml&lt;/code&gt;来提交&lt;strong&gt;百度&lt;/strong&gt;、&lt;strong&gt;谷歌&lt;/strong&gt;、&lt;strong&gt;必应&lt;/strong&gt;的搜索引擎收录。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>利用<code>sitemap.xml</code>来提交<strong>搜索引擎收录</strong>，是搜索引擎优化（SEO）的重要一步。本文将介绍如何利用<code>sitemap.xml</code>来提交<strong>百度</strong>、<strong>谷歌</strong>、<strong>必应</strong>的搜索引擎收录。</p><span id="more"></span><hr><h1 id="准备">准备</h1><h2 id="何为-Sitemap？">何为 Sitemap？</h2><blockquote><p>Sitemap（站点地图）是一种文件的统称，通常Sitemap（站点地图）可以是txt或者XML格式。通过Sitemap（站点地图）你可以告诉搜索引擎关于你的站点中的网页、视频或者其他文件的相关信息，帮助搜索引擎更好的认识和理解你的站点。格式正确的Sitemap（站点地图）文件会帮助搜索引擎更高效地抓取你的网站。XML格式的站点地图，通常会包含更多的信息，比如你可以通过Sitemap（站点地图）文件告诉搜索引擎你认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。例如，网页上次更新的时间和网页是否有任何备用的语言版本。<br><a href="https://zhuanlan.zhihu.com/p/441973408"><strong>知乎</strong></a></p></blockquote><p>简单来说，Sitemap 使得您可以一次性提交全站的所有 URL 等信息，帮助搜索引擎快速给您的网站建立索引。</p><h2 id="何为搜索引擎优化（SEO）？">何为搜索引擎优化（SEO）？</h2><blockquote><p>SEO（Search EngineOptimization，搜索引擎优化）是一种利用搜索引擎的内在规则，优化网站结构和内容，从而提升网站在搜索引擎结果中的自然排名的方法。<br><a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132"><strong>百度百科</strong></a></p></blockquote><p>搜索引擎收录了无数的网页。当用户搜索时，搜索引擎根据用户的关键字找到所有相关的网页，然后通过一定的算法对这些网页进行排名，将最相关的网页放在搜索结果的前面。搜索引擎优化就是通过一些技术手段，让网站在搜索引擎中排名靠前。<br>那么很显然，您必须首先把整个网站的 URL 都提交给搜索引擎，才能让搜索引擎收录之。进而您再考虑 SEO。</p><h2 id="安装插件">安装插件</h2><p>您需安装<code>hexo-generator-sitemap</code>插件和<code>hexo-generator-baidu-sitemap</code>插件。前者用于生成通用的<code>sitemap.xml</code>，后者用于生成<strong>百度</strong>的<code>baidusitemap.xml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h2 id="修改配置文件">修改配置文件</h2><p>打开<strong>站点配置文件</strong><code>_config.yml</code>，添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动生成sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><h2 id="生成和部署">生成和部署</h2><p>在 Hexo 根目录下，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时，在根目录的<code>public</code>文件夹中，您会发现其中生成了<code>sitemap.xml</code>和<code>baidusitemap.xml</code>两个文件。<br>文件的主体部分大致如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loc</span>&gt;</span>http:/example.com/test/123456/<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>yyyy-mm-dd<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是您需要提交给搜索引擎的 URL 信息：<strong>URL 地址</strong>、<strong>最后更新时间</strong>。</p><h1 id="提交百度">提交百度</h1><h2 id="登录百度站长平台">登录百度站长平台</h2><p>由此进入：<a href="http://zhanzhang.baidu.com/">百度站长平台</a><br>并进入<strong>站点管理</strong>页面：<br><img src="/posts/ff51cb4c/%E7%AB%99%E7%82%B9%E7%AE%A1%E7%90%86.png" alt="站点管理"></p><p><a id="Section"></a></p><h2 id="添加站点并验证">添加站点并验证</h2><p>输入您网站的域名：<br><img src="/posts/ff51cb4c/%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9.png" alt="添加站点"></p><p>在<strong>验证网站</strong>页面，选用<strong>文件验证</strong>方式，并下载指定的验证文件（当前：<code>baidu_verify_codeva-JSNntnC1KX.html</code>）：<br><img src="/posts/ff51cb4c/%E9%AA%8C%E8%AF%81.png" alt="验证"></p><p>将此验证文件放入<code>themes/next/source</code>下，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>等待 GitHub Pages 部署完成（您可在 GitHub 页面查看进度）。然后点击<strong>完成验证</strong>。</p><h2 id="主动推送">主动推送</h2><p>您需安装<code>hexo-baidu-url-submit</code>插件。该插件可在您执行<code>hexo d</code>时自动向<strong>百度</strong>推送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>修改<strong>站点配置文件</strong><code>_config.yml</code>，添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">5</span> <span class="comment">## 提交最新的五个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">http://example.com</span> <span class="comment">## 百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">your_token</span> <span class="comment">## 准入秘钥</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><div class="warning"><p><code>host</code>字段一定要填写<strong>站长平台注册的域名</strong>。<br>要获取<code>token</code>，请点击<strong>普通收录</strong>，点击<strong>API提交</strong>，在<strong>推送接口</strong>一栏可以找到<code>token=********</code>字样。*为您的<code>token</code>。</p></div><div class="warning"><p>请检查<strong>站点配置文件</strong><code>_config.yml</code>中的<code>url</code>字段是否正确。形如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://example.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title.xml</span></span><br></pre></td></tr></table></figure><p><code>url</code>字段必须是<strong>站长平台注册的域名</strong>。</p></div><p>最后，加入新的 deployer：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span> <span class="comment">## 原来的deployer</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">branch:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span> <span class="comment">## 添加这里内容即可</span></span><br></pre></td></tr></table></figure><div class="warning"><p>出现了两个<code>type</code>字段，因此您<strong>必须</strong>在前面添加<code>-</code>字符。</p></div><h2 id="自动推送">自动推送</h2><p>您可令页面被访问时，其 URL 自动推送给百度。修改<strong>主题</strong>目录下的<code>layout/post.swig</code>文件，末尾加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> bp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> curProtocol = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (curProtocol === <span class="string">&#x27;https&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        bp.<span class="property">src</span> = <span class="string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span>;        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        bp.<span class="property">src</span> = <span class="string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    s.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(bp, s);</span></span><br><span class="line"><span class="language-javascript">&#125;)();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Sitemap-提交">Sitemap 提交</h2><div class="tips"><p>百度站长平台貌似已经限制了 Sitemap 提交，暂时未获取提交机会。</p></div><div class="warning"><p>百度似乎无法爬取 GitHub Pages 上的网页，据说需要二次部署至 Coding 上。<strong>待更新</strong></p></div><h1 id="提交谷歌">提交谷歌</h1><h2 id="登录-Google-Search-Console">登录 Google Search Console</h2><p>由此进入：<a href="https://search.google.com/search-console/about">Google Search Console</a><br>点击<strong>立即使用</strong>。</p><h2 id="添加站点并验证-2">添加站点并验证</h2><p><a href="#Section">同上</a>。</p><h2 id="Sitemap-提交-2">Sitemap 提交</h2><p>在<strong>编制索引</strong>下找到<strong>站点地图</strong>，输入您的站点地图网址。例如：<code>http://example.com/sitemap.xml</code>。</p><p>您可以在上方搜索栏输入此网址，让<strong>谷歌</strong>检测您的 Sitemap 是否可以被收录。<br><img src="/posts/ff51cb4c/%E7%BD%91%E5%9D%80%E6%A3%80%E6%9F%A5.png" alt="网址检查"></p><p>点击<strong>测试实际网址</strong></p><p><img src="/posts/ff51cb4c/%E6%88%90%E5%8A%9F.png" alt="成功"></p><div class="success"><p>您应期望看到的结果是：<br><code>是否允许抓取？：是</code><br><code>是否允许编入索引？：是</code></p></div><p>若提交了 Sitemap 但显示<code>无法抓取</code>，则可能是由于 <strong>GSC</strong>的显示 bug，请等待一段时间。</p><div class="danger"><p>据说是这样，目前为止我的 Sitemap 还没有显示成功提交。。。</p></div><h1 id="提交必应">提交必应</h1><h2 id="登录-Bing-Webmaster">登录 Bing Webmaster</h2><p>由此进入：<a href="https://www.bing.com/webmaster/">Bing Webmaster</a><br>可以使用 <strong>Microsoft</strong> 账户登录。</p><h2 id="一键从-GSC-导入名下网站">一键从 GSC 导入名下网站</h2><p>登录您的 <strong>Google</strong> 账户即可。</p><h2 id="或手动添加网站并验证">或手动添加网站并验证</h2><p><a href="#Section">同上</a>。</p><h2 id="Sitemap-提交-3">Sitemap 提交</h2><div class="success"><p><strong>Bing</strong> 办事效率非常高，Sitemap 一下就通过了。</p></div>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/Hexo%E6%95%99%E7%A8%8B/">Hexo教程</category>
      
      
      <category domain="https://samuflore.top/tags/Hexo/">Hexo</category>
      
      <category domain="https://samuflore.top/tags/SEO/">SEO</category>
      
      <category domain="https://samuflore.top/tags/Baidu/">Baidu</category>
      
      <category domain="https://samuflore.top/tags/Google/">Google</category>
      
      <category domain="https://samuflore.top/tags/Bing/">Bing</category>
      
      
      <comments>https://samuflore.top/posts/ff51cb4c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Blog 7：[Hexo教程]更高级的 Markdown 渲染器：Markdown-it</title>
      <link>https://samuflore.top/posts/e11361f1/</link>
      <guid>https://samuflore.top/posts/e11361f1/</guid>
      <pubDate>Fri, 18 Jul 2025 02:29:59 GMT</pubDate>
      
      <description>&lt;div class=&quot;tips&quot;&gt;
&lt;p&gt;我正在使用 Markdown-it 来渲染此博文！&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;Hexo 默认使用 &lt;strong&gt;hexo-renderer-marked&lt;/strong&gt; 来渲染 Markdown 文件。此渲染器只支持一些基础语法。我们可以将其替换为更高级的 &lt;strong&gt;Markdown-it&lt;/strong&gt; 渲染器。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="tips"><p>我正在使用 Markdown-it 来渲染此博文！</p></div><h1 id="序">序</h1><p>Hexo 默认使用 <strong>hexo-renderer-marked</strong> 来渲染 Markdown 文件。此渲染器只支持一些基础语法。我们可以将其替换为更高级的 <strong>Markdown-it</strong> 渲染器。</p><span id="more"></span><hr><h1 id="安装">安装</h1><p>首先，您需要卸载原有的渲染器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure><p>然后安装新的渲染器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure><p>接着，您需要安装三个 Markdown-it 子插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i markdown-it-checkbox</span><br><span class="line">npm i markdown-it-imsize</span><br><span class="line">npm i markdown-it-expandable</span><br></pre></td></tr></table></figure><div class="warning"><p>请注意：科学上网。</p></div><div class="tips"><p>Markdown-it 内置了许多子插件，您只需手动安装上述三个。</p></div><hr><h1 id="配置">配置</h1><p>在<strong>站点配置文件</strong>的尾部填写 Markdown 渲染器配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">&quot;language-&quot;</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&quot;“”‘’&quot;</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-cjk-breaks</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-deflist</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-mark</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-checkbox</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-imsize</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-expandable</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">success</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">tips</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">warning</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">danger</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">&quot;header-anchor&quot;</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">&quot;left&quot;</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&quot;¶&quot;</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure><div class="tips"><p>要禁用某插件，您可<strong>注释</strong>该行。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - markdown-it-abbr</span></span><br></pre></td></tr></table></figure><p><s>或者直接删了</s></p></div><div class="warning"><p>上述代码的 <code>level</code> 字段表示最上级锚点的层级。当设置为 1 时，表示 <code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code> 都可以作为锚点。用于目录的跳转。</p></div><hr><h1 id="修改CSS">修改CSS</h1><p><a href="#Section">自定义容器</a>的样式需要您手动修改。对于NexT主题，您需要在以下路径的文件中添加CSS样式代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\next\source\css\_common\scaffolding\base.styl</span><br></pre></td></tr></table></figure><p>参考样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tips</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span> rgba(<span class="number">52</span>,<span class="number">152</span>,<span class="number">219</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">4px</span> solid rgb(<span class="number">52</span>,<span class="number">152</span>,<span class="number">219</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">darken</span>(<span class="built_in">rgb</span>(<span class="number">52</span>,<span class="number">152</span>,<span class="number">219</span>),<span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span> rgba(<span class="number">46</span>,<span class="number">204</span>,<span class="number">113</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">4px</span> solid rgb(<span class="number">46</span>,<span class="number">204</span>,<span class="number">113</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">darken</span>(<span class="built_in">rgb</span>(<span class="number">46</span>,<span class="number">204</span>,<span class="number">113</span>),<span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span> rgba(<span class="number">241</span>,<span class="number">196</span>,<span class="number">15</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">4px</span> solid rgb(<span class="number">241</span>,<span class="number">196</span>,<span class="number">15</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">darken</span>(<span class="built_in">rgb</span>(<span class="number">241</span>,<span class="number">196</span>,<span class="number">15</span>),<span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.danger</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span> rgba(<span class="number">231</span>,<span class="number">76</span>,<span class="number">60</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">4px</span> solid rgb(<span class="number">231</span>,<span class="number">76</span>,<span class="number">60</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">darken</span>(<span class="built_in">rgb</span>(<span class="number">231</span>,<span class="number">76</span>,<span class="number">60</span>),<span class="number">20%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tips"><p>其他主题，您可<strong>自行查找</strong></p></div><hr><h1 id="调用">调用</h1><h2 id="基础">基础</h2><table><thead><tr><th>插件</th><th>描述</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>markdown-it-abbr</td><td>注释</td><td><code>*[HTML]: Hyper Text Markup Language</code></td><td>*[HTML]: Hyper Text Markup Language</td></tr><tr><td>markdown-it-emoji</td><td>表情</td><td><code>:+1:</code></td><td>👍</td></tr><tr><td>markdown-it-footnote</td><td>脚注</td><td><code>文本[^1]文本</code></td><td>文本<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>文本</td></tr><tr><td>markdown-it-ins</td><td>下划线</td><td><code>++Inserted text++</code></td><td><ins>Inserted text</ins></td></tr><tr><td>markdown-it-mark</td><td>突出显示</td><td><code>==Marked text==</code></td><td><mark>Marked text</mark></td></tr><tr><td>markdown-it-sub</td><td>下标</td><td><code>H~2~O</code></td><td>H<sub>2</sub>O</td></tr><tr><td>markdown-it-sup</td><td>上标</td><td><code>X^2^</code></td><td>X<sup>2</sup></td></tr><tr><td>markdown-it-checkbox</td><td>复选框</td><td><code>- []未选中</code><br><code>- [x]已选中</code></td><td><input type="checkbox" id="checkbox1"><label for="checkbox1">未选中</label><br><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">已选中</label></td></tr></tbody></table><h2 id="进阶">进阶</h2><h3 id="折叠">折叠</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++ <span class="strong">**点击此处**</span></span><br><span class="line">这是被隐藏的内容。</span><br><span class="line">+++</span><br></pre></td></tr></table></figure><p>效果：</p><details open><summary><span class="pre-summary">&nbsp;</span><strong>点击此处</strong></summary><p>这是被隐藏的内容。</p></details><p><a id="Section"></a></p><h3 id="自定义容器">自定义容器</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">::: tips</span><br><span class="line"><span class="strong">**提示**</span></span><br><span class="line">这是一个提示</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: warning</span><br><span class="line"><span class="strong">**警告**</span></span><br><span class="line">这是一个警告</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: danger</span><br><span class="line"><span class="strong">**危险**</span></span><br><span class="line">这是一个危险信号</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: success</span><br><span class="line"><span class="strong">**成功**</span></span><br><span class="line">这是一个成功信号</span><br><span class="line">:::</span><br></pre></td></tr></table></figure><p>效果：</p><div class="tips"><p><strong>提示</strong><br>这是一个提示</p></div><div class="warning"><p><strong>警告</strong><br>这是一个警告</p></div><div class="danger"><p><strong>危险</strong><br>这是一个危险信号</p></div><div class="success"><p><strong>成功</strong><br>这是一个成功信号</p></div><hr><h1 id="推荐">推荐</h1><ul class="lvl-0"><li class="lvl-2"><p>查找 Emoji 的写法，您可参考：<a href="https://www.emojiall.com/zh-hans">EMOJIALL</a></p></li><li class="lvl-2"><p>查阅 Markdown-it 文档，您可参考：<a href="https://mdit-plugins.github.io/zh/">Markdown It 插件</a></p></li><li class="lvl-2"><p>了解更多 Markdown 语法，您可参考：<a href="https://markdown.com.cn/">Markdown 教程</a></p></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>这是参考文献。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/Hexo%E6%95%99%E7%A8%8B/">Hexo教程</category>
      
      
      <category domain="https://samuflore.top/tags/Hexo/">Hexo</category>
      
      <category domain="https://samuflore.top/tags/Tutorial/">Tutorial</category>
      
      <category domain="https://samuflore.top/tags/Markdown/">Markdown</category>
      
      
      <comments>https://samuflore.top/posts/e11361f1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
