<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>SamuFlore&#39;s Dimension</title>
    <link>https://samuflore.top/</link>
    
    <atom:link href="https://samuflore.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>一人倒、衆人倒。</description>
    <pubDate>Tue, 09 Sep 2025 02:50:19 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[轉載]新川大陆文化史</title>
      <link>https://samuflore.top/posts/10425c0c/</link>
      <guid>https://samuflore.top/posts/10425c0c/</guid>
      <pubDate>Tue, 09 Sep 2025 02:34:17 GMT</pubDate>
      
      <description>&lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;本文转载自神皇枫秀，敬请留意。&lt;/p&gt;
          &lt;/div&gt;
&lt;h1 id=&quot;新川大陆文化史&quot;&gt;新川大陆文化史&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;新川大陆的文明发展史是一部多元文化交融的史诗。从远古人类的起源分化，到各文明的兴衰更迭，这片土地见证了种族迁徙、技术革新、宗教演变与政治制度的不断创新。本书记述了从公元前2000年至公元1000年间，除川帝国外主要文明的发展历程，展现了斯特人、瓦伦人、伊塞尔人、米亚人等多个族群在探索、融合与抗争中共同谱写的文明篇章。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="note info">            <p>本文转载自神皇枫秀，敬请留意。</p>          </div><h1 id="新川大陆文化史">新川大陆文化史</h1><h2 id="引言">引言</h2><p>新川大陆的文明发展史是一部多元文化交融的史诗。从远古人类的起源分化，到各文明的兴衰更迭，这片土地见证了种族迁徙、技术革新、宗教演变与政治制度的不断创新。本书记述了从公元前2000年至公元1000年间，除川帝国外主要文明的发展历程，展现了斯特人、瓦伦人、伊塞尔人、米亚人等多个族群在探索、融合与抗争中共同谱写的文明篇章。</p><span id="more"></span><h2 id="第一章：人类起源与早期迁徙（公元前2000年之前）">第一章：人类起源与早期迁徙（公元前2000年之前）</h2><h3 id="1-1-人类共同祖先的分化">1.1 人类共同祖先的分化</h3><p>新川大陆的人类起源可追溯至远古时期的古人猿进化。根据《新川大陆民族发展简史》记载，古人猿主要分化为两个方向：</p><p>• <strong>兽向进化</strong>：形成<strong>林人</strong>，身形矫健，擅长山林间穿梭游居</p><p>• <strong>人向进化</strong>：形成<strong>山人</strong>，依靠智慧聚居于山洞，发展出早期社会组织</p><p>山人与林人的生存竞争构成了大陆文明的第一个重要分水岭。山人凭借更先进的工具使用能力和社会组织形式，在竞争中占据优势，迫使林人开始大规模迁徙，进而开启了新川大陆文明多样性的序幕。</p><h3 id="1-2-林人的三大迁徙路线">1.2 林人的三大迁徙路线</h3><p><strong>公元前2000年前后</strong>，山人与林人爆发决定性争斗，山人胜利后，林人被迫分为三大支系向不同方向迁徙：</p><p>• <strong>北迁支系</strong>：向寒冷的北方极地进发，逐渐适应严寒气候</p><p>• <strong>西南迁支系</strong>：进入干旱的沙漠戈壁地区，发展出耐旱生存技能</p><p>• <strong>西北迁支系</strong>：深入原始森林密布的西北山地，与野兽和复杂地形抗争</p><p>这一迁徙过程不仅是地理空间的拓展，更是文化多样性形成的关键阶段，为后来各文明的独特发展奠定了基础。</p><h3 id="1-3-山人的内部发展">1.3 山人的内部发展</h3><p>占据东部肥沃土地的山人，随着人口增长也开始分化为三支：</p><p>• <strong>海人</strong>：向东迁至沿海地区，发展渔业和航海文化</p><p>• <strong>川人</strong>：向平原地带发展，建立早期农业社会</p><p>• <strong>米亚人</strong>：沿河流建村，发展出与水资源密切相关的文化</p><p>山人与林人的分化与迁徙，构成了新川大陆文明发展的基本格局，为后续的文明碰撞与融合埋下了伏笔。</p><h2 id="第二章：远古探索时期（公元前2000年-公元前400年）">第二章：远古探索时期（公元前2000年-公元前400年）</h2><h3 id="2-1-北境文明的奠基：斯特人与斯尔吉亚雏形">2.1 北境文明的奠基：斯特人与斯尔吉亚雏形</h3><p><strong>公元前1700年前后</strong>，向北迁徙的林人分支在&quot;神之息&quot;山谷定居，逐渐演变为<strong>斯特人</strong>。他们选择的定居点位于摩尔吉亚河下游，这片山谷土地肥沃，四周环山，既提供了防御优势，又便于农业发展。斯特人在此建立了早期城镇<strong>坤达帖木儿</strong>，标志着北境第一个文明雏形的诞生。</p><p>斯特人发展出独特的山地农业技术，适应了北境较短的生长季节，并形成了以部落长老为核心的社会结构。他们崇拜山神，认为山脉是神灵的化身，这种信仰后来与川人的游牧文化融合，形成了斯尔吉亚文明的精神基础。</p><h3 id="2-2-西南沙漠的适应：瓦伦人的迁徙与定居">2.2 西南沙漠的适应：瓦伦人的迁徙与定居</h3><p><strong>公元前1600年前后</strong>，向西南迁徙的林人分支演变为<strong>瓦伦人</strong>。他们最初进入的裂空山谷地区气候干旱，生存条件恶劣，族群数量急剧减少。经过多年探索，瓦伦人最终穿越裂空山，发现了水源充沛、土地肥沃的<strong>裂龙山谷</strong>，并在此建立了<strong>拜亚城</strong>。</p><p>瓦伦人在裂龙山谷发展出独特的节水农业技术，他们建造了复杂的引水渠系统，将山泉水引入农田，成功在沙漠边缘开辟出绿洲。这种对水资源的精细管理能力，成为后来瓦伦迪亚商业文明的重要特征。</p><h3 id="2-3-西北山地的开拓者：伊塞尔人的分支发展">2.3 西北山地的开拓者：伊塞尔人的分支发展</h3><p><strong>公元前1400年前后</strong>，向西北迁徙的林人演变为<strong>伊塞尔人</strong>，并进一步分为两支：</p><p>• <strong>向西分支</strong>：约50年后抵达伊塞尔河上游，建立<strong>伊塞尔城</strong>。该城东南北三面环山，形成天然防御屏障，伊塞尔人在此发展出以农业为主的定居文明。</p><p>• <strong>向北分支</strong>：抵达寒冷的<strong>霜狼高原</strong>，开启了长达数百年的流浪生活。在与严酷自然环境的抗争中，他们与当地狼群形成了独特的共生关系，逐渐产生了对<strong>霜狼的信仰</strong>，这种信仰成为他们精神生活的核心。</p><p>伊塞尔人的两支发展路径，体现了同一族群在不同环境压力下的文化适应策略，为后来新川大陆文明的多样性做出了重要贡献。</p><h3 id="2-4-山人的分化与融合">2.4 山人的分化与融合</h3><p><strong>公元前1800年前后</strong>，占据东部肥沃土地的山人逐渐分化为三个支系：<strong>川人</strong>、<strong>海人</strong>和<strong>米亚人</strong>。这三支在发展过程中命运各异：</p><p><strong>海人</strong>因海洋资源有限和环境变化，于<strong>公元前1100年前后</strong>逐渐消亡，其土地被川人兼并。这一事件成为新川大陆文明发展史上第一次记录的民族消亡事件，反映了环境适应对文明存续的重要性。</p><p><strong>公元前1000年前后</strong>，<strong>川人</strong>发起对<strong>米亚人</strong>的兼并战争。战争导致米亚人分化为两支：一支被川人兼并，逐渐演变为<strong>兰川人</strong>；另一支则开始大规模迁徙，史称&quot;米亚远行&quot;，这一迁徙对后来多个文明的发展产生了深远影响。</p><h2 id="第三章：古典农业时期（公元前400年-公元400年）">第三章：古典农业时期（公元前400年-公元400年）</h2><h3 id="3-1-水利技术的传播与文明革新">3.1 水利技术的传播与文明革新</h3><p><strong>公元前800年前后</strong>，远行的米亚人与瓦伦人在裂龙山谷相遇。米亚人带来的先进水利技术与瓦伦人的沙漠生存经验相结合，促成了<strong>拜亚城</strong>的重建。这次重建不仅是城市物理空间的改造，更是一次深刻的文化融合，标志着<strong>瓦伦迪亚文明</strong>的正式形成。</p><p>米亚人带来的水利技术包括：</p><p>• 复杂的引水渠系统设计</p><p>• 水坝和水库的建造技术</p><p>• 农田灌溉的高效分配方法</p><p>这些技术使裂龙山谷的农业产量大幅提高，支持了人口增长和城市扩张，为瓦伦迪亚后来的商业繁荣奠定了物质基础。</p><h3 id="3-2-霜狼高原的文明融合：蒙里米亚的诞生">3.2 霜狼高原的文明融合：蒙里米亚的诞生</h3><p><strong>公元前700年前后</strong>，另一支远行的米亚人抵达<strong>霜狼高原</strong>，与在此流浪数百年的伊塞尔人北迁分支相遇。米亚人带来的水利技术使高原农业成为可能，他们在河流源头建立了<strong>蒙德里城</strong>，标志着<strong>蒙里米亚文明</strong>的诞生。</p><p>蒙里米亚文明的独特之处在于：</p><p>• <strong>霜狼信仰与米亚人宗教观念的融合</strong>：形成了独特的萨满教体系</p><p>• <strong>高原农业技术</strong>：开发出适应高寒环境的作物品种和种植技术</p><p>• <strong>政教合一的社会结构</strong>：宗教领袖同时掌握政治权力</p><p><strong>公元前307年</strong>，在伊塞尔人入侵的压力下，大先知蒙完成了对宗教的系统诠释，确立了以霜狼为核心的神学体系。<strong>公元前110年</strong>，蒙的第十一代孙统一霜狼高原各部，正式建立政教合一的<strong>蒙里米亚</strong>国家，使蒙里米亚成为古典农业时期最具影响力的文明之一。</p><h3 id="3-3-北境的民族融合：斯尔人的崛起">3.3 北境的民族融合：斯尔人的崛起</h3><p><strong>公元前500年前后</strong>，川人内部因生产方式差异发生分裂。从事游牧的一支因与农耕文明的冲突被边缘化，向北迁移。<strong>公元前400年前后</strong>，这支游牧川人与北境的斯特人相遇并逐渐融合，形成了新的民族——<strong>斯尔人</strong>。</p><p>斯尔人继承了：</p><p>• 斯特人的北境适应能力和骑射技术</p><p>• 川人的社会组织能力和军事战略思想</p><p>• 双方的文化传统和宗教信仰</p><p><strong>公元101年</strong>，斯尔人凭借军事优势占领<strong>坤达帖木儿</strong>，建立<strong>斯尔吉亚</strong>政权。斯尔吉亚实行军事贵族制度，形成了少数精英统治多数斯特人的社会结构，这种结构后来成为北境政治的典型模式。</p><h3 id="3-4-伊塞尔文明的动荡与变革">3.4 伊塞尔文明的动荡与变革</h3><p><strong>公元前309年</strong>，伊塞尔人向南扩张，大举进攻霜狼高原的蒙里米亚。然而，不适应高原环境的伊塞尔军队遭遇惨败，这场战争引发了伊塞尔内部的长期混乱。</p><p>战争失败后，伊塞尔社会陷入危机：</p><p>• 军事贵族与传统祭司的权力斗争加剧</p><p>• 资源分配不均引发社会矛盾</p><p>• 外部威胁与内部动荡交织</p><p><strong>公元前307年</strong>，在战争阴影下，大先知蒙完成宗教改革，而伊塞尔内部则出现了<strong>铁器技术</strong>引发的社会变革。铁器的传入改变了战争形态和生产方式，导致旧贵族与新兴军事阶层的冲突。旧贵族虽然在权力斗争中暂时获胜，但社会矛盾的积累为后来的动荡埋下了伏笔。</p><h2 id="第四章：帝国封建时期（公元400年-公元1000年）">第四章：帝国封建时期（公元400年-公元1000年）</h2><h3 id="4-1-双丹的独立与商业文明的兴起">4.1 双丹的独立与商业文明的兴起</h3><p><strong>公元404年</strong>，<strong>切丹</strong>宣布独立，这一事件成为帝国封建时期的开端。切丹家族虽身处川人政权体系，却保留着部分瓦伦人的血脉。他们利用瓦伦迪亚民众的暴乱，扩充私军，最终脱离川人统治，建立独立政权。</p><p>切丹政权的成功得益于：</p><p>• <strong>战略地理位置</strong>：在沿海地区建立双海港（赤丹港和乌丹港）</p><p>• <strong>灵活的外交策略</strong>：利用瓦伦迪亚与川帝国的矛盾，实行中立政策</p><p>切丹家族为避免内战，将双海港分别交给两个儿子治理，形成了赤丹港侧重金属加工业、乌丹港专注奢侈品贸易的分工格局。这种模式不仅促进了经济繁荣，也为后来的联邦制度提供了早期实践经验。</p><h3 id="4-2-瓦伦迪亚的统一与联邦共和制的诞生">4.2 瓦伦迪亚的统一与联邦共和制的诞生</h3><p><strong>公元409年</strong>，受双丹独立的鼓舞，瓦伦迪亚各城邦通过条约完成统一，创立了独特的<strong>联邦共和制</strong>。这一政治制度的创新包括：</p><p>• <strong>城邦代表制度</strong>：各城邦根据人口比例选派代表</p><p>• <strong>议会决策机制</strong>：重要事务由城邦代表组成的议会投票决定</p><p>• <strong>法律面前平等</strong>：确立了超越城邦界限的公民权利</p><p>瓦伦迪亚的统一并非通过军事征服，而是基于共同商业利益的自愿联合。这种和平统一模式在新川大陆文明史上独树一帜，反映了商业文明对政治制度的深刻影响。</p><h3 id="4-3-斯尔吉亚的军事扩张与北境霸权">4.3 斯尔吉亚的军事扩张与北境霸权</h3><p>斯尔吉亚在建立后迅速发展成为北境强国，其成功的关键因素包括：</p><p><strong>军事制度创新</strong>：</p><p>• 建立专业化的骑兵部队，职业军队就此诞生</p><p>• 发展先进的弓箭技术和战术</p><p>• 高效的信仰提供强力的军事动员</p><p><strong>战略资源控制</strong>：</p><p>• 占领万通港口，控制东西贸易的北方海上通道</p><p>• 开发东部草原作为战马繁育基地</p><p>• 建立覆盖北境的军事要塞网络</p><p>斯尔吉亚的军事扩张使其成为强大的军事帝国，其骑兵部队在大陆北部所向披靡，形成了独特的军事文化和贵族统治体系。</p><h3 id="4-4-伊塞尔的统一与现代化">4.4 伊塞尔的统一与现代化</h3><p>在经历了长达数百年的分裂与动荡后，<strong>艾</strong>于公元1世纪末崛起，通过军事征服和外交联盟，重新统一了伊塞尔各割据势力。艾的统一不仅结束了内乱，还：</p><p>• 建立了中央集权的行政体系</p><p>• 改革军事制度，吸收先进战术</p><p>• 发展与周边文明的贸易关系</p><p>艾的统一标志着<strong>现代伊塞尔文明</strong>的确立，使伊塞尔重新成为大陆西部的重要力量。伊塞尔文明在经历长期分裂后，吸收了多元文化元素，形成了独特的社会结构和文化传统。</p><h2 id="第五章：跨文明专题研究">第五章：跨文明专题研究</h2><h3 id="5-1-技术传播与文明互动">5.1 技术传播与文明互动</h3><p>新川大陆文明发展的重要特征是技术的跨文明传播，其中<strong>水利技术</strong>和<strong>金属冶炼技术</strong>的传播最为关键：</p><p><strong>水利技术传播路线</strong>：</p><p>• 起源：米亚人</p><p>• 传播路径：向西传入瓦伦，随后北上穿越沙漠传入霜狼高原和伊塞尔；</p><p>向北被川人吸纳，随后再次向北传入斯尔吉亚。</p><p>• 技术演变：从河流治理到水利灌溉，再到水力工业。</p><p><strong>金属冶炼技术传播</strong>：</p><p>• 起源：川人的善于冶炼的一支</p><p>• 传入路径：自被发现，迅速在川人文化普及，随后向四周辐射，向北进入斯尔吉亚，向西进入伊塞尔，向西南进入瓦伦迪亚。</p><p>• 社会影响：改变军事格局，促成新贵族崛起，引发社会结构变革</p><p>技术传播不仅是工具和方法的转移，更是知识体系和思维方式的交流，促进了各文明的创新与发展。</p><h3 id="5-2-宗教演变与精神文化">5.2 宗教演变与精神文化</h3><p>新川大陆各文明发展出丰富的宗教体系，这些宗教既反映了各民族的生存环境，也塑造了他们的文化特征：</p><p><strong>霜狼信仰</strong>：</p><p>• 起源：伊塞尔人北迁分支在霜狼高原的生存体验</p><p>• 发展：与米亚人宗教观念融合，形成蒙里米亚国教</p><p>• 特征：自然崇拜与祖先崇拜结合，动物图腾（霜狼）为核心象征</p><p><strong>山神信仰</strong>：</p><p>• 起源：斯特人在&quot;神之息&quot;山谷的定居经历</p><p>• 演变：与川人游牧文化融合，形成斯尔吉亚的军事神学</p><p>• 影响：强化了军事贵族的统治合法性</p><p>宗教不仅是精神寄托，也是社会整合的工具，在蒙里米亚的政教合一和斯尔吉亚的军事动员中发挥了关键作用。</p><p>两种信仰均在极度寒冷的自然条件压迫下产生，或许信仰能成为人类在危难面前支撑活下去的精神源泉。</p><h3 id="5-3-政治制度的多样性与创新">5.3 政治制度的多样性与创新</h3><p>帝国封建时期，新川大陆各文明发展出多样化的政治制度，反映了不同的社会结构和文化传统：</p><p><strong>蒙里米亚的政教合一制</strong>：</p><p>• 权力结构：宗教领袖同时担任政治首脑</p><p>• 治理方式：以宗教律法为基础，祭司阶层参与行政管理</p><p>• 优势与局限：强化社会凝聚力，但限制思想创新</p><p><strong>瓦伦迪亚的联邦共和制</strong>：</p><p>• 权力结构：城邦代表组成的议会为最高权力机构</p><p>• 决策机制：多数投票制，城邦享有高度自治权</p><p>• 优势与局限：促进商业发展和文化多元，但决策效率较低</p><p><strong>斯尔吉亚的军事贵族制</strong>：</p><p>• 权力结构：军事精英组成的贵族会议掌握实权</p><p>• 社会流动：基于军功的晋升体系，保持军事活力</p><p>• 优势与局限：形成强大军事力量，但容易引发对外扩张</p><p><strong>双丹的商业寡头制</strong>：</p><p>• 权力结构：富裕商人组成的寡头集团控制政治</p><p>• 治理特点：以商业利益为导向，灵活的外交政策</p><p>• 优势与局限：促进经济繁荣，但可能忽视社会公平</p><p>这些政治制度的多样性反映了新川大陆文明发展的丰富性，也为不同环境下的社会治理提供了多样化的解决方案。</p><h2 id="第六章：文明互动与历史影响">第六章：文明互动与历史影响</h2><h3 id="6-1-贸易网络的构建与文化交流">6.1 贸易网络的构建与文化交流</h3><p><strong>公元500年后</strong>，新川大陆形成了以覆盖多帝国的贸易网络：</p><p><strong>主要贸易路线</strong>：</p><p>• 沙漠商路：自川帝国京师一路向西，穿越沙漠，连接各个大型城市，最终抵达伊塞尔城。这条商路是大陆最重要的陆地贸易。</p><p>• 双丹商路：双丹港口作为贸易基站，东连川帝国东海岸五大港口，西连瓦伦，西门。（西帝国唯一港口，西帝国是川文化的扩张）</p><p>• 北方航道：自万通港至米亚基斯，是东西贸易最为高效的商路。</p><p>• 东部丝绸之路：川帝国盛产的丝绸等奢饰品向北连接斯尔吉亚，进入万通港，向东进入五大港，向西南进入瓦伦，是最重要的奢侈品贸易路线。</p><p>贸易不仅促进了商品流通，也带来了文化交流：</p><p>• 语言的相互影响：各文明词汇的借用与语法结构的趋同</p><p>• 科技知识的传播：农业技术、手工业方法的跨文明交流</p><h3 id="6-2-军事冲突与文明融合">6.2 军事冲突与文明融合</h3><p>军事冲突虽然带来破坏，但也促进了文明间的融合：</p><p>古典时期三大战争</p><p><strong>伊塞尔-蒙里米亚战争（公元前309年）</strong>：</p><p>• 直接结果：伊塞尔失败，蒙里米亚巩固高原统治</p><p>• 长远影响：促进军事技术交流，伊塞尔内乱为艾的统一创造条件</p><p><strong>斯尔吉亚扩张（公元100-200年）</strong>：</p><p>• 军事策略：骑兵部队的灵活运用，要塞体系的建设</p><p>• 文化影响：斯特人与川人文化的深度融合，形成新的文化认同</p><p>• 长远影响：夺取万通港，占据东部大草原，为斯尔吉亚的强盛奠定基础</p><p><strong>双丹独立战争（公元404年）</strong>：</p><p>• 政治影响：打破川人霸权，开启联邦共和实验</p><p>• 经济影响：促进商业网络形成，改变大陆权力格局</p><h3 id="6-3-主要文明的历史地位与贡献">6.3 主要文明的历史地位与贡献</h3><p><strong>蒙里米亚文明</strong>：</p><p>• 独特贡献：政教合一制度的实践，高原农业技术的创新</p><p>• 文化遗产：丰富的宗教典籍，独特的艺术风格，水利工程技术</p><p><strong>瓦伦迪亚文明</strong>：</p><p>• 独特贡献：联邦共和制度的早期实践，商业文化的发展</p><p>• 文化遗产：法律体系，商业契约传统，城市规划理念</p><p><strong>斯尔吉亚文明</strong>：</p><p>• 独特贡献：骑兵战术的革新，游牧与农耕文化的融合</p><p>• 文化遗产：军事训练体系，马术技术，多元文化融合模式</p><p><strong>双丹文明</strong>：</p><p>• 独特贡献：商业网络的构建，城邦联盟的治理经验</p><p>• 文化遗产：航海技术，金融制度，国际贸易规范</p><p><strong>伊塞尔文明</strong>：</p><p>• 独特贡献：在分裂与统一中探索社会整合的路径</p><p>• 文化遗产：铁器制造技术，行政管理体系，文学传统</p><h2 id="第七章：终论">第七章：终论</h2><p>新川大陆的文明发展史是一部多元文化互动、冲突与融合的史诗。从远古时期山人与林人的分化，到古典农业时期的技术传播，再到帝国封建时期的政治创新，各文明在适应环境、应对挑战的过程中，发展出独特的文化特征和社会结构。</p><p>蒙里米亚的宗教整合、瓦伦迪亚的商业智慧、斯尔吉亚的军事创新、双丹的贸易网络、伊塞尔的社会变革，共同构成了新川大陆文明的丰富图景。这些文明虽然发展路径各异，但都对大陆的整体发展做出了独特贡献。</p><p>新川大陆文明发展的历史启示：</p><p>1. 环境适应是文明存续的基础，各文明都发展出适应特定环境的生存策略</p><p>2. 技术创新和传播是文明进步的关键驱动力</p><p>3. 文化融合能够创造新的文明形态，增强社会活力</p><p>4. 政治制度的多样性反映了不同社会结构的适应性需求</p><p>5. 贸易网络的构建促进了物质与文化的交流，推动整体发展</p><p>新川大陆的文明发展史表明，文明的进步不是单一模式的复制，而是多元文化在互动中共同演进的过程。这种多元一体的发展模式，为理解人类文明的多样性和统一性提供了重要视角。</p><h2 id="附录：新川大陆文明年表">附录：新川大陆文明年表</h2><p>• <strong>公元前2000年</strong>：山人与林人爆发争斗，林人被迫迁徙</p><p>• <strong>公元前1800年</strong>：山人分化为川人、海人、米亚人</p><p>• <strong>公元前1700年</strong>：斯特人建立坤达帖木儿，北境文明诞生</p><p>• <strong>公元前1600年</strong>：瓦伦人建立拜亚城，西南文明奠基</p><p>• <strong>公元前1400年</strong>：伊塞尔人分化，西支建立伊塞尔城</p><p>• <strong>公元前1100年</strong>：海人消亡，土地被川人兼并</p><p>• <strong>公元前1000年</strong>：川人兼并米亚人，引发米亚远行</p><p>• <strong>公元前800年</strong>：米亚人与瓦伦人融合，瓦伦迪亚文明形成</p><p>• <strong>公元前700年</strong>：米亚人抵达霜狼高原，蒙里米亚文明萌芽</p><p>• <strong>公元前500年</strong>：川人与兰川人融合，形成新川人</p><p>• <strong>公元前400年</strong>：川人游牧分支与斯特人融合，形成斯尔人</p><p>• <strong>公元前309年</strong>：伊塞尔进攻霜狼高原失败，陷入内乱</p><p>• <strong>公元前307年</strong>：大先知蒙完成宗教改革</p><p>• <strong>公元前110年</strong>：蒙里米亚完成政教合一</p><p>• <strong>公元前77年左右</strong>：艾统一伊塞尔，伊塞尔文明确立</p><p>• <strong>公元101年</strong>：斯尔人占领坤达帖木儿，建立斯尔吉亚</p><p>• <strong>公元404年</strong>：切丹独立，双丹文明兴起</p><p>• <strong>公元409年</strong>：瓦伦迪亚完成统一，联邦共和制确立</p><p>• <strong>公元500年后</strong>：新川大陆跨文明贸易网络形成</p>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%BD%89%E8%BC%89/">轉載</category>
      
      
      <category domain="https://samuflore.top/tags/History/">History</category>
      
      <category domain="https://samuflore.top/tags/Repost/">Repost</category>
      
      
      <comments>https://samuflore.top/posts/10425c0c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CO Pre]Verilog 入门</title>
      <link>https://samuflore.top/posts/c9f56abd/</link>
      <guid>https://samuflore.top/posts/c9f56abd/</guid>
      <pubDate>Mon, 01 Sep 2025 08:50:18 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Verilog 部分。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Verilog 部分。</p><span id="more"></span><h1 id="IDE">IDE</h1><p>本文使用 ISE 开发与仿真。</p><h1 id="Verilog-语法">Verilog 语法</h1><h2 id="模块的定义方法">模块的定义方法</h2><p>模块（module）是 Verilog HDL 的基本功能单元，它实际上代表了具有一定功能的电路实体。通俗来讲，其代表了电路中被导线连接的各个功能模块（子电路）。</p><p>以一个与门为例：<br>方法一：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AndGate(</span><br><span class="line">    <span class="keyword">input</span> i1,</span><br><span class="line">    <span class="keyword">input</span> i2,</span><br><span class="line">    <span class="keyword">output</span> o</span><br><span class="line">);<span class="comment">// 模块名定义、端口定义及IO说明</span></span><br><span class="line">    <span class="keyword">assign</span> o = i1 &amp; i2; <span class="comment">// 模块功能定义</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">// 结束模块定义</span></span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AndGate(i1,i2,o); <span class="comment">// 模块名定义及端口定义</span></span><br><span class="line">    <span class="keyword">input</span> i1;</span><br><span class="line">    <span class="keyword">input</span> i2; <span class="comment">// 也可合并为一句: input i1,i2;</span></span><br><span class="line">    <span class="keyword">output</span> o;</span><br><span class="line">    <span class="comment">// 上为IO说明</span></span><br><span class="line">    <span class="keyword">assign</span> o = i1 &amp; i2; <span class="comment">// 模块功能定义</span></span><br><span class="line"><span class="keyword">endmodule</span> <span class="comment">// 结束模块定义</span></span><br></pre></td></tr></table></figure><p>两种方法没有实质上的区别，只是形式上有所不同：方法 1 对方法 2 中的端口定义及 IO 说明进行了合并。<br>模块以 <code>module</code> 开始，<code>endmodule</code> 结束，中间包括模块名、端口定义、I/O 说明等部分。<ins>模块中的语句除了顺序执行的语句块以外都是并行的</ins>；输入输出端口若不特别说明类型及位宽，<ins>默认为 1 位 <code>wire</code> 型</ins>。</p><h2 id="常用数据类型">常用数据类型</h2><h3 id="Wire-型">Wire 型</h3><p><code>wire</code> 型数据属于线网 <code>nets</code> 型数据，通常用于表示组合逻辑信号，可以将它类比为电路中的导线。它本身并不能存储数据，需要有输入才有输出（这里输入的专业术语叫驱动器），且输出随着输入的改变而即时改变。一般使用 <code>assign</code> 语句对 <code>wire</code> 型数据进行驱动（<code>assign</code> 语句将在下一节中进行讲解）。</p><p><code>wire</code> 型的数据分为标量（1 位）和向量（多位）两种。可以在声明过程中使用范围指示器指明位数，如 <code>wire [31:0] a</code>;。冒号两侧分别代表最高有效位（MSB, Most Significant Bit）和最低有效位（LSB, Least Significant Bit）。在访问时，可以使用形如 <code>a[7:4]</code> 的方式取出 <code>a</code> 的第 7-4 位数据。</p><div class="tips"><p>声明位宽时，如果写作 <code>wire [0:31] a</code> 也是可以的。此时高位被指定为第 0 位，低位被指定为第 31 位。为其赋值时 <code>a = 32'h1234_5678</code> 1 会实际存储在首位，而 8 会存储在末位，与正常相反。</p></div><div class="note warning">            <p>信号定义好之后，不仅决定了位宽还决定了方向，例如定义为 <code>[4:7]</code> 的 <code>b</code> 信号，四个管脚分别为 4，5，6，7，在使用中只能正向接，不能反向接。因此接 <code>b[4:7]</code> 是合法的，而 <code>b[7:4]</code> 是不合法的；同理接 <code>c[8:11]</code> 是合法的，接 <code>c[11:8]</code> 是不合法的。（“接”指赋值操作）</p>          </div><div class="note info">            <p>在 Verilog 里，信号的位宽可以通过 <code>in[a:b]</code> 这样的语法来取一部分:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> out = in[<span class="number">7</span>:<span class="number">4</span>];<span class="comment">//取 in 的第 7-4 位</span></span><br></pre></td></tr></table></figure><p>这里的 <code>a</code> 和 <code>b</code> 都必须是<ins>常量</ins>，不能包含变量。比如写成 <code>assign out = in[m * 4 + 3:m * 4]</code> 就会报错，因为 <code>m</code> 是一个变量。<br>但是，Verilog-2001/SystemVerilog 提供了一种叫 part-select with variable index 的写法:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> out = in[start +: width];<span class="comment">//从 start 位开始往高位取 width 位</span></span><br><span class="line"><span class="keyword">assign</span> out = in[start -: width];<span class="comment">//从 start 位开始往低位取 width 位</span></span><br></pre></td></tr></table></figure><p>这里的 start 则可以是变量，而 width 必须是常量。</p>          </div><h3 id="Reg-型">Reg 型</h3><p><code>reg</code> 型是寄存器数据类型，具有存储功能。它也分为标量和向量，类似 <code>wire</code> 型，可以类比前面的教程。一般在 <code>always</code> 块内使用 <code>reg</code> 型变量（<code>always</code> 块将在本章后面提到），通过赋值语句来改变寄存器中的值。为了确定何时进行赋值，我们经常需要用到各种控制结构，包括 <code>while</code>、<code>for</code>、<code>switch</code> 等，这与 C 语言中的做法十分相似。</p><p>需要注意的是，<code>reg</code> 型变量<ins>不能使用 <code>assign</code> 赋值</ins>。而且，<code>reg</code> 型<ins>并不一定被综合成寄存器</ins>，它也可和 <code>always</code> 关键字配合（下一节会讲到），建模组合逻辑。</p><p>我们可以通过对 <code>reg</code> 型变量建立数组来对存储器建模，例如 <code>reg [31:0] mem [0:1023]</code>;，其中前面的中括号内为位宽，后面的中括号内为存储器数量。这种写法在我们开始搭建CPU后会用到。<br>我们可以通过引用操作访问存储器型数据元素，类似于位选择操作，例如 <code>mem[2]</code> 就是访问 <code>mem</code> 中的第 3 个元素。</p><div class="tips"><p>Verilog HDL 中<ins>没有</ins>多维数组。</p></div><h3 id="数字字面量">数字字面量</h3><p>Verilog 中的数字字面量可以按二进制（b 或 B）、八进制（o 或 O）、十六进制（h 或 H）、十进制（d 或 D）表示。</p><p>数字的完整表达为 <code>&lt;位宽&gt;'&lt;进制&gt;&lt;值&gt;</code>，如 <code>10'd100</code>。省略位宽时采用默认位宽（与机器有关，一般为 <ins>32 位</ins>），省略进制时默认为<ins>十进制</ins>，值部分可以用下划线分开提高可读性，如 <code>16'b1010_1011_1111_1010</code>。</p><p>Verilog 中除了普通的数字以外，还有两个特殊的值：<code>x</code> 和 <code>z</code>。<code>x</code> 为不定值，当某一二进制位的值不能确定时出现，变量的默认初始值为 <code>x</code>。<code>z</code> 为高阻态，代表没有连接到有效输入上。对于位宽大于 1 的数据类型，<code>x</code> 与 <code>z</code> 均可只在部分位上出现。</p><div class="warning"><p>注意数字的位宽决定了数字的最大值。比如 <code>3'd101</code> 就是一个非法的数字，因为 3 位宽的数字最大值为 7。</p></div><div class="warning"><p>Verilog 数字本身并不能添加负号，但写作类似于 <code>-8'd5</code> 这样的形式可以看作是对数字的运算，是合法的。</p></div><h3 id="Integer-型">Integer 型</h3><p><code>integer</code> 数据类型一般为 32 位，与 C 语言中的 <code>int</code> 类似，默认为有符号数，在我们的实验中主要用于 <code>for</code> 循环（将在本章后面提到）。</p><h3 id="Parameter-型">Parameter 型</h3><p><code>parameter</code> 类型用于在编译时确认值的常量，通过形如 <code>parameter 标识符 = 表达式</code>; 的语句进行定义，如：<code>parameter width = 8</code>;。在实例化模块时，可通过参数传递改变在被引用模块实例中已定义的参数（模块的实例化将在后面的章节进行介绍）。<code>parameter</code> 虽然看起来可变，但它属于常量，在编译时会有一个确定的值。</p><p><code>parameter</code> 可以用于在模块实例化时指定数据位宽等参数，便于在结构相似、位宽不同的模块之间实现代码复用。</p><h2 id="组合逻辑建模常用语法">组合逻辑建模常用语法</h2><h3 id="Assign-语句">Assign 语句</h3><p><code>assign</code> 语句是连续赋值语句，是组合逻辑的建模利器，其作用是用一个信号来驱动另一个信号。如 <code>assign a = b</code>;，其中 <code>a</code> 为 <code>wire</code> 型（也可由位拼接得到，见运算符部分），<code>b</code> 是由数据和运算符组成的表达式。</p><p><code>assign</code> 语句与 C 语言的赋值语句有所不同，这里“驱动”的含义类似于电路的连接，也就是说，<code>a</code> 的值<ins>时刻</ins>等于 <code>b</code>。这也解释了 <code>assign a = a + 1</code>; 这样的语句为什么是不合法的。由于这样的特性，<code>assign</code> 语句不能在 <code>always</code> 和 <code>initial</code> 块中使用。</p><p><code>assign</code> 语句经常与三目运算符配合使用建模组合逻辑。一般来说，<code>assign</code> 语句综合出来的电路是右侧表达式化简后所对应的逻辑门组合。</p><div class="note warning">            <ul class="lvl-0"><li class="lvl-2"><p><code>reg</code> 类型不能被 <code>assign</code> 赋值。</p></li><li class="lvl-2"><p>未被 <code>assign</code> 赋值（驱动）过的 <code>wire</code> 类型数据不能被赋给其他的 <code>wire</code> 类型数据。未被 <code>assign</code> 过的 <code>wire</code> 类型就好比什么都没连接的导线，它和其它导线连接是没有意义的。</p></li><li class="lvl-2"><p>1 位的变量，不可以被两次 <code>assign</code>，多位的变量，每一位只能被一次 <code>assign</code>。比如 <code>wire [3:0] output; assign output[1:0] = 2'b01; assign output[3:2] = 2'b10;</code> 这是合法的。而 <code>assign output = 4'b0; assign output[1:0] = 2'b01;</code> 是不合法的，因为 0 位和 1 位被两次赋值。</p></li></ul>          </div><h3 id="运算符">运算符</h3><p>这里只介绍和 C 语言有差异的运算符。</p><ul class="lvl-0"><li class="lvl-2"><p>Verilog 中没有自增和自减运算符。</p></li><li class="lvl-2"><p>操作数中有不定值 <code>x</code> 和高阻态 <code>z</code> 时，结果中也可能出现。</p></li><li class="lvl-2"><p>逻辑右移 <code>&gt;&gt;</code> 和算术右移 <code>&gt;&gt;&gt;</code></p><ul class="lvl-2"><li class="lvl-6">它们的区别主要在于前者在最高位补 0，而后者在最高位补符号位。</li></ul></li><li class="lvl-2"><p>相等比较运算符 <code>==</code> 和 <code>===</code>、不等比较运算符 <code>!=</code> 和 <code>!==</code></p><ul class="lvl-2"><li class="lvl-6"><code>==</code> 和 <code>!=</code> 可能由于不定值 <code>x</code> 和高阻值 <code>z</code> 的出现导致结果为不定值 <code>x</code>，而 <code>===</code> 和 <code>!==</code> 的结果一定是确定的 0 或 1（<code>x</code> 与 <code>z</code> 也参与比较）。</li></ul></li><li class="lvl-2"><p>阻塞赋值 <code>=</code> 和非阻塞赋值 <code>&lt;=</code></p><ul class="lvl-2"><li class="lvl-6">不同于 <code>assign</code> 语句，这两种赋值方式被称为过程赋值，通常出现在 <code>initial</code> 和 <code>always</code> 块中，<ins>为 <code>reg</code> 型变量赋值</ins>。这种赋值类似 C 语言中的赋值，不同于 <code>assign</code> 语句，赋值仅会在一个时刻执行。由于 Verilog 描述硬件的特性，Verilog 程序内会有大量的并行，因而产生了这两种赋值方式。这两种赋值方式的详细区别会在<a href="#assignment">之后的小节内</a>介绍，这里暂时只需记住一点：为了写出正确、可综合的程序，<ins>在描述时序逻辑时要使用非阻塞式赋值 <code>&lt;=</code></ins>。</li></ul></li><li class="lvl-2"><p>位拼接运算符 <code>&#123;&#125;</code></p><ul class="lvl-2"><li class="lvl-6">这个运算符可以将几个信号的某些位拼接起来，例如 <code>&#123;a, b[3:0], w, 3'b101&#125;</code>;；可以简化重复的表达式，如 <code>&#123;4&#123;w&#125;&#125;</code> 等价于 <code>&#123;w,w,w,w&#125;</code>；还可以嵌套，<code>&#123;b, &#123;3&#123;a, b&#125;&#125;&#125;</code> 等价于 <code>&#123;b, &#123;a, b, a, b, a, b&#125;&#125;</code>，也就等价于 <code>&#123;b, a, b, a, b, a, b&#125;</code>。</li></ul></li><li class="lvl-2"><p>缩减运算符</p><ul class="lvl-2"><li class="lvl-6">运算符 <code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）等作为<em>单目运算符</em>是对操作数的<strong>每一位汇总运算</strong>，如对于 <code>reg[31:0] B</code>; 中的 <code>B</code> 来说，<code>&amp;B</code> 代表将 <code>B</code> 的<em>每一位</em>与起来得到的结果。</li></ul></li></ul><h2 id="时序逻辑建模常用语法">时序逻辑建模常用语法</h2><h3 id="Always-块">Always 块</h3><p><code>always</code> 块有如下两种用法：</p><ul class="lvl-0"><li class="lvl-2"><p>若 <code>always</code> 之后紧跟 <code>@(...)</code>，其中括号内是敏感条件列表，表示当括号中的条件满足时，将会执行 <code>always</code> 之后紧跟的语句或顺序语句块（和 C 语言中的语句块类似，只是将大括号用 <code>begin</code> 和 <code>end</code> 替换了）。这种用法主要用于<ins>建模时序逻辑</ins>。<br>例如：</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)  <span class="comment">// 表示在 clk 上升沿触发后面的语句块</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">// 一些操作</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>若 <code>always</code> 之后紧跟 <code>@ *</code> 或 <code>@(*)</code>，则表示对<ins>其后紧跟的语句或语句块</ins>内<ins>所有信号</ins>的变化敏感。这种用法主要用于与 reg 型数据和阻塞赋值配合，建模组合逻辑。</p></li><li class="lvl-2"><p>若 <code>always</code> 紧跟语句，则表示在该语句执行完毕之后立刻再次执行。这种用法主要配合后面提到的时间控制语句使用，来产生一些周期性的信号。</p></li></ul><p><code>always</code> 的敏感条件列表中，条件使用变量名称表示，例如 <code>always @(a)</code> 表示当变量 <code>a</code> <ins>发生变化</ins>时执行之后的语句；若条件前加上 <code>posedge</code> 关键字，如 <code>always @(posedge a)</code>，表示当 <code>a</code> 达到<ins>上升沿</ins>，即从 0 变为 1 时触发条件，下降沿不触发；加上 <code>negedge</code> 则是下降沿触发条件，上升沿不触发。每个条件使用逗号 , 或 <code>or</code> 隔开，只要有其中一个条件被触发，<code>always</code> 之后的语句都会被执行。</p><div class="tips"><p>敏感条件是变量时，该变量只要变化就会触发执行，没有对高低电平的要求。</p></div><div class="warning"><p>多个 <code>always</code> 块中对同一个变量进行赋值会导致无法综合。</p></div><h3 id="Initial-块">Initial 块</h3><p><code>initial</code> 块后面紧跟的语句或顺序语句块在硬件仿真开始时就会运行，且仅会运行一次，一般用于对 <code>reg</code> 型变量的取值进行初始化。<code>initial</code> 块通常仅用于仿真，是<em>不可综合的</em>。下面的代码用于给寄存器 <code>a</code> 赋初始值 0：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><div class="note warning">            <p><code>wire</code> 型数据不能在 <code>always</code> 和 <code>initial</code> 块中赋值。<br><code>wire</code> 类型本质上模拟硬件电路中的物理导线，它本身不具备存储功能，仅用于传递信号（从驱动源到接收端）。导线的特性是 “即时响应驱动源”—— 驱动源的信号变化会立即通过导线传递，没有时间延迟或状态保持。<br>而 <code>always</code> 块描述的是时序逻辑或组合逻辑的 “计算过程”，通常包含条件判断、状态跳转等逻辑，其赋值对象需要具备 “根据逻辑计算结果更新状态” 的能力。<code>wire</code> 作为导线，无法承载这种 “计算后更新” 的语义，因此不能作为 <code>always</code> 块的赋值目标。</p>          </div><blockquote><p><strong>语句块</strong><br>块语句的作用是将多条语句合并成一组，使它们像一条语句那样。在使用上一节提到的各种控制语句或者要使用 <code>always</code>/<code>initial</code> 过程块时，如果要执行多条语句，就可以使用块语句，这就类似于 C 语言中大括号里的语句。块语句有两种：顺序块和并行块。顺序块的关键字是 <code>begin</code> - <code>end</code>，并行块的关键字是 <code>fork</code> - <code>join</code>，关键字位于块语句的起始位置和结束位置，相当于 C 语言中的左大括号和右大括号。块语句也可以嵌套。</p><ol><li class="lvl-3">顺序块中的语句是一条接一条按顺序执行的，只有前面的语句执行完成之后才能执行后面的语句，除非是带有内嵌延迟控制的非阻塞赋值语句。</li><li class="lvl-3">如果语句包括延迟，那么延迟总是相对于前面那条语句执行完成的仿真时间的。</li></ol></blockquote><h3 id="If-语句">If 语句</h3><p>Verilog 中 <code>if</code> 语句的语法和 C 语言基本相同，也有 <code>else if</code>、<code>else</code> 这样的用法。但是，<ins><code>if</code> 语句只能出现在顺序块中</ins>，其后的分支也只能是语句或顺序块。举例如下（下面的例子也使用了 <code>always</code> 建模组合逻辑）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @ * <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">begin</span></span><br><span class="line">        out = a;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        out = b;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="Case-语句">Case 语句</h3><p>Verilog 中的 <code>case</code> 语句与 C 语言的写法略有区别，详见下方的示例。<code>case</code> 语句同样只能出现在<ins>顺序块</ins>中，其中的分支也只能是语句或顺序块。与 C 语言不同，<ins><code>case</code> 语句在分支执行结束后不会落入下一个分支</ins>，而会<ins>自动退出</ins>。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">case</span>(data)</span><br><span class="line">      <span class="number">0</span>: out &lt;= <span class="number">4</span>;</span><br><span class="line">      <span class="number">1</span>: out &lt;= <span class="number">5</span>;</span><br><span class="line">      <span class="number">2</span>: out &lt;= <span class="number">2</span>;</span><br><span class="line">      <span class="number">3</span>: <span class="keyword">begin</span></span><br><span class="line">          out &lt;= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">default</span>: ;</span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><div class="tips"><p>Verilog 中的 <code>case</code> 语句默认做的是全等比较，即所有位都相等（包括 <code>x</code> 和 <code>z</code>）。上例中 <code>data === 0</code> 时 <code>out</code> 才会赋值为 4。</p></div><h3 id="For-语句">For 语句</h3><p><code>for</code> 语句和 C 语言中的类似。</p><h4 id="循环变量">循环变量</h4><p><code>integer</code> 类型和 <code>reg</code> 类型的变量均可以作为循环变量，但 <code>reg</code> 型需要注意位宽的设置以免造成<ins>死循环</ins>，譬如：</p><div class="note danger">            <p>以下代码会造成 Isim 崩溃。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] tmp;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (tmp = <span class="number">2&#x27;h0</span>; tmp &lt;= <span class="number">2&#x27;h3</span>; tmp = tmp + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;tmp = %d&quot;</span>, tmp);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Finished.&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>          </div><p>这是因为 <code>tmp</code> 位宽为 2，最大只能到 2’h3，当 <code>tmp</code> 等于 2’h3 时，下一轮循环 <code>tmp</code> 溢出，回到 2’h0，如此往复导致死循环。</p><h3 id="While-语句">While 语句</h3><p><code>while</code> 语句和 C 语言中的类似。</p><div class="tips"><p>在 Verilog 中所有的循环语句只能在 always 或 initial 块中使用。</p></div><h2 id="模块实例化">模块实例化</h2><p>对于一个已经存在的模块 <code>Sample</code>，以及其定义好的接口 <code>input a</code>, <code>input b</code>, <code>output c</code>，我们可以通过以下方法进行实例化：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> x;</span><br><span class="line"><span class="keyword">wire</span> y;</span><br><span class="line"><span class="keyword">wire</span> z;</span><br><span class="line">Sample sample_instance1 (x, y, z);<span class="comment">//这里，x, y, z 会自动匹配 Sample 模块定义时的形参顺序。</span></span><br><span class="line">Sample sample_instance2 (<span class="variable">.b</span>(x), <span class="variable">.a</span>(y), <span class="variable">.c</span>(z));<span class="comment">//这里，.b, .a, .c 是为形参指定了匹配的实参。</span></span><br></pre></td></tr></table></figure><p><a id="assignment"></a></p><h2 id="非阻塞赋值和阻塞赋值">非阻塞赋值和阻塞赋值</h2><p>考察以下代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> blocked_and_non_blocked(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> b_blocked,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> c_blocked,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> b_non_blocked,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> c_non_blocked</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞赋值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        b_non_blocked &lt;= a;</span><br><span class="line">        c_non_blocked &lt;= b_non_blocked;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 阻塞赋值</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        b_blocked = a;</span><br><span class="line">        c_blocked = b_blocked;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="非阻塞赋值">非阻塞赋值</h3><p><code>clk</code> 上升沿到来的时候，可以认为仿真器为 <code>&lt;=</code> 右侧的变量做了一次“快照”，即存储了它们的值。然后将“快照”值赋给了 <code>&lt;=</code> 左侧的变量。在上述代码中，<code>b_non_blocked</code> 值变为 <code>a</code> 的值，而 <code>c_non_blocked</code> 值变为原来的 <code>b_non_blocked</code> 值。</p><div class="tips"><p>处在一个 <code>always</code> 块中的非阻塞赋值是在块结束时同时并发执行的。</p></div><h3 id="阻塞赋值">阻塞赋值</h3><p>阻塞赋值是<ins>顺序执行</ins>的。在 <code>begin</code> - <code>end</code> 顺序块中，前一句阻塞赋值完成后，后一句阻塞赋值才会开始。在上述代码中，上升沿到来时，<code>b_blocked</code> 值变为 <code>a</code> 的值，然后 <code>c_blocked</code> 值才变为新的 <code>b_blocked</code> 值，即 <code>a</code> 的值。</p><div class="warning"><p>在时序逻辑中的阻塞赋值可能是不可综合的。</p></div><h2 id="有符号数的处理">有符号数的处理</h2><p><code>wire</code>, <code>reg</code> 等类型的数据默认是<ins>无符号</ins>的。</p><p>若要声明该数据是有符号的，需要使用 <code>$signed()</code>，例如 <code>$signed(a)</code>。</p><h3 id="一个简单的例子">一个简单的例子</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> comparator(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> res</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> res = a &gt;= b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>我们编写一个 Testbench 来测试，令 <code>a</code> 和 <code>b</code> 的初始值都为 1，100 ns 后令 <code>b</code> 为 -1。<br>我们期望看到 <code>res</code> 的值恒为 1，但是实际观测到 100 ns 后 <code>res</code> 的值变为 0。<br>这正是因为我们没有声明 <code>b</code> 是有符号数。Verilog 默认其为无符号数，当 <code>b</code> = -1 时，其补码为 4’b1111，会被认为是 15。<br>将比较代码修改为 <code>assign res = $signed(a) &gt; $signed(b);</code>，程序即可达到预期结果。</p><p>值得一提的是，假如将比较代码修改为 <code>assign res = a &gt; $signed(b);</code>，得到的结果也达不到预期效果。</p><p>在对无符号数和符号数同时操作时，Verilog 会自动地做数据类型匹配，将符号数向无符号数转化。因为在执行 <code>a &gt; $signed(b)</code> 时，<code>a</code> 是无符号数，<code>$signed(b)</code> 是符号数，Verilog 默认向无符号类型转化，得到的结果仍是无符号数的比较结果。</p><p>关于符号数和无符号数的原理，您可参考<a href="https://cscore.e1.buaa.edu.cn/tutorial/verilog/verilog-3/verilog-3-7/#_3">这里</a>。简单地概括，<ins>一个表达式，只要其子表达式中有任一表达式是无符号，则该表达式就是无符号的</ins>。</p><h3 id="一些注意事项">一些注意事项</h3><ul class="lvl-0"><li class="lvl-2"><p>对于<ins>移位运算符</ins>，其<ins>右侧的操作数总是被视为无符号数</ins>，并且<ins>不会对运算结果的符号性产生任何影响</ins>。结果的符号由运算符左侧的操作数和表达式的其余部分共同决定。</p></li><li class="lvl-2"><p>对于<ins>三目运算符</ins>，其 <code>?</code> 前的布尔表达式是自决定的表达式，不会对最外层表达式的符号造成影响。</p></li><li class="lvl-2"><p>算术右移在<ins>左操作数无符号时</ins>高位仍然补 <ins>0</ins>，与逻辑右移效果相同。</p></li><li class="lvl-2"><p>未指定位宽和进制的 0 的有无符号性是根据上下文决定的。而指定了位宽和进制的 0（比如 4’b0000）的符号是确定的。</p></li></ul><h2 id="宏定义">宏定义</h2><p>宏定义格式如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> WORDSIZE 8</span></span><br><span class="line"><span class="comment">// 省略模块定义</span></span><br><span class="line"> <span class="keyword">reg</span>[<span class="number">1</span>:`WORDSIZE] data;</span><br><span class="line"><span class="comment">// 相当于定义 reg[1:8] data;</span></span><br></pre></td></tr></table></figure><p>定义时，需要以反引号（<code>`</code>）开头。使用时，也需要加上反引号。</p><h1 id="Verilog-例题">Verilog 例题</h1><h2 id="电梯调度">电梯调度</h2><h3 id="简介">简介</h3><p>一栋大楼有一部运行的电梯，你需要根据乘客请求和电梯状态来输出。</p><h3 id="电梯的具体信息">电梯的具体信息</h3><ul class="lvl-0"><li class="lvl-2"><p>在最开始或者每次 reset 后，电梯默认初始楼层为一楼。保证在输入到来前先进行 reset。</p></li><li class="lvl-2"><p>初始运行方向：每次 reset 后，电梯默认向上运行。</p></li><li class="lvl-2"><p>运行范围：1 至 7 层。</p></li><li class="lvl-2"><p>调度规则：</p><ul class="lvl-2"><li class="lvl-6">如果当前周期没有乘客请求 (乘客请求详细信息见下文)，则电梯将会按照当前的运行方向运动一层，并在下一周期更新楼层；如果位于边界楼层且运行方向越界，则反转运行方向并运动一层。</li><li class="lvl-6">如果当前周期有乘客请求，且乘客请求楼层与当前电梯所在楼层不相同，则电梯将会向乘客请求楼层方向移动一层，并在下一周期更新楼层，电梯运行方向也调整为向乘客请求楼层运行的方向 (若与原来方向一致则不用调整) 。</li><li class="lvl-6">如果当前周期有乘客请求，且乘客请求楼层与当前电梯所在楼层相同，则电梯将保持不动，并在下一周期维持楼层，电梯运行方向不改变。</li></ul></li></ul><h3 id="乘客请求">乘客请求</h3><ul class="lvl-0"><li class="lvl-2"><p>存在乘客请求的条件：</p><ul class="lvl-2"><li class="lvl-6">若 from = 0 并且<ins>不存在未完成的乘客请求</ins>，则视为当前周期没有乘客请求。反之，如果 from != 0 或者+存在未完成的乘客请求++，则视为当前周期有乘客请求。</li><li class="lvl-6">若 from != 0，则视为当前周期有新到来的乘客请求。该乘客请求将会一直存在直到满足取消条件 ( 即使后续周期 from = 0 ) ，在此期间内视为：存在一个未完成的乘客请求。</li><li class="lvl-6">若 from = 0 并且<ins>存在一个未完成的乘客请求</ins>，则该乘客请求继续存在直至满足取消条件。</li></ul></li><li class="lvl-2"><p>取消乘客请求的条件：</p><ul class="lvl-2"><li class="lvl-6">若当前周期的乘客请求楼层和电梯的当前所在楼层相同，则视为满足该请求的取消条件，在下一个周期开始时取消该请求。</li><li class="lvl-6">若当前周期有 reset 信号，则在下一周期取消该乘客请求。</li></ul></li><li class="lvl-2"><p>其他规则：输入数据保证在上一个乘客请求满足取消条件之前，不会输入下一个乘客请求。 也就是当 from != 0 时，当前一定不存在未完成的乘客请求。</p></li></ul><h3 id="输出要求">输出要求</h3><p>当乘客请求楼层和电梯的当前所在楼层相同时，输出 1 ；否则输出 0 。</p><h3 id="样例">样例</h3><p><img src="/posts/c9f56abd/elevator.png" alt="样例"><br>如图，在 reset 后电梯默认从一楼向上运行。<br>在电梯运行到三楼时，输入了一楼的乘客请求，于是下个周期电梯向乘客请求楼层 (一楼) 方向运行，回到了二楼。然后再下个周期电梯到了一楼，此时电梯楼层和乘客请求楼层相同，因此输出 out 置为 1 ,同时下个周期电梯保留楼层和运行方向。再下个周期输入为 0，电梯掉头向上运行，同时取消上一个乘客请求。</p><p>当电梯继续运行到五楼时，输入了同层五楼的乘客请求，输出 out <ins>立刻</ins>置为 1 ，同时下一周期电梯保留原楼层和运行方向，同时取消乘客请求。再下个周期输入为 0，电梯正常向上运行至六楼。</p><div class="warning"><p>请认真阅读波形图，一切逻辑以波形图所示为准！</p></div><h3 id="分析">分析</h3><p>本题适合用时序逻辑来解决。按照题意，在没有乘客请求的时候，电梯全自动运行，故首先我们需要解决这个问题。我们应当维护两个变量，它们分别是当前的楼层和电梯运行方向，记作 <code>cur_floor</code> 和 <code>direction</code>。简单起见，由于楼层只有七层，可以用一个 3 位二进制数表示（001 至 111），方向则用 0 和 1 表示上与下，简略代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span><span class="comment">//初始化在一楼，向上</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset == <span class="number">1</span>) <span class="keyword">begin</span><span class="comment">//reset逻辑</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="number">0</span>) <span class="keyword">begin</span><span class="comment">//上</span></span><br><span class="line">            <span class="keyword">if</span> (cur_floor == <span class="number">3&#x27;b111</span>) <span class="keyword">begin</span><span class="comment">//顶楼</span></span><br><span class="line">                direction &lt;= <span class="number">1</span>;</span><br><span class="line">                cur_floor &lt;= cur_floor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span><span class="comment">//未到顶楼</span></span><br><span class="line">                cur_floor &lt;= cur_floor + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span><span class="comment">//下</span></span><br><span class="line">            ...<span class="comment">//类似逻辑</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果有乘客请求，其实有两种情况需要考虑：</p><ul class="lvl-0"><li class="lvl-2"><p>当 <code>from</code> 信号出现的时候，电梯尚未到该楼层。</p></li><li class="lvl-2"><p>当 <code>from</code> 信号出现的时候，电梯已经到该楼层。</p></li></ul><p>如果电梯还没到，则需要想办法保存下这个乘客请求的楼层号，然后及时调整电梯运行方向。当某个上升沿确认 <code>cur_floor</code> 等于 <code>from</code> 的楼层（当然这个 <code>from</code> 是一个副本，因为 <code>from</code> 输入可能只持续一个周期就归零了，接下来将把这个副本叫做 <code>request</code>）时，让下一个周期保持运行方向和楼层不变。<ins>这是样例中 30ns 时发出 1 楼请求的情况</ins>。可以看到，45ns 的上升沿电梯刚好到 1 楼，同时 <code>request</code> 等于 <code>cur_floor</code>，<code>out</code> 置为 1，下一个周期（55ns - 65ns）电梯保持在 1 楼。</p><p>如果发出乘客请求时，电梯正好处于该楼层，则情况稍微会复杂些。按照样例的解释（一切逻辑以样例为准！），100ns 发出 5 楼的请求，此时时钟信号正处于<ins>下降沿</ins>，而 <code>out</code> 被<ins>立刻</ins>置为 1。很明显 <code>out</code> 的输出采用的组合逻辑的 <code>assign</code> 语句，一检测到 <code>from</code> 或 <code>request</code> 与 <code>cur_floor</code> 相匹配就立刻置为 1（对于第一种情况，当然是检测 <code>request</code> 的信号，第二种则是 <code>from</code>）。再看电梯停留在 5 楼的时间。105ns 时电梯本准备往 6 楼去，而实际上停留在 5 楼，这就说明 105ns - 115ns 是电梯停留的一周期。也就是说，95ns - 105ns 发生了 <code>cur_floor</code> 和 <code>from</code> 的判定，即在第二种情况下判定并不是发生在上升沿的，而是立即判定！</p><p>我们如果想要电梯停留在某一层一个周期，可以这样写：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) <span class="keyword">begin</span></span><br><span class="line">    cur_floor &lt;= cur_floor;</span><br><span class="line">    direction &lt;= direction;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>无论怎么说，使用非阻塞赋值就决定了这一逻辑一定会在某个上升沿激活。对于第一种情况，我们可以大胆地让 <code>cur_floor == request</code> 作为条件，根据“乘客请求-其他规则”，<code>request</code> 尚未解决时不会有新的 <code>from</code> 出现。可以预见的是一定会在某个上升沿满足条件，然后下一个上升沿执行上述的等待逻辑。对于第二种情况，则大有不同了，接受 <code>from</code> 信号后将其赋给 <code>request</code> 必定也使用非阻塞赋值，那么 <code>request</code> 的赋值要等到 <code>from</code> 信号来临的下一个上升沿，即二者会出现一定的时间差。这对于 <code>out</code> 的输出，以及电梯的等待，都是不可接受的。具体到样例中，如果接到 <code>from</code> 信号后立刻赋给 <code>request</code>，那么 105ns 时 <code>request</code> 才会被置为 1。如果还用 <code>cur_floor == request</code> 作为条件，5 楼的等待时间将会延长到 115ns - 125ns 周期，这就错了。而且 <code>out</code> 与 <code>from</code> 和 <code>request</code> 挂钩，如果在 <code>request</code> 已经被赋值（105ns），再用条件判断将其归零，也许要等到下一个上升沿（115ns），这样， <code>out</code> 就会从 100ns 一直激活到 115ns。</p><p>总的来说，面对第二种情况，等待逻辑的判定条件必须是 <code>cur_floor == from</code>，而且如果满足该条件，就要立刻发出 <code>request</code> 归零的命令，让 <code>request</code> 赶在下一个上升沿（105ns）就归零，相当于“反悔给 <code>request</code> 赋值”（这样做从波形上来看，<code>request</code> 不会被赋值，因为赋值和归零都是在上升沿以外的地方进行的），避免 <code>out</code> 激活时间过长。</p><h1 id="Verilog-工程的设计开发调试">Verilog 工程的设计开发调试</h1><h2 id="编写可综合代码">编写可综合代码</h2><div class="warning"><p>以下规则不适用于 Testbench。</p></div><ul class="lvl-0"><li class="lvl-2"><p>勿使用 Initial 块、勿为 Reg 型（寄存器）赋初值。</p></li><li class="lvl-2"><p>一个寄存器只能在<ins>一个</ins> <code>always</code> 块中赋值<ins>一次</ins>。<br>以下代码不可综合：</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> a;</span><br><span class="line"><span class="keyword">wire</span> b, c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_1) <span class="keyword">begin</span></span><br><span class="line">    a &lt;= b;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_2) <span class="keyword">begin</span></span><br><span class="line">    a &lt;= c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>实际上，Reg 型一般会被综合为 D 触发器，只有一个时钟输入，而上述代码让该触发器处于两个时钟域中。</p><p>何谓赋值一次？如果使用 <code>if</code> / <code>else</code> / <code>case</code> 语句进行条件判断，在不同且互斥的情况下对同一个寄存器进行赋值，是完全合法的。而其他情况是不可被综合的。</p><ul class="lvl-0"><li class="lvl-2"><p>尽量避免综合后的奇怪故障</p></li></ul><ol><li class="lvl-3"><p>在时序逻辑中，永远使用非阻塞赋值（<code>&lt;=</code>）；在组合逻辑中，永远使用阻塞赋值（<code>=</code>）；</p></li><li class="lvl-3"><p>每个组合逻辑运算结果仅在一个 <code>always @(*)</code> 中修改；</p></li><li class="lvl-3"><p>在 <code>always @(*)</code> 中，为每个运算结果赋初值，避免 latch 的产生。</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/Verilog/">Verilog</category>
      
      <category domain="https://samuflore.top/tags/ISE/">ISE</category>
      
      
      <comments>https://samuflore.top/posts/c9f56abd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CO Pre]One-Hot 编码</title>
      <link>https://samuflore.top/posts/9707d4af/</link>
      <guid>https://samuflore.top/posts/9707d4af/</guid>
      <pubDate>Tue, 19 Aug 2025 14:06:21 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;独热编码&lt;/strong&gt;（One-Hot Encoding），又称&lt;strong&gt;一位有效编码&lt;/strong&gt;，是一种将分类变量转换为数值形式的常用方法。其核心思想是，将一个具有 N 个不同类别的分类特征转换为 N 个二元（0 或 1）特征，其中每个新特征对应原始特征中的一个类别。对于每一个样本，只有代表其原始类别的那个新特征值为 1，其余所有新特征值均为0。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p><strong>独热编码</strong>（One-Hot Encoding），又称<strong>一位有效编码</strong>，是一种将分类变量转换为数值形式的常用方法。其核心思想是，将一个具有 N 个不同类别的分类特征转换为 N 个二元（0 或 1）特征，其中每个新特征对应原始特征中的一个类别。对于每一个样本，只有代表其原始类别的那个新特征值为 1，其余所有新特征值均为0。</p><span id="more"></span><h1 id="原来的问题">原来的问题</h1><p>对于一个人，ta 会具有多种属性，比如性别、职业、国籍等等。现在假设有一组人的样本，他们的属性在如下范围内：</p><ul class="lvl-0"><li class="lvl-2"><p>性别：男、女</p></li><li class="lvl-2"><p>职业：医生、律师、程序员、学生</p></li><li class="lvl-2"><p>国籍：中国、美国、法国</p></li></ul><p>如果将上述属性用数字进行表示，会更有利于计算机处理，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;男&quot;, &quot;医生&quot;, &quot;中国] -&gt; [0, 0, 0]</span><br><span class="line">[&quot;女&quot;, &quot;程序员&quot;, &quot;法国&quot;] -&gt; [1, 2, 2]</span><br></pre></td></tr></table></figure><p>但是，这是不适合机器学习的。<br>在机器学习中，许多算法，特别是线性模型（如线性回归、逻辑回归）和距离度量相关的算法（如K近邻），都是基于数值计算的。如果直接将“医生”、“律师”、“程序员”用数字0、1、2来表示（这种方法称为标签编码 Label Encoding），模型可能会错误地学习到这些类别之间存在有序关系。比如“程序员”是“律师”的 2 倍，这是荒谬的。</p><p>因此，我们需要新的方法。</p><h1 id="One-Hot-编码">One-Hot 编码</h1><p>对于性别这一属性，二者天然是互斥的，所以我们可以用一个二维向量来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 0] 男</span><br><span class="line">[0, 1] 女</span><br></pre></td></tr></table></figure><p>对于职业，则可以用四维向量来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 0, 0, 0] 医生</span><br><span class="line">[0, 1, 0, 0] 律师</span><br><span class="line">[0, 0, 1, 0] 程序员</span><br><span class="line">[0, 0, 0, 1] 学生</span><br></pre></td></tr></table></figure><p>独热编码通过将每个类别独立表示为一个特征，完美地解决了这个问题。每个类别都处于一个正交的向量空间中，它们（例如 [1, 0, 0]、[0, 1, 0] 和 [0, 0, 1]）之间的距离是相等的，从而消除了标签编码可能引入的虚假顺序关系，让模型能够更准确地学习特征与目标之间的关系。<br>正如其名“One-Hot”，在每一行数据中，只有一个新特征是“热”的（值为 1）。</p>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/CO-Pre/">CO Pre</category>
      
      <category domain="https://samuflore.top/tags/One-Hot-Encoding/">One-Hot Encoding</category>
      
      
      <comments>https://samuflore.top/posts/9707d4af/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CO Pre]Logisim 入门</title>
      <link>https://samuflore.top/posts/e7ebcfa7/</link>
      <guid>https://samuflore.top/posts/e7ebcfa7/</guid>
      <pubDate>Thu, 14 Aug 2025 14:53:54 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Logisim 部分。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Logisim 部分。</p><span id="more"></span><hr><h1 id="什么是-Logisim？">什么是 Logisim？</h1><blockquote><p>Logisim 是一款非常优秀的用于数字电路设计与仿真的教育软件。它提供了丰富的电路库与元件的抽象表示，生成的电路图也比较美观，还提供了时序的模拟功能，能够让我们对 CPU 的结构和运行情况有更直观的理解，并且在开发一些小电路时还有一些其他辅助功能。<br><a href="https://cscore.e1.buaa.edu.cn/tutorial/logisim/logisim-1/logisim-1-1/">为什么要学习 Logisim？</a></p></blockquote><h1 id="这里有什么？">这里有什么？</h1><ul class="lvl-0"><li class="lvl-2"><p>Logisim 门电路</p></li><li class="lvl-2"><p>Logisim 组合电路</p></li><li class="lvl-2"><p>Logisim 时序电路</p></li><li class="lvl-2"><p>Logisim 仿真与调试</p></li><li class="lvl-2"><p>应用与挑战</p></li></ul><h1 id="Logisim-门电路">Logisim 门电路</h1><h2 id="界面认识">界面认识</h2><p>打开 Logisim 后，我们会看到如下的界面：<br><img src="/posts/e7ebcfa7/logisim%E7%95%8C%E9%9D%A2.png" alt="界面"><br>Logisim 提供图形界面，可以通过长按拖动的形式新建部件以及进行连线。也可通过 <code>Ctrl + D</code> 快速部署选中的部件。</p><h2 id="元件概览">元件概览</h2><h3 id="Wirings（线路）">Wirings（线路）</h3><p><img src="/posts/e7ebcfa7/wiring.png" alt="wiring"></p><p><a id="tunnel"></a></p><h4 id="Tunnel（隧道）">Tunnel（隧道）</h4><p>​Tunnel 部件是在整个 Logisim 实验中简化电路布线复杂度效果最好的一个部件，可以让你在纷繁复杂的接线中解脱出来，让你能够更加专心的关注于各个部件的设计，而不被复杂的接线所打扰。<br>​Tunnel 名为隧道，即它可以将标签<strong>相同</strong> Tunnel 之间的数据，通过一个不可见的“隧道”进行传输，在使用过程中，可以链接数据的输入端和输出端，使得数据可以方便简单的传输。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p><img src="/posts/e7ebcfa7/Tunnel.png" alt="Tunnel"></p><p>拥有不同标签的 Tunnel 之间，数据传输是独立的。</p><h4 id="Probe（探针）">Probe（探针）</h4><p>​Probe 作为一个显示线路数据值的部件，可以对多位宽数据进行实时监控，简而言之，就是可以直接显示接线的数值，并且不影响整个电路的运行。<br>Probe 有点类似于输出引脚，可以显示数值，它可以显示<strong>多位宽数据</strong>。</p><p><img src="/posts/e7ebcfa7/Probe.png" alt="Probe"></p><p><a id="splitter"></a></p><h4 id="Splitter（分叉器）">Splitter（分叉器）</h4><p>​Splitter 是一个多路分叉器，可以将一个数据输入端分成多个输出端，可以将数据进行分流，使得数据可以分别处理。每条岔路都会注明数据来源的<strong>位编号</strong>，位编号从 0 开始，对应数据源最靠右的位，例如：</p><p><img src="/posts/e7ebcfa7/Splitter.png" alt="Splitter"></p><p>要注意，Splitter 分流后，数据的位宽会相应的发生改变，因此输出引脚的位宽也需要改变。</p><div class="note info">            <p>Splitter 的输出引脚也可以当输入来用，这时，原先的输入引脚会输出此时输入的数据的组合（按照位次顺序）。</p>          </div><h4 id="Bit-Extender（位扩展）">Bit Extender（位扩展）</h4><p>Bit Extender 有三个主要的参数：</p><ul class="lvl-0"><li class="lvl-2"><p><code>Bit Width In</code>：输入数据的位宽</p></li><li class="lvl-2"><p><code>Bit Width Out</code>：输出数据的位宽</p></li><li class="lvl-2"><p><code>Extension Type</code>：扩展方式，包括 <code>Zero</code>, <code>One</code>, <code>Sign</code>, <code>Input</code>。</p></li></ul><p>当输入数据的位宽<strong>小于</strong>输出数据的位宽时，Bit Extender 保留全部输入数据，然后补充内容使得输出数据位宽达到要求。</p><ul class="lvl-0"><li class="lvl-2"><p>若 <code>Extension Type</code> 为 <code>Zero</code>，则补充 0。</p></li><li class="lvl-2"><p>若 <code>Extension Type</code> 为 <code>One</code>，则补充 1。</p></li><li class="lvl-2"><p>若 <code>Extension Type</code> 为 <code>Sign</code>，则补充符号位<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p></li></ul><p>当输入数据的位宽<strong>大于</strong>输出数据的位宽时，Bit Extender 从低到高截取需要的位数，其余的舍弃。</p><p><img src="/posts/e7ebcfa7/BE.png" alt="BE"></p><h4 id="Clock（时钟）">Clock（时钟）</h4><p>在 Simulate 菜单中开启 Ticks Enabled 选项，Clock 会自动经历周期，释放信号。<br>Clock 可以指定 <code>High Duration</code> 和 <code>Low Duration</code>，分别表示高电平持续时间和低电平持续时间。单位为 <code>Tick(s)</code>。</p><p><img src="/posts/e7ebcfa7/Clock.png" alt="Clock"></p><div class="note info">            <p>Logisim 对时钟的模拟是理想状态的：在实际电路中，多个时钟会相互漂移，并且永远不会同步移动。 但在 Logisim 中，所有时钟都以相同的速率经历滴答声。</p>          </div><p><a id="circle"></a><br>Clock 的周期：</p><p><img src="/posts/e7ebcfa7/Clock2.png" alt="Clock2"></p><h3 id="Gates（门）">Gates（门）</h3><p><img src="/posts/e7ebcfa7/gate.png" alt="gate"></p><h4 id="Odd-Parity（奇校验）">Odd Parity（奇校验）</h4><p>奇校验门和异或门在<ins>两个输入端</ins>时表现相同。但是如果有<ins>超过两个</ins>指定的输入，异或门将在刚好++只有一个 1 <ins>的时候输出 1。而奇校验门在</ins>奇数个 1 ++输入时就会输出 1。<br><img src="/posts/e7ebcfa7/OP.png" alt="OP"></p><p>第一列和第二列均为奇数个 1，则输出端的第一列和第二列均为 1。</p><div class="note info">            <p>这与异或门的 <code>Multiple-Input Behavior</code> 字段选择 <code>When an odd number are on</code> 是一致的，而其默认选项是 <code>When one input is on</code> （只有一个 1 时输出 1）。</p>          </div><h4 id="Even-Parity（偶校验）">Even Parity（偶校验）</h4><p>偶校验门在输入端有偶数个 1 时输出 1，否则输出 0。<br><img src="/posts/e7ebcfa7/EP.png" alt="EP"></p><h3 id="Plexers（复用器）">Plexers（复用器）</h3><p><img src="/posts/e7ebcfa7/plexer.png" alt="plexer"></p><h4 id="Multiplexer-MUX-（多路选择器）">Multiplexer(MUX)（多路选择器）</h4><p>在组合电路中，多路选择器（Multiplexer，简称 MUX）是非常重要的一类部件，他们在组合电路中扮演着非常重要的角色。下图是一个典型的 Logisim 中的多路选择器，左侧是多个输入，右侧是相应的输出，通过底部（黑色）的选择信号，对输入的信号进行选择后输出。另外一个端口是部件的使能端，当其为高电平（为 1）时，整个部件使能工作。</p><p><img src="/posts/e7ebcfa7/MUX.png" alt="MUX"></p><p>选择信号：当 <code>Select Bits</code> 字段为 n 时，选择信号的位宽为 n，此时输入引脚有 2<sup>n</sup> 个。选择信号的值表示选择<ins>要输出的输入信号的位次</ins>，自上而下，从 0 开始。</p><h4 id="Demultiplexer-DMX-（多路分配器）">Demultiplexer(DMX)（多路分配器）</h4><p>多路分配器和多路选择器功能恰好相反，即能够将 1 个输入数据，根据需要传送到多个输出端的任何一个输出端。</p><p><img src="/posts/e7ebcfa7/DMX.png" alt="DMX"></p><p>选择信号：当 <code>Select Bits</code> 字段为 n 时，选择信号的位宽为 n，此时输出引脚有 2<sup>n</sup> 个。选择信号的值表示选择要<ins>把输入信号复制到第几个输出引脚上</ins>，自上而下，从 0 开始。</p><h4 id="Decoder（译码器）">Decoder（译码器）</h4><p>如下图，右侧是多个输出，底部是黑色的选择信号与使能端。译码器最大的功能在于将二进制编码转换为相应的<a href="https://samuflore.top/posts/9707d4af/">独热码（one-hot）</a>，如 101 的 3 位二进制编码作为输入就会被转换成 00100000 的 8 位独热码作为输出。因而该元件得名译码器。</p><p><img src="/posts/e7ebcfa7/decd.png" alt="decd"></p><p>译码器与多路选择器不同之处有两点：</p><ol><li class="lvl-3"><p>除选择信号外，多路选择器是多输入，单输出，输出取决于输入与选择信号，译码器则是无输入，多输出，输出模式仅取决于选择信号。</p></li><li class="lvl-3"><p>译码器输出位宽每个信号仅一位，多路选择器可以有多位。</p></li></ol><h4 id="Bit-Selector（位选择器）">Bit Selector（位选择器）</h4><p>Bit Selector 有两个重要的参数：</p><ul class="lvl-0"><li class="lvl-2"><p><code>Data Bits</code>: 输入数据的位宽</p></li><li class="lvl-2"><p><code>Output Bits</code>: 输出数据的位宽<br>Bit Selector 有两个输入：data 和 dist。其中，dist 宽度为 ⌈log<sub>2</sub>(⌈data / <code>Output Bits</code>⌉)⌉。<br>一个输出为 <code>Output Bits</code> 位宽。<br>Bit Selector 根据输出数据的位宽将输入数据等分成若干段，每段为 <code>Output Bits</code> 位宽。然后根据 <code>dist</code> 指定的编号从低到高选出需要的段并输出。</p></li></ul><p><img src="/posts/e7ebcfa7/BS.png" alt="BS"></p><h3 id="Arithmetic（运算器）">Arithmetic（运算器）</h3><p><img src="/posts/e7ebcfa7/arithmetic.jpg" alt="arithmetic"></p><h4 id="Negator（取反）">Negator（取反）</h4><p>Negator 是一个单输入的运算器。名曰取反，实则求补。即<strong>取反加一</strong>。<br><img src="/posts/e7ebcfa7/negator.png" alt="negator"></p><h4 id="Shifter（移位）">Shifter（移位）</h4><p>Shifter 含有两个输入，data 和 dist，它有一个输出，这是根据 dist 位移动数据的结果。data 和输出具有相同的位宽。</p><div class="note warning">            <p>data 的位宽和 dist 的位宽需要满足下述数学关系：<br>dist = ⌈log<sub>2</sub>data⌉</p>          </div>  <p>Shifter 支持以下几种移位方式：</p><ul class="lvl-0"><li class="lvl-2"><p>Logical Left（逻辑左移）: 数据中的所有位向左移动 dist 位，底部空出的位用 0 填充。例如，11001011逻辑左移两次就是00101100（之前的右边两位丢弃）。</p></li><li class="lvl-2"><p>Logical Right（逻辑右移）: 数据中的所有位向右移动 dist 位，左端空出的位用 0 填充。例如，11001011逻辑右移两次就是00110010（之前的左边两位丢弃）。</p></li><li class="lvl-2"><p>Arithmetic Right（算术右移）: 数据中的所有位向右移动 dist 位，左端空出的位用数据中<strong>最高位</strong>重复填充。例如，11001011算术右移两次就是11110010（之前最高位为 1，所以用 1 填充）。</p></li><li class="lvl-2"><p>Rotate Left（循环左移）:   数据中的所有位都向左移动 dist 位，左边被“挤出去”的位填充到右边空出的位。例如，将11001011循环左移两次就是00101111。</p></li><li class="lvl-2"><p>Rotate Right（循环右移）:  数据中的所有位都向右移动 dist 位，右边被“挤出去”的位填充到左边空出的位。例如，将11001011循环右移两次就是11110010。</p></li></ul><p><img src="/posts/e7ebcfa7/shifter.png" alt="shifter"></p><div class="note info">            <p><a href="https://blog.csdn.net/Hi_KER/article/details/121049347">本小节摘自 CSDN</a></p>          </div><h4 id="Bit-Finder（位查找）">Bit Finder（位查找）</h4><p>Bit Finder 有一个 n 位宽的输入，有一个 1 位宽的输出，表示在输入中是否找到对应的值。对于 n 位的输入，Bit Finder 有一个 ⌈log<sub>2</sub>n⌉ 位宽的输出表示找到的值的编号。<br>Bit Finder 有一个 <code>Type</code> 参数：</p><ul class="lvl-0"><li class="lvl-2"><p>Lowest-order 1: 自<strong>最低位</strong>开始查找 1</p></li><li class="lvl-2"><p>Highest-order 1: 自<strong>最高位</strong>开始查找 1</p></li><li class="lvl-2"><p>Lowest-order 0: 自<strong>最低位</strong>开始查找 0</p></li><li class="lvl-2"><p>Highest-order 0: 自<strong>最高位</strong>开始查找 0</p></li></ul><div class="tips"><p>无论何种查找方式，返回的都是绝对位次，即从右往左数从 0 开始的位次。</p></div><p><img src="/posts/e7ebcfa7/BF.png" alt="BF"></p><h4 id="Adder（加法）">Adder（加法）</h4><p>Adder 将两个左端输入值数学相加，并在右端输出结果。</p><p><img src="/posts/e7ebcfa7/Adder.png" alt="Adder"></p><h4 id="Subtractor（减法）">Subtractor（减法）</h4><p>Subtractor 将两个左端输入值数学相减，并在右端输出结果。</p><p><img src="/posts/e7ebcfa7/Subtractor.png" alt="Subtractor"></p><div class="warning"><p>差值为负，则结果为其补码。</p></div><h4 id="Bit-Adder（位加法）">Bit Adder（位加法）</h4><p>Bit Adder 计算输入中有多少位是 1，并输出为 1 的位的数量。对于 n 位的输入，Bit Adder 有一个 ⌈log<sub>2</sub>n⌉ 位宽的输出表示 1 的位的数量。</p><div class="warning"><p>Bit Adder 可以指定至多 32 个输入。此时 n<sub>总</sub> 为所有输入的 n 之和。</p></div><p><img src="/posts/e7ebcfa7/BA.png" alt="BA"></p><h4 id="Comparator（比较）">Comparator（比较）</h4><p>Comparator 比较两个值（无符号值或两个补码值，可选）的大小。Comparator 有 3 个输出，通常，其中一个输出为1，另外两个输出为0。</p><p><img src="/posts/e7ebcfa7/Comparator.png" alt="Comparator"></p><h3 id="Memory（存储）">Memory（存储）</h3><p><img src="/posts/e7ebcfa7/memory.png" alt="memory"></p><h4 id="Register（寄存器）">Register（寄存器）</h4><p>Register 存储单个多位值，该值以<ins>十六进制</ins>形式显示在其矩形内，并在其输出端输出。当时钟信号输入满足 Register 触发条件时，存储在 Register 中的值就会在该时刻改变为 D 输入的值。时钟信号指示 Register 储存值发生改变的确切条件是通过触发属性配置的，Logisim 中一般有时钟<strong>上升沿</strong>和<strong>下降沿</strong>，<strong>高电平</strong>和<strong>低电平</strong>这四种触发方式。</p><p>使能信号：使能信号输入为 1 时，Register 开始工作，输入信号 D 有效。使能信号输入为 0 时，Register 停止工作，输入信号 D 无效。</p><p><img src="/posts/e7ebcfa7/Register.png" alt="Register"></p><p>Reset（复位）输入异步地将 Register 的值重置为0（全部为0），也就是说，只要 Reset 为 1，Register 的值就固定为 0，不管时钟和输入是什么。</p><p>关于四种触发方式在周期的位置，请看<a href="#circle">此处</a></p><h4 id="RAM（随机存取存储器）">RAM（随机存取存储器）</h4><div class="warning"><p>在我们的实验中，我们采用的是读与写相互分离的类型，所以在选择 RAM 时，请将数据接口选择为 <code>Separate load and store ports</code>。</p></div><p>RAM 组件是 Logisim 内置库中最复杂的组件，最多可存储 16,777,216 个值（在 地址位宽度/Address Bit Width 属性中指定），每个值最多可包含 32 位（在 数据位宽度/Data Bit Width 属性中指定）。RAM 可加载和存储数据。此外，用户可以通过 Poke 工具 (Poke Tool) 交互修改单个值，或者可以通过 菜单工具 (Menu Tool) 修改整个内容。<br>储存的数据值在组件中显示。地址以灰色字体形式陈列在显示区域的左边。在内部，每个值都使用十六进制格式列出。当前选定地址的值将以反色（白字黑底）显示。</p><p><img src="/posts/e7ebcfa7/RAM.png" alt="RAM"></p><div class="note info">            <p>除了 clr(Clear, 为 1 时复位整个 RAM) 信号和时钟信号，sel(Chip Select, 选择生效的 RAM，即电路中同时刻只有一个 RAM 可用), str(Store, 为 1 时允许在时钟信号为高电平时将 D 输入信号写入 RAM), ld(Load, 为 1 时允许在时钟信号为高电平时从 RAM 中读取数据) 在没有输入的情况下均默认为 1。</p>          </div><h4 id="ROM（只读存储器）">ROM（只读存储器）</h4><p>ROM 组件最多可以存储 16,777,216 个值(在地址位宽度属性中指定)，每个值最多可以包含32 位(在 数据位宽度/Address Bit Width 属性中指定)。电路可以访问 ROM 中的储存值，但不能改变它们。用户可以通过 Poke 工具交互修改单个值，或者用户可以通过菜单工具修改整个内容。<br>与 RAM 组件不同，ROM 组件的当前内容是作为组件的属性存储的。因此，如果一个包含ROM 组件的电路被使用了两次，这两个 ROM 组件都持有相同的值。也因为这种行为，ROM 的数据存储在 Logisim 创建的文件中。<br>当前值显示在组件中。显示的地址以灰色显示在显示区域的左边。在内部，每个值都使用十六进制列出。当前选定地址的值将以相反的文本(白底黑)显示。</p><p><img src="/posts/e7ebcfa7/ROM.png" alt="ROM"></p><div class="note info">            <p>ROM 的数据是存储在本地的，以一个 .txt 形式。内含非零地址及其值，第一行固定为 <code>v2.0 raw</code>。</p>          </div><h3 id="I-O（输入输出）">I/O（输入输出）</h3><p><img src="/posts/e7ebcfa7/io.png" alt="io"></p><h3 id="Base（基本组件）">Base（基本组件）</h3><p><img src="/posts/e7ebcfa7/base.png" alt="base"></p><h2 id="一位全加器">一位全加器</h2><p>一位全加器由两个输入 A 和 B，一个进位输入 Cin，一个输出 S，一个进位输出 Cout 组成。全加器的表达式为：<br><code>S = A ^ B ^ Cin; Cout = A &amp; B | Cin &amp; (A ^ B);</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><br>对于 S 的运算，我们可以作出：<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><br><img src="/posts/e7ebcfa7/S.png" alt="S">利用已有的运算结果，进一步搭建整个电路：<br><img src="/posts/e7ebcfa7/Full.png" alt="Full"></p><p><a id="swap"></a></p><h2 id="Swap-电路">Swap 电路</h2><p>现在需要你使用基础的门电路搭建这样一个电路，当输入 S 为 0（低电平）时，输出 O1 等于输入 I1，输出 O2 等于输入 I2。当输入 S 为 1（高电平）时，则交换两输出，即输出 O2 等于输入 I1，输出 O1 等于输入 I2。我们给它取名叫做 swap 电路。</p><h3 id="提交要求">提交要求</h3><p><strong>用 Logisim 完成 swap 电路</strong></p><ul class="lvl-0"><li class="lvl-2"><p>文件内模块名：<code>swap</code></p></li><li class="lvl-2"><p>输入：<code>I1</code>(1 bit), <code>I2</code>(1 bit), <code>S</code>(1 bit)</p></li><li class="lvl-2"><p>输出：<code>O1</code>(1 bit), <code>O2</code>(1 bit)</p></li><li class="lvl-2"><p><strong>注意：请从门级电路开始搭建，切勿使用 Plexers 类元件。</strong></p></li><li class="lvl-2"><p><strong>测试电路图（我们将使用下方的电路对你搭建的电路进行测试，测试的原理是将下图的 swap 模块替换为你提交文件中的 swap 模块，随后测试机会仿真运行下图中的电路图，记录其输出并与正确的输出进行对比）</strong></p></li></ul><p><img src="/posts/e7ebcfa7/test.png" alt="test"></p><p>模块样式：</p><p><img src="/posts/e7ebcfa7/swap_circuit.png" alt="swap_circuit"></p><h3 id="解">解</h3><p><strong>答案</strong><br><img src="/posts/e7ebcfa7/swap.png" alt="swap"></p><p><strong>分析</strong><br>如果 S 为 0 且 I1 为 1，则 O1 为 1，若 I1 为 0，则 O1 为 0。显然，这需要一个与门来实现。<br><img src="/posts/e7ebcfa7/swap1.png" alt="swap1"></p><p>对于 I2 与 O2，是与前者一样的逻辑<br><img src="/posts/e7ebcfa7/swap2.png" alt="swap2"></p><p>如果 S 为 1，则 I1 与 I2 的值交换再赋给 O1 与 O2。对于 I1 而言，首先必须获取其值，然后传递给 O2。由于 S 是 1，则让 S 和 I1 通过与门。考虑到 I2 到 O2 和 I1 到 O2 不会同时为 1，则将两个与门的输出用一个或门连接，再输出到 O2 即可。<br><img src="/posts/e7ebcfa7/swap3.png" alt="swap3"><br><img src="/posts/e7ebcfa7/swap4.png" alt="swap4"></p><p>到 O1 的线路如法炮制即可。</p><div class="note warning">            <p>在打包成模块时，注意按要求调整 S, I1, I2, O1, O2 的位置。<br>注意按要求命名。</p>          </div><h1 id="Logisim-组合电路">Logisim 组合电路</h1><h2 id="子电路">子电路</h2><h3 id="子电路使用流程">子电路使用流程</h3><ol><li class="lvl-3"><p>创建子电路：通过 Project 栏下的 Add Circuit；</p></li><li class="lvl-3"><p>添加子电路内容；</p></li><li class="lvl-3"><p>设置外观；</p></li><li class="lvl-3"><p>引用。</p></li></ol><p>譬如 Swap 电路，若将其封装成子电路，则可以设计出双重交换电路 2Swap。</p><p><img src="/posts/e7ebcfa7/2swap.png" alt="2swap"><br><img src="/posts/e7ebcfa7/2swap1.png" alt="2swap1"><br><img src="/posts/e7ebcfa7/2swap2.png" alt="2swap2"></p><h2 id="Wire-Bundle（线束）">Wire Bundle（线束）</h2><p><img src="/posts/e7ebcfa7/wires.png" alt="wires">​对于一个完整且正确的电路，是以深绿色，浅绿色，黑色接线构成，绿色接线可以通过深浅直接判断出取值，而黑色接线，并不能直接反映出取值，这里建议大家使用 Wiring 库中的 Probe 元器件，可以对多位数据实时显示监控。</p><p><a id="analyze"></a></p><h2 id="利用-Logisim-进行组合逻辑分析">利用 Logisim 进行组合逻辑分析</h2><p>​Logisim 中具有逻辑分析的功能，可以实现组合电路，真值表，布尔表达式三者间的两两转换。<br>​打开组合逻辑分析模块的方式：</p><ol><li class="lvl-3"><p>Window 栏目下的 Combinational Analysis;</p></li><li class="lvl-3"><p>Project 栏目下的 Analyze Circuit;</p></li></ol><p>​组合逻辑分析模块，可根据逻辑表达式得到相应的真值表。我们也可以通过输入真值表，再产生相应的表达式，或者产生相应的电路。其中真值表的选值有：0，1，x（浮动）。<br><img src="/posts/e7ebcfa7/analysis.png" alt="analysis"></p><p>并且在生成电路时，我们也可以勾选下列生成电路的附加约束：</p><ul class="lvl-0"><li class="lvl-2"><p>Use Two-Input Gates Only 只使用二输入门电路；<br><img src="/posts/e7ebcfa7/2-input.png" alt="2-input"></p></li><li class="lvl-2"><p>Use NAND Gates Only 只使用与非门；<br><img src="/posts/e7ebcfa7/nand.png" alt="nand"></p></li></ul><h2 id="排序电路（4bit-sort）">排序电路（4bit_sort）</h2><p>在前面的学习过程中，我们搭建了一个 1 位的 swap 电路。现在需要我们使用之前的 1 位 swap 电路来搭建一个 4 位 4 输入的排序电路。</p><h3 id="要求">要求</h3><p>先使用 1 位的 swap 搭建 4 位的 swap，再使用 4 位的 swap 模块和 Logisim 内置的 comparator 元件搭建排序电路（请不要使用 Plexers 类元件）。</p><ul class="lvl-0"><li class="lvl-2"><p>功能描述: 该电路具有 4 个 4 位的二进制数字作为输入和 4 个 4 位的二进制数字作为输出。它的功能是，将 4 个输入的二进制数字进行排序，从上往下数第一个输出端口输出的是 4 个数字中最小的，第二个输出端口输出的是第二小的，以此类推。</p></li><li class="lvl-2"><p>输入： A, B, C, D (4 bit)</p></li><li class="lvl-2"><p>输出： #1, #2, #3, #4 (4 bit)（#1 对应第一个输出端口，以此类推）</p></li><li class="lvl-2"><p>文件内 1 位 swap 模块名：<code>1bit_swap</code></p></li><li class="lvl-2"><p>文件内 4 位 swap 模块名：<code>4bit_swap</code></p></li><li class="lvl-2"><p>文件内排序电路模块名：<code>4bit_sort</code></p></li><li class="lvl-2"><p>Hint: 所有的二进制数字均看做是无符号的。</p></li></ul><h3 id="解-2">解</h3><p>1 位 swap 电路可以参考<a href="#swap">这里</a>。<br>要构建 4 位 swap 电路，其实就是把 4 bit 输入拆分成四个 1 bit 输入，然后分别交给 1 位 swap 电路，再将四个 1 bit 输出连接起来即可。拆分，也就是使用 Splitter 元件，交换后再用 Splitter 连接起来。有关 Splitter 您可参考<a href="#splitter">这里</a>。</p><p><img src="/posts/e7ebcfa7/4bit_swap.png" alt="4bit_swap"></p><div class="warning"><p><strong>注意</strong><br>图中已封装好的模块是 1 位 swap 模块 <code>1bit_swap</code>。</p></div><div class="note info">            <p>您可使用 Tunnel 元件简化电路。关于 Tunnel 元件您可参考<a href="#tunnel">这里</a>。</p>          </div><p>如何实现排序呢？我们可以使用<a href="https://www.runoob.com/w3cnote/bubble-sort.html">冒泡排序（Bubble Sort）</a>来完成。对于 A, B, C, D 四个输入，我们可以先比较 A 和 B 的大小，由于要求从小到大输出，那么如果 A &gt; B，则交换 A 和 B，然后比较 A 和 C，如果 A &gt; C，则交换 A 和 C，以此类推，直到比较完所有四个输入。每个输入都会与另三各完成一次比较，从而得到四者的顺序。此处我们可以充分利用 Tunnel 元件，将一次比较的结果传递给下次比较的输入。</p><p><img src="/posts/e7ebcfa7/4bit_sort.png" alt="4bit_sort"></p><div class="warning"><p><strong>注意</strong><br>图中已封装好的模块是 4 位 swap 模块 <code>4bit_swap</code>。</p></div><p>每轮比较，若结果为大于，则 Comparator 输出 1，该信号作为使能信号激活 <code>4bit_swap</code> 模块，将输入的二者交换。完成后，其结果用新的 Tunnel 传递给之后的比较轮次。</p><h1 id="Logisim-时序电路">Logisim 时序电路</h1><h2 id="SR-锁存器（SR-Latch）">SR 锁存器（SR Latch）</h2><div class="note warning">            <p>部分内容选自<a href="https://zhuanlan.zhihu.com/p/1938209046684505714">知乎</a>。</p>          </div><p>我们先来讲解一种简单的电路——SR 锁存器（SR latch），它由两个交叉耦合的或非门（或者，等价地，两个反置输入的与非门）组成，整个电路的状态可以由 S（Set）和 R（Reset）输入来决定，对应得到两个相反的输出 Q 和 ~Q，它的真值表如下：</p><p><img src="/posts/e7ebcfa7/SR1.jpg" alt="SR1"></p><p>一种电路如下：<br><img src="/posts/e7ebcfa7/NOR-SR.png" alt="NOR-SR"></p><div class="tips"><p>Q 为 1 而 ~Q 为 0 时被称为锁存器的 1 状态，Q 为 0 而 ~Q 为 1 时被称为锁存器的 0 状态。</p></div><p>其中 S<sub>D</sub> 和 R<sub>D</sub> 为是电路输入的两个端口，Q<sup>n</sup> 表示电路当前的输出，Q<sup>n+1</sup> 表示电路下一个状态的输出。由真值表可以看出，这个电路的输出不仅和当前输入有关，也和上一次的输出有关。<br>观察它的功能一栏，可以看到，通过改变 S<sub>D</sub> 和 R<sub>D</sub> 为合适的值，我们可以改变电路的输出，而当 S<sub>D</sub> 和 R<sub>D</sub> 为均为 0 时，电路会一直保持原来的输出不变，这看上去很像 U 盘之类的设备（通电时能够修改存储的内容，断电时保持内容不变）。事实上，通过配合合适的外部电路，我们就可以使用这个电路来存储整个电路的状态，从而搭建起更复杂的时序电路。</p><div class="note info">            <p>简单来说，初始情况下 S 和 R 均为 0，按下 S 键，锁存器将进入 1 状态(Set)。此时，无论 S 如何变化，锁存器的输出都将不变。因为锁存器已经被设置成 1 了。再按下 R 键，锁存器重置（Reset），输出变为 0。无论 R 如何变化，锁存器的输出都将不变。因为锁存器已经被重置了。0 重置 仍然是 0。</p>          </div><p>由于复位和置位都是输入端为 1 才发生，故这种 SR 锁存器叫做<ins>高电平有效的SR锁存器</ins>。</p><p>还有一种<ins>低电平有效的SR锁存器</ins>，它的输入端 S 和 R 均为低电平有效。真值表如下：</p><p><img src="/posts/e7ebcfa7/SR2.jpg" alt="SR2"></p><p>它的电路如下：</p><p><img src="/posts/e7ebcfa7/NAND-SR.png" alt="NAND-SR"></p><h2 id="D-锁存器（D-Latch）">D 锁存器（D Latch）</h2><p>D 锁存器是最常用于在数字系统中存储数据的逻辑电路。它基于 SR 锁存器，但没有“未定义”或“无效”状态问题。</p><p><img src="/posts/e7ebcfa7/D_latch.png" alt="D_latch"></p><div class="warning"><p><strong>注意</strong><br>图中封装的电路是<ins>高电平有效的SR锁存器</ins>。</p></div><p>D 锁存器有两个输入 D 和 E，其中 E 是使能信号。当 E 为 1 时，D 锁存器将 D 输入的值存储在 Q 中，随着 D 变化而变化。当 E 为 0 时，D 锁存器保持当前的 Q 值不变。即锁存 D 输入的值。</p><div class="note info">            <p>E 也可以看作是 CLK 时钟信号。此时 D 锁存器将<ins>时间</ins>输入和<ins>数据</ins>输入明确的分隔开，而 SR 锁存器是没有区分的。<br>当 CLK 为 1 时，D 锁存器是透明的（transparent），数据 D 通过 D 锁存器流向 Q。当 CLK 为 0 时，D 锁存器是不透明的（opaque），其阻塞新数据流向 Q，Q 保持原值不变。</p>          </div><h2 id="D-触发器（D-Flip-Flop）">D 触发器（D Flip-Flop）</h2><p>D 触发器由反相时钟控制的两个 D 锁存器组成。分别为主锁存器（Master）和从锁存器（Slave）。<br>CLK 为 0 时，主锁存器透明，从锁存器不透明，D 流向从锁存器但无法流入，保持在二者连线处。CLK 为 1 时，主锁存器不透明，从锁存器透明，数据流向 Q，但新的输入无法流入主锁存器。<br>也就是说，D 触发器只会在时钟上升沿将 D 复制到 Q，在其他时间段保持原来的状态。</p><p><img src="/posts/e7ebcfa7/D_FF.png" alt="D_FF"></p><h2 id="有限状态机（FSM）">有限状态机（FSM）</h2><h3 id="有限状态机的定义和行为">有限状态机的定义和行为</h3><h4 id="有限状态机的构成和基本性质">有限状态机的构成和基本性质</h4><p>有限状态机（Finite State Machine，FSM）又称有限自动状态机，它拥有有限数量的状态，每个状态代表不同的意义，每个状态可以切换到 零-多 个状态。任意时刻状态机有且只能处在一个状态。</p><div class="note info">            <p><strong>数学定义</strong><br>构成一个有限状态机的六元组为：状态集合，输入集合，输出集合，状态转移函数，输出函数，初始状态。给定以上六个集合，函数或元素，就可以确定一个有限状态机。</p>          </div><p>据此，有限状态机具有以下特征：</p><ul class="lvl-0"><li class="lvl-2"><p>在任何时间点，状态、输入、输出均为<ins>给定的有限种情况之一</ins>。</p></li><li class="lvl-2"><p>对于一对确定的当前状态和输入，只有一个<ins>固定且唯一</ins>的次态（下一个周期的状态）。</p></li><li class="lvl-2"><p>对于一对确定的当前状态和输入，只有一种<ins>固定且唯一</ins>的输出情况。</p></li></ul><h4 id="有限状态机的时序行为">有限状态机的时序行为</h4><p>状态转移行为可以描述成如下过程：</p><ul class="lvl-0"><li class="lvl-2"><p>当第 0 周期开始，状态设定为 state<sub>0</sub>。</p></li><li class="lvl-2"><p>第 n 周期结束的瞬间，记此时刻输入为 input<sub>n</sub>。</p></li><li class="lvl-2"><p>每当第 n 周期结束，第 n + 1 周期开始时，状态变为状态转移函数给出的次态：state<sub>n+1</sub> = F<sub>next</sub>(state<sub>n</sub>, input<sub>n</sub>)。</p></li></ul><h3 id="Moore-和-Mealy-状态机的区别">Moore 和 Mealy 状态机的区别</h3><p>区分状态机类型时：当<ins>输出函数的结果会随 input 变化而改变时</ins>，该状态机为 <ins>Mealy 机</ins>，<ins>否则为 Moore 机</ins>。</p><p><img src="/posts/e7ebcfa7/FSM.png" alt="FSM"></p><h2 id="2n-mod-5">2<sup>n</sup> mod 5</h2><h3 id="要求-2">要求</h3><p>使用 Logisim 搭建电路，该电路串行输入一个二进制无符号数 B（先从高位输入，每输入一个数字就相当于之前输入的数左移一位再加上当前输入的数字），输出 “2 的 B 次幂” 模 5 的余数的电路并提交。</p><ul class="lvl-0"><li class="lvl-2"><p>输入： In（1bit 串行输入）</p></li><li class="lvl-2"><p>输出：S<sub>0</sub>, S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>, S<sub>4</sub> （独热编码，S<sub>x</sub> 为 1 时表示 2<sup>In</sup> ≡ x (mod 5)）</p></li><li class="lvl-2"><p>文件内模块名: mod5</p></li><li class="lvl-2"><p>状态机类型: Mealy 型有限状态机</p></li><li class="lvl-2"><p>注意：切勿使用内置算术器件（如加法器、除法器等）！请搭建有限状态机！</p></li><li class="lvl-2"><p>样例：输入输出样例中每一行表示相邻上升沿之间的<ins>开区间时间内</ins>的输入和期望输出。<br><img src="/posts/e7ebcfa7/mod5_example.png" alt="mod5_example"></p></li></ul><h3 id="解-3">解</h3><p>题目要求使用有限状态机来搭建，且由于输入和输出有关，是 Mealy 型状态机。<br>首先要确定状态集合。2 的幂次方模 5 所产生的余数其实只有 1 到 4，也就是说只有四种状态。我们可以用 2 位的二进制数来表示状态：</p><table><thead><tr><th>状态</th><th>余数</th></tr></thead><tbody><tr><td>00</td><td>0</td></tr><tr><td>01</td><td>1</td></tr><tr><td>10</td><td>2</td></tr><tr><td>11</td><td>3</td></tr></tbody></table><p>不难发现，1 % 5 = 1, 2 % 5 = 2, 4 % 5 = 4, 8 % 5 = 3, 16 % 5 = 1……即余数以 4 为周期进行循环。若把被除数写成二进制形式，并观察其末二位，则会发现有这样的规律：</p><table><thead><tr><th>余数</th><th>状态</th><th>末二位</th><th>被除数</th></tr></thead><tbody><tr><td>1</td><td>00</td><td>00</td><td>2<sup>0</sup></td></tr><tr><td>2</td><td>01</td><td>01</td><td>2<sup>1</sup></td></tr><tr><td>4</td><td>11</td><td>10</td><td>2<sup>2</sup></td></tr><tr><td>3</td><td>10</td><td>11</td><td>2<sup>3</sup></td></tr></tbody></table><p>现在，要改变状态，我们会进行一次输入，考察这次输入引起的变化：末二位左移一次，输入值填补在低位。输入只有 1 和 0 两种情况，而现在状态有 4 种，因此我们可以枚举出共计 8 种可能的情况：</p><div class="warning"><p>接下来，现在状态的第一位称为 ST1，第二位为 ST2；次态的第一位称为 ST1’，第二位为 ST2’；输入称为 IN；余数称为 S0 到 S4。</p></div><p>状态转移表如下：</p><table><thead><tr><th>ST1</th><th>ST2</th><th>IN</th><th>ST1’</th><th>ST2’</th><th>S0</th><th>S1</th><th>S2</th><th>S3</th><th>S4</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><div class="tips"><p>可以看出 S0 恒为 0。</p></div><p>根据 Mealy 型状态机的结构图，我们需要构建三个部分：状态转移逻辑、输出逻辑和寄存器。其顶层结构如下：<br><img src="/posts/e7ebcfa7/mod5.png" alt="mod5"></p><p>寄存器保存的是<ins>现态</ins>。在上升沿以外的时间段，可以把整个状态机的行为拆分成两步：</p><ol><li class="lvl-3"><p>现态从 Q 流向状态转移逻辑 <code>Trans</code>，和 In 一起决定次态的值。但是由于时间在上升沿以外，次态滞留在寄存器外，无法改变其值。</p></li><li class="lvl-3"><p>现态从 Q 流向输出逻辑 <code>Out</code>，和 In 一起决定输出的值。</p></li></ol><p>当时间来到上升沿，滞留的次态值进入寄存器，完成状态的转移。然后在下一个上升沿到来前，重复上述的 1 和 2 步。</p><div class="tips"><p>这正好满足了样例说的“每一行表示相邻上升沿之间的<ins>开区间时间内</ins>的输入和期望输出”，因为输出这一步骤就是在两个上升沿之间完成的。</p></div><p>状态转移逻辑和输出逻辑的实现，最简单的步骤就是根据状态转移表，使用 Logisim 的 <a href="#analyze">Analyze Circuit</a> 功能来自动生成即可。</p><h2 id="斐波那契数列">斐波那契数列</h2><h3 id="要求-3">要求</h3><p>使用 Logisim 搭建一个根据输入序号 x 计算对应序号斐波那契数 F<sub>x</sub> 的电路并提交。</p><ul class="lvl-0"><li class="lvl-2"><p>F<sub>0</sub> = 0, F<sub>1</sub> = 1, F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub> (n ≥ 2)</p></li><li class="lvl-2"><p>输入：N (3bit)</p></li><li class="lvl-2"><p>输出：Nth(4bit)</p></li><li class="lvl-2"><p>文件内模块名: main</p></li><li class="lvl-2"><p>测试要求：每次给定一个固定输入保持不变，电路在 64 个周期内计算出结果并稳定输出，在结果未计算出之前输出端口输出 0。</p></li></ul><h3 id="解-4">解</h3><h4 id="计数逻辑">计数逻辑</h4><p>要知道第 x 号斐波那契数的值，我们可以从 0 号和 1 号开始，依次计算斐波那契数，直至第 x 号时停止并输出。那么要算多少次呢？如果我们以 0 号和 1 号开始，每一个时钟周期计算一次的话，那么第一个周期算出 2 号，第二个周期算出 3 号……并且，还需要花掉一个上升沿去<ins>初始化</ins>寄存器的值，计数器达到需求时，又需等下一个上升沿才能输出结果。若要求 2 号斐波那契数，计数逻辑到第 3 个上升沿时就会发出停止运算并输出的信号。而第 1 个上升沿被用来初始化，第 2 个上升沿算出 2 号，到第 3 个上升沿算出 3 号，输出的结果就是 3 号斐波那契数了，并不符合我们的需求。因此我们可以往前推一位，以 -1 号和 0 号开始。</p><div class="tips"><p>F<sub>-1</sub> = 1, F<sub>0</sub> = 0。</p></div><p>这样，第 x 号斐波那契数需要 x 个时钟周期才能算出。换言之，当第 x 个时钟周期结束时，已经算出了第 x 号斐波那契数。而下一个时钟周期的上升沿，必须停止计次，然后输出数字，否则会多算一次。<br>控制运算次数的逻辑可以使用一个计数器（Counter）和一个比较器（Comparator）来实现。计数器从 0 开始，每到一个上升沿加 1。也就是说 x 个时钟周期结束时，计数器的值为 x，在下一个上升沿到来时，传递一个信号（output_signal）给运算斐波那契数的逻辑，令其做完运算后立刻输出结果，并且将结果锁定在寄存器中。每个上升沿，用比较器比较计数器的值和 N 的值，若计数器的值小于等于 N，则 output_signal 为 0，否则为 1。</p><div class="tips"><p>由于输入格式是 3bit，若计数器的位宽也设置成 3bit，则会在边界情况下失效。比如输入为 111，第七个周期时，计数器的值为 111。在下一个上升沿到来时，计数器的值要么回到 000，要么保持 111，始终无法让其大于输入值，output_signal 始终为 0。因此，需要设置计数器的位宽比输入值多 1 位。然后使用 Bit Extender 把输入扩展到 4bit。</p></div><div class="warning"><p>比较器的 Numeric Type 参数必须设定为 <code>Unsigned</code> 即无符号数比较。若为 <code>2's Complement</code> 即补码比较，则 output_signal 会逆转。</p></div><p><img src="/posts/e7ebcfa7/time_control.png" alt="time_control"></p><h4 id="运算逻辑">运算逻辑</h4><p>回到运算斐波那契数的逻辑。由于每个斐波那契数的值只与其前两个值（prev, cur）有关，每次算出新值 = prev + cur，可以用 cur 覆盖 prev，然后用新值覆盖 cur，以此类推就可以持续计算下去。这些步骤在上升沿完成。核心逻辑如下：</p><p><img src="/posts/e7ebcfa7/fib_cal.png" alt="fib_cal"></p><p>在上升沿以外的时刻，Cur 值流向 Prev 寄存器，但无法进入，滞留在线路中。同时 Prev 和 Cur 值在 Adder 中相加，得出下一个斐波那契数，流向 Cur 寄存器，也无法进入，滞留在线路中。<br>在上升沿，Cur 值进入 Prev 寄存器，并覆盖原有值，同时新的斐波那契数进入 Cur 寄存器，覆盖掉原有值。也就是说，最新的斐波那契数保存在 Cur 寄存器中，并且是每个上升沿到来时更新一次。</p><p>如何初始化两个寄存器呢？由于 F<sub>-1</sub> = 1, F<sub>0</sub> = 0，因此我们要把 Prev 寄存器的值设为 1，而 Cur 寄存器默认为零。我们用一个 Maximum Value 为 <code>1</code> 的<ins>计数器</ins>来实现。利用到计数器有一个 Carry 输出，当计数器达到最大值时，Carry 输出为 1，否则为 0。再搭配一个二选一 MUX，0 号输入为想要的初始值，1 号输入则是 Cur 隧道。这样就实现了如下效果：</p><ul class="lvl-0"><li class="lvl-2"><p>第一个上升沿到来前，MUX 选择初始值，但无法进入 Prev 寄存器，滞留在线路中。</p></li><li class="lvl-2"><p>第一个上升沿到来时，初始值进入 Prev 寄存器，实现初始化。MUX 选择 Cur 隧道值。</p></li></ul><p><img src="/posts/e7ebcfa7/init1.png" alt="init1"><br><img src="/posts/e7ebcfa7/init2.png" alt="init2"></p><h4 id="锁定斐波那契数">锁定斐波那契数</h4><p>很简单，传入 output_signal，当其为 1 时表示已经算出了所求的，让其通过非门，然后传给两个寄存器的使能信号端口即可。</p><h4 id="稳定输出">稳定输出</h4><p>在找到要求的斐波那契数前，输出 Nth 要求保持为 0。可以用一个二选一 MUX，0 号输入为 0，1 号输入为 Cur 隧道值。传入 output_signal，当其为 1 时自然就输出了 Cur 寄存器中保存的值。</p><p>整个运算逻辑如下：<br><img src="/posts/e7ebcfa7/fib_cal2.png" alt="fib_cal2"></p><p>顶层电路如下：<br><img src="/posts/e7ebcfa7/fibonacci.png" alt="fibonacci"></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Tunnel 需要增加标签以区分不同的数据。并且每个标签只允许有一个输入，输出的数量不做限制。但是在有较多 Tunnel 部件的时候，要特别留意标签的名字，防止出现混乱。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>将输入数据的最高位视为符号位，扩展的数值全为符号位的值。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>优先级：<code>&amp;</code> &gt; <code>^</code> &gt; <code>|</code> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>Logisim 画布上，高亮代表此线路的真值为 1，不高亮代表此线路的真值为 0。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/Logisim/">Logisim</category>
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/CO-Pre/">CO Pre</category>
      
      
      <comments>https://samuflore.top/posts/e7ebcfa7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>加密文章测试</title>
      <link>https://samuflore.top/posts/7e709353/</link>
      <guid>https://samuflore.top/posts/7e709353/</guid>
      <pubDate>Thu, 14 Aug 2025 04:59:28 GMT</pubDate>
      
      <description>此處已加密</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密碼錯誤，請重試。" data-whm="哈希錯誤，您可繼續查看之。">  <script id="hbeData" type="hbeData" data-hmacdigest="e51da5b86cbbc76e46e127f10949edd09b362ac81c170ab7e01736f04b5aa8c8">e55adbd63f533766c9f21930da64422ba895a6bdbe5300133465591509dc5c39</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">此處輸入密碼</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      
      
      <comments>https://samuflore.top/posts/7e709353/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CO Pre]原码、反码与补码</title>
      <link>https://samuflore.top/posts/908cc5fb/</link>
      <guid>https://samuflore.top/posts/908cc5fb/</guid>
      <pubDate>Wed, 13 Aug 2025 16:10:54 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;计组 Pre 开始了，但是我把上学期学的内容都忘了（&lt;br&gt;
所以先从&lt;strong&gt;数制&lt;/strong&gt;开始吧。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>计组 Pre 开始了，但是我把上学期学的内容都忘了（<br>所以先从<strong>数制</strong>开始吧。</p><span id="more"></span><hr><h1 id="机器数">机器数</h1><p>一个数在计算机中的二进制表示形式被称为<strong>机器数</strong>。<br>机器数是有符号的，计算机中将机器数的最高位（最左边）称为符号位，用以表示符号。0 表示正数，1 表示负数。</p><hr><h1 id="真值">真值</h1><p>机器数的<strong>真值</strong>是指该机器数对应的实际数值。<br>对于一个有符号数，它的机器数未必等于它本身。<br>譬如十进制数 -7，它的机器数为 10000111，但 10000111 如果当作二进制表示，对应的十进制数是 135。故 -7 的机器数的真值应该是 00000111。</p><hr><h1 id="原码">原码</h1><p><strong>原码</strong>就是<strong>符号位</strong>和<strong>真值</strong>的组合。即用最高位表示符号，其余位表示数字大小。</p><ul class="lvl-0"><li class="lvl-2"><p>[+1]原码：0000 0001</p></li><li class="lvl-2"><p>[-1]原码：1000 0001</p></li></ul><hr><h1 id="反码">反码</h1><p><strong>反码</strong>的表示方法如下：</p><ul class="lvl-0"><li class="lvl-2"><p>正数的反码是其原码本身。</p></li><li class="lvl-2"><p>负数的反码将其原码的符号位不变，其余各位<strong>按位取反</strong>。<br>比如：</p></li><li class="lvl-2"><p>[+1]反码：0000 0001</p></li><li class="lvl-2"><p>[-1]反码：1111 1110</p></li></ul><hr><h1 id="补码">补码</h1><p><strong>补码</strong>的表示方法如下：</p><ul class="lvl-0"><li class="lvl-2"><p>正数的补码是其原码本身。</p></li><li class="lvl-2"><p>负数的补码是其反码加 1。</p></li></ul><div class="warning"><p><strong>注意</strong><br>加 1 指的是二进制加法，注意进位。</p></div><p>比如：</p><ul class="lvl-0"><li class="lvl-2"><p>[+1]补码：0000 0001</p></li><li class="lvl-2"><p>[-1]补码：1111 1111</p></li></ul><hr><h1 id="为什么要这么复杂？">为什么要这么复杂？</h1><p>数字存储在计算机中，是需要用来运算的。根据四则运算的性质，人们只需要解决<strong>加法</strong>的运算方法就可以了。<br>可是，对于人脑而言，进行有符号数的加法是很简单的，因为大家都能一眼看出数字的符号，再根据符号决定运算。对于计算机而言，倘若要模拟人的运算，就必须拥有识别符号的能力，这无疑是增加了复杂度。<br>于是聪明的人们就想到了把符号位也纳入运算中。</p><h2 id="原码运算">原码运算</h2><p>大家都知道，1 - 1 = 0。<br>如果使用原码运算，那么 1 - 1 = 1 + (-1) = 0000 0001 + 1000 0001 = 1000 0010。<br>按照原码的定义，这显然等于 -2。因此，原码是不行的。</p><h2 id="反码运算">反码运算</h2><p>仍然是 1 - 1 = 0 这个问题。<br>1 - 1 = 1 + (-1) = 0000 0001[反码] + 1111 1110[反码] = 1111 1111[反码] = 1000 0000[原码] = -0。<br>-0，人们都知道 0 和 -0 是一样的，可如果使用反码运算，-0 和 0 就成了两个数。如果用 -0 和 0 分别进行一些运算：</p><ul class="lvl-0"><li class="lvl-2"><p>-0 + 1 = 1111 1111[反码] + 0000 0001[反码] = 1 0000 0000[反码]<br>对于反码的加法运算，倘若位数溢出，则需要把溢出的位数依次补到末尾，称之为<strong>循环进位</strong>。<br>故 1 0000 0000[反码] = 0000 0001[反码] = 0000 0001[原码] = 1。</p></li><li class="lvl-2"><p>0 + 1 = 0000 0000[反码] + 0000 0001[反码] = 0000 0001[反码] = 0000 0001[原码] = 1。</p></li></ul><p>可见，反码的运算是繁琐而有歧义的，问题就出在 0 和 -0 的区分上。</p><h2 id="补码运算">补码运算</h2><p>1 - 1 = 1 + (-1) = 0000 0001[补码] + 1111 1111[补码] = 1 0000 0000[补码]<br>补码运算中，没有循环进位，溢出位舍弃。<br>故 1 0000 0000[补码] = 0000 0000[补码] = 0000 0000[原码] = 0。<br>补码中是没有 0 和 -0 的区分的：0 就是 0000 0000，而 1000 0000 则被用来表示 -128。</p><div class="tips"><p><strong>为什么是 -128？</strong><br>-1 + (-127) = 1111 1111 + 1000 0001 = 1000 0000 = -128。</p></div><p>补码是可以解决问题的。</p><hr><p>关于原码、反码和补码的数学原理探讨，您可参考<a href="https://zhuanlan.zhihu.com/p/118432554">这篇文章</a>。</p>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E6%88%90%E5%8E%9F%E7%90%86/">計算機組成原理</category>
      
      
      <category domain="https://samuflore.top/tags/CO/">CO</category>
      
      <category domain="https://samuflore.top/tags/CO-Pre/">CO Pre</category>
      
      <category domain="https://samuflore.top/tags/Sign-Magnitude/">Sign-Magnitude</category>
      
      <category domain="https://samuflore.top/tags/Ones-Complement/">Ones&#39; Complement</category>
      
      <category domain="https://samuflore.top/tags/Two-s-Complement/">Two&#39;s Complement</category>
      
      
      <comments>https://samuflore.top/posts/908cc5fb/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Blog 9：[Hexo]Hexo NexT 自定义字体</title>
      <link>https://samuflore.top/posts/ec5f1055/</link>
      <guid>https://samuflore.top/posts/ec5f1055/</guid>
      <pubDate>Sat, 09 Aug 2025 12:37:06 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;三种方法为 Hexo NexT 主题自定义字体。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天我才发现我的 NexT 主题是过时已久的 7.x 版本。尝试更新到 8.x，发现变了许多，便决定继续用旧版本了。&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>三种方法为 Hexo NexT 主题自定义字体。</p><blockquote><p>今天我才发现我的 NexT 主题是过时已久的 7.x 版本。尝试更新到 8.x，发现变了许多，便决定继续用旧版本了。</p></blockquote><span id="more"></span><hr><h1 id="从-Google-Fonts-引用">从 Google Fonts 引用</h1><p>在<strong>站点配置文件</strong> <code>_config.yml</code> 中，搜索 <code>font</code> 字段，您将看到以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> </span><br></pre></td></tr></table></figure><p><code>host</code> 字段处指定字体的来源，默认使用 Google Fonts。</p><div class="tips"><p><s>由于不可抗力</s>，您可使用 Google Fonts 的镜像站来确保访问速度。例如 <code>https://fonts.loli.net</code>。</p></div><p>引用的字体可以分派到五个部分：<strong>全局默认</strong>、<strong>网站标题</strong>、<strong>博文标题</strong>、<strong>博文正文</strong>、<strong>内嵌代码和代码块</strong>。</p><div class="warning"><p>由于 <code>Yaml</code> 语法限制，此处您每个字段只能指定一种字体。</p></div><p><code>family</code> 字段指定字体的名称。譬如 <code>Noto Serif SC</code>（思源宋体简体中文）。<br>但是，如果您需要中西文分两种字体，这显然是无法满足要求的。</p><hr><h1 id="修改-Stylus-样式文件">修改 Stylus 样式文件</h1><div class="warning"><p>下文中将出现两个名为 <code>base.styl</code> 的不同文件，敬请注意区分。</p></div><p>首先我们必须知道是什么文件在控制 NexT 主题各元素的样式。<br>在 <code>themes\next\source\css\_common\scaffolding\base.styl</code> 文件中，我们可以看到类似这样的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="variable">$font</span>-family-headings;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这是用来指定 <code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code> 标签的样式的。于是我们就知道这是用来控制 NexT 主题样式的文件。注意到，这里有一个 <code>font-family</code> 字段。Stylus 是为 Node.js 构建的 CSS 预处理器，因此它具有 CSS 的性质。所以这里可以指定多种字体。我们只需在 <code>$font-family-headings</code> 前加西文字体的指定即可，比如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Times New Roman, <span class="variable">$font</span>-family-headings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就为西文指定了 Times New Roman。</p><div class="tips"><p>先指定西文字体，再指定中文字体，以确保中文字体的拉丁字符不会替换西文字体的字形。</p></div><p>可是什么是 <code>$font-family-headings</code> 呢？<br>打开 <code>themes\next\source\css\_variables\base.styl</code> 文件，我们可以看到：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Font families.</span></span><br><span class="line"><span class="variable">$font</span>-family-chinese      = <span class="string">&quot;PingFang SC&quot;</span>, <span class="string">&quot;Microsoft YaHei&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-base         = <span class="variable">$font</span>-family-chinese, sans-serif;</span><br><span class="line"><span class="variable">$font</span>-family-base         = <span class="built_in">get_font_family</span>(<span class="string">&#x27;global&#x27;</span>), <span class="variable">$font</span>-family-chinese, sans-serif <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;global&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-logo         = <span class="variable">$font</span>-family-base;</span><br><span class="line"><span class="variable">$font</span>-family-logo         = <span class="built_in">get_font_family</span>(<span class="string">&#x27;title&#x27;</span>), <span class="variable">$font</span>-family-base <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-headings     = <span class="variable">$font</span>-family-base;</span><br><span class="line"><span class="variable">$font</span>-family-headings     = <span class="built_in">get_font_family</span>(<span class="string">&#x27;headings&#x27;</span>), <span class="variable">$font</span>-family-base <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;headings&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-posts        = <span class="variable">$font</span>-family-base;</span><br><span class="line"><span class="variable">$font</span>-family-posts        = <span class="built_in">get_font_family</span>(<span class="string">&#x27;posts&#x27;</span>), <span class="variable">$font</span>-family-base <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;posts&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$font</span>-family-monospace    = consolas, Menlo, monospace, <span class="variable">$font</span>-family-chinese;</span><br><span class="line"><span class="variable">$font</span>-family-monospace    = <span class="built_in">get_font_family</span>(<span class="string">&#x27;codes&#x27;</span>), consolas, Menlo, monospace, <span class="variable">$font</span>-family-chinese <span class="keyword">if</span> <span class="built_in">get_font_family</span>(<span class="string">&#x27;codes&#x27;</span>);</span><br></pre></td></tr></table></figure><p>原来，<code>$font-family-headings</code> 是一个变量，它先获取 <code>_config.yml</code> 中 <code>font</code> 字段的 <code>headings</code> 设置。如果没有，则使用 <code>$font-family-base</code> 作为默认值。后者获取 <code>_config.yml</code> 中 <code>font</code> 字段的 <code>global</code> 设置。如果没有，则缺省为最通用的<strong>苹方</strong>和<strong>微软雅黑</strong>。</p><p>所以，您如果希望正文中的西文字体是 Times New Roman，而中文是 Noto Serif SC，就可以在 <code>_config.yml</code> 中设置 <code>posts</code> 字段字体为 <code>Noto Serif SC</code>，然后在 <ins>控制样式</ins> 的 <code>base.styl</code> 的 <code>body</code> 处指定 <code>font-family</code> 为 <code>Times New Roman, Noto Serif SC</code>。其余也类似。</p><div class="warning"><p>像上述方法在 Stylus 中指定字体时，只填写字体名称的，当浏览网页之设备有该字体时才能正常显示。如果没有，则会显示为默认字体。</p></div><p>如果需要指定的字体在任何设备上都能正常显示，又该如何呢?</p><hr><h1 id="使用-font-face">使用 <code>@font-face</code></h1><h2 id="原始方法">原始方法</h2><p>关于 <code>@font-face</code>，您可参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">这里</a>。<br>它的格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Open Sans&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>:</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&quot;/fonts/OpenSans-Regular-webfont.woff2&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;woff2&quot;</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&quot;/fonts/OpenSans-Regular-webfont.woff&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;woff&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>font-family</code> 字段可以自定义字体的名称方便后续使用。<code>src</code> 字段指定字体文件的路径，既可以是本地路径也可以是网络路径。<code>format</code> 字段指定字体文件的格式，譬如 TTF。简单来说，您通过它可以自定义一个字体以供使用。</p><p>故您可以将一些字体文件上传到云端，然后以相对路径的形式引用，这样就能在任何设备上都能正常显示。在 <code>themes\next\source</code> 目录下新建一个 <code>fonts</code> 文件夹，然后将字体文件放入其中。然后在 <ins>控制样式</ins> 的 <code>base.styl</code> 文件中，在 <code>font-family</code> 字段前加上 <code>@font-face</code>，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Mozilla Headline&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;../fonts/MozillaHeadline-Regular.otf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tips"><p>为什么是 <code>../fonts/</code>？Hexo 博客在编译时，默认会将 <code>source</code> 目录下的所有文件复制到 <code>public</code> 目录下。所有样式会被编译到 <code>public\css</code> 目录下。对于 CSS 文件而言，OTF 文件自然是<strong>上级目录</strong>的 fonts 文件夹下的文件了。</p></div><p>然后再在 <ins>控制样式</ins> 的 <code>base.styl</code> 的 <code>body</code> 处指定 <code>font-family</code> 为 <code>Mozilla Headline, Noto Serif SC</code>。这样，所有设备都会在加载网页时加载 MozillaHeadline-Regular.otf 字体文件，然后应用样式。<br>可是，这是最优解吗？</p><p>2009 年，Web 开放字体格式出现并发展。现在正由万维网联盟的 Web 字体工作小组标准化，以求成为推荐标准。此字体格式不但能够有效利用压缩来减少档案大小，并且不包含加密也不受 DRM（数位著作权管理）限制。WOFF 本质上是包含了基于 sfnt 的字体（如 TrueType、OpenType 或开放字体格式），且这些字体均经过 WOFF 的编码工具压缩，以便嵌入网页中。这个字体格式使用zlib压缩，文件大小一般比 TTF 小 40%<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>如果能用上 WOFF 或 WOFF2 格式，岂不美哉？</p><h2 id="现代方法">现代方法</h2><p>只要能弄到 WOFF 或 WOFF2 格式的字体文件，按上述方法，就能完成速度优化。这里介绍一种从 Google Fonts 下载 WOFF 或 WOFF2 格式字体的方法。</p><p>首先，在 Google Fonts 上搜索您需要的字体。例如 Mozilla Headline。点击 Get Font，然后点击 Get embed code。</p><p><img src="/posts/ec5f1055/%E5%9B%BE%E4%B8%80.png" alt="Get embed code"></p><p>在 import 模式中找到字体的 URL。如下图的 <a href="https://fonts.googleapis.com/css2?family=Mozilla+Headline:wght@200..700&amp;display=swap">https://fonts.googleapis.com/css2?family=Mozilla+Headline:wght@200..700&amp;display=swap</a> 。</p><p><img src="/posts/ec5f1055/%E5%9B%BE%E4%BA%8C.png" alt="Get font URL"></p><p>将 URL 复制到浏览器地址栏，访问。可以得到包含 <code>@font-face</code> 的 CSS 代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* latin-ext */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Mozilla Headline&#x27;</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">200</span> <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">font-stretch</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-display</span>: swap;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(https://fonts.gstatic.com/s/mozillaheadline/v1/QGY4z-UXahmCOps4kyMKGuSA9pYt2_P-w2kFrS88o6cVYTHDYMVmJQ.woff2) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">  unicode-range: U+<span class="number">0100</span>-<span class="number">02</span>BA, U+<span class="number">02</span>BD-<span class="number">02</span>C5, U+<span class="number">02</span>C7-<span class="number">02</span>CC, U+<span class="number">02</span>CE-<span class="number">02</span>D7, U+<span class="number">02</span>DD-<span class="number">02</span>FF, U+<span class="number">0304</span>, U+<span class="number">0308</span>, U+<span class="number">0329</span>, U+<span class="number">1</span>D00-<span class="number">1</span>DBF, U+<span class="number">1</span>E00-<span class="number">1</span>E9F, U+<span class="number">1</span>EF2-<span class="number">1</span>EFF, U+<span class="number">2020</span>, U+<span class="number">20</span>A0-<span class="number">20</span>AB, U+<span class="number">20</span>AD-<span class="number">20</span>C0, U+<span class="number">2113</span>, U+<span class="number">2</span>C60-<span class="number">2</span>C7F, U+A720-A7FF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* latin */</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Mozilla Headline&#x27;</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">200</span> <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">font-stretch</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-display</span>: swap;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(https://fonts.gstatic.com/s/mozillaheadline/v1/QGY4z-UXahmCOps4kyMKGuSA9pYt2_P-w2kFrS88o6cVYTHNYMU.woff2) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">  unicode-range: U+<span class="number">0000</span>-<span class="number">00</span>FF, U+<span class="number">0131</span>, U+<span class="number">0152</span>-<span class="number">0153</span>, U+<span class="number">02</span>BB-<span class="number">02</span>BC, U+<span class="number">02</span>C6, U+<span class="number">02</span>DA, U+<span class="number">02</span>DC, U+<span class="number">0304</span>, U+<span class="number">0308</span>, U+<span class="number">0329</span>, U+<span class="number">2000</span>-<span class="number">206</span>F, U+<span class="number">20</span>AC, U+<span class="number">2122</span>, U+<span class="number">2191</span>, U+<span class="number">2193</span>, U+<span class="number">2212</span>, U+<span class="number">2215</span>, U+FEFF, U+FFFD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里已经包含了两个 URL，是将该字体按照不同字符集分成的两个 WOFF2 文件。浏览器访问会自动下载。将下载的文件放到 <code>fonts</code> 文件夹中。然后把以上代码复制到 <ins>控制样式</ins> 的 <code>base.styl</code> 文件中。把 URL 改成相对路径。再在 <code>font-family</code> 字段中指定 <code>Mozilla Headline</code>，即可。</p><div class="success"><p>按照我的理解，直接将此 CSS 代码复制进去就能使用。但是考虑到某些不可抗力，还是建议将字体文件上传到云端，然后以相对路径的形式引用。</p></div><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.cnblogs.com/bianchengsanmei/p/15857883.html">TTF、TOF、WOFF 和 WOFF2 的相关概念</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/Hexo%E6%95%99%E7%A8%8B/">Hexo教程</category>
      
      
      <category domain="https://samuflore.top/tags/Hexo/">Hexo</category>
      
      <category domain="https://samuflore.top/tags/Tutorial/">Tutorial</category>
      
      <category domain="https://samuflore.top/tags/NexT/">NexT</category>
      
      <category domain="https://samuflore.top/tags/Font/">Font</category>
      
      
      <comments>https://samuflore.top/posts/ec5f1055/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Blog 8：[Hexo教程]Hexo之提交搜索引擎收录</title>
      <link>https://samuflore.top/posts/ff51cb4c/</link>
      <guid>https://samuflore.top/posts/ff51cb4c/</guid>
      <pubDate>Mon, 21 Jul 2025 11:14:08 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;利用&lt;code&gt;sitemap.xml&lt;/code&gt;来提交&lt;strong&gt;搜索引擎收录&lt;/strong&gt;，是搜索引擎优化（SEO）的重要一步。本文将介绍如何利用&lt;code&gt;sitemap.xml&lt;/code&gt;来提交&lt;strong&gt;百度&lt;/strong&gt;、&lt;strong&gt;谷歌&lt;/strong&gt;、&lt;strong&gt;必应&lt;/strong&gt;的搜索引擎收录。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序">序</h1><p>利用<code>sitemap.xml</code>来提交<strong>搜索引擎收录</strong>，是搜索引擎优化（SEO）的重要一步。本文将介绍如何利用<code>sitemap.xml</code>来提交<strong>百度</strong>、<strong>谷歌</strong>、<strong>必应</strong>的搜索引擎收录。</p><span id="more"></span><hr><h1 id="准备">准备</h1><h2 id="何为-Sitemap？">何为 Sitemap？</h2><blockquote><p>Sitemap（站点地图）是一种文件的统称，通常Sitemap（站点地图）可以是txt或者XML格式。通过Sitemap（站点地图）你可以告诉搜索引擎关于你的站点中的网页、视频或者其他文件的相关信息，帮助搜索引擎更好的认识和理解你的站点。格式正确的Sitemap（站点地图）文件会帮助搜索引擎更高效地抓取你的网站。XML格式的站点地图，通常会包含更多的信息，比如你可以通过Sitemap（站点地图）文件告诉搜索引擎你认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。例如，网页上次更新的时间和网页是否有任何备用的语言版本。<br><a href="https://zhuanlan.zhihu.com/p/441973408"><strong>知乎</strong></a></p></blockquote><p>简单来说，Sitemap 使得您可以一次性提交全站的所有 URL 等信息，帮助搜索引擎快速给您的网站建立索引。</p><h2 id="何为搜索引擎优化（SEO）？">何为搜索引擎优化（SEO）？</h2><blockquote><p>SEO（Search EngineOptimization，搜索引擎优化）是一种利用搜索引擎的内在规则，优化网站结构和内容，从而提升网站在搜索引擎结果中的自然排名的方法。<br><a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132"><strong>百度百科</strong></a></p></blockquote><p>搜索引擎收录了无数的网页。当用户搜索时，搜索引擎根据用户的关键字找到所有相关的网页，然后通过一定的算法对这些网页进行排名，将最相关的网页放在搜索结果的前面。搜索引擎优化就是通过一些技术手段，让网站在搜索引擎中排名靠前。<br>那么很显然，您必须首先把整个网站的 URL 都提交给搜索引擎，才能让搜索引擎收录之。进而您再考虑 SEO。</p><h2 id="安装插件">安装插件</h2><p>您需安装<code>hexo-generator-sitemap</code>插件和<code>hexo-generator-baidu-sitemap</code>插件。前者用于生成通用的<code>sitemap.xml</code>，后者用于生成<strong>百度</strong>的<code>baidusitemap.xml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h2 id="修改配置文件">修改配置文件</h2><p>打开<strong>站点配置文件</strong><code>_config.yml</code>，添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动生成sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><h2 id="生成和部署">生成和部署</h2><p>在 Hexo 根目录下，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时，在根目录的<code>public</code>文件夹中，您会发现其中生成了<code>sitemap.xml</code>和<code>baidusitemap.xml</code>两个文件。<br>文件的主体部分大致如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loc</span>&gt;</span>http:/example.com/test/123456/<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>yyyy-mm-dd<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是您需要提交给搜索引擎的 URL 信息：<strong>URL 地址</strong>、<strong>最后更新时间</strong>。</p><h1 id="提交百度">提交百度</h1><h2 id="登录百度站长平台">登录百度站长平台</h2><p>由此进入：<a href="http://zhanzhang.baidu.com/">百度站长平台</a><br>并进入<strong>站点管理</strong>页面：<br><img src="/posts/ff51cb4c/%E7%AB%99%E7%82%B9%E7%AE%A1%E7%90%86.png" alt="站点管理"></p><p><a id="Section"></a></p><h2 id="添加站点并验证">添加站点并验证</h2><p>输入您网站的域名：<br><img src="/posts/ff51cb4c/%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9.png" alt="添加站点"></p><p>在<strong>验证网站</strong>页面，选用<strong>文件验证</strong>方式，并下载指定的验证文件（当前：<code>baidu_verify_codeva-JSNntnC1KX.html</code>）：<br><img src="/posts/ff51cb4c/%E9%AA%8C%E8%AF%81.png" alt="验证"></p><p>将此验证文件放入<code>themes/next/source</code>下，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>等待 GitHub Pages 部署完成（您可在 GitHub 页面查看进度）。然后点击<strong>完成验证</strong>。</p><h2 id="主动推送">主动推送</h2><p>您需安装<code>hexo-baidu-url-submit</code>插件。该插件可在您执行<code>hexo d</code>时自动向<strong>百度</strong>推送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>修改<strong>站点配置文件</strong><code>_config.yml</code>，添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">5</span> <span class="comment">## 提交最新的五个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">http://example.com</span> <span class="comment">## 百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">your_token</span> <span class="comment">## 准入秘钥</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><div class="warning"><p><code>host</code>字段一定要填写<strong>站长平台注册的域名</strong>。<br>要获取<code>token</code>，请点击<strong>普通收录</strong>，点击<strong>API提交</strong>，在<strong>推送接口</strong>一栏可以找到<code>token=********</code>字样。*为您的<code>token</code>。</p></div><div class="warning"><p>请检查<strong>站点配置文件</strong><code>_config.yml</code>中的<code>url</code>字段是否正确。形如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://example.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title.xml</span></span><br></pre></td></tr></table></figure><p><code>url</code>字段必须是<strong>站长平台注册的域名</strong>。</p></div><p>最后，加入新的 deployer：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span> <span class="comment">## 原来的deployer</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">branch:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span> <span class="comment">## 添加这里内容即可</span></span><br></pre></td></tr></table></figure><div class="warning"><p>出现了两个<code>type</code>字段，因此您<strong>必须</strong>在前面添加<code>-</code>字符。</p></div><h2 id="自动推送">自动推送</h2><p>您可令页面被访问时，其 URL 自动推送给百度。修改<strong>主题</strong>目录下的<code>layout/post.swig</code>文件，末尾加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> bp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> curProtocol = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (curProtocol === <span class="string">&#x27;https&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        bp.<span class="property">src</span> = <span class="string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span>;        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        bp.<span class="property">src</span> = <span class="string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    s.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(bp, s);</span></span><br><span class="line"><span class="language-javascript">&#125;)();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Sitemap-提交">Sitemap 提交</h2><div class="tips"><p>百度站长平台貌似已经限制了 Sitemap 提交，暂时未获取提交机会。</p></div><div class="warning"><p>百度似乎无法爬取 GitHub Pages 上的网页，据说需要二次部署至 Coding 上。<strong>待更新</strong></p></div><h1 id="提交谷歌">提交谷歌</h1><h2 id="登录-Google-Search-Console">登录 Google Search Console</h2><p>由此进入：<a href="https://search.google.com/search-console/about">Google Search Console</a><br>点击<strong>立即使用</strong>。</p><h2 id="添加站点并验证-2">添加站点并验证</h2><p><a href="#Section">同上</a>。</p><h2 id="Sitemap-提交-2">Sitemap 提交</h2><p>在<strong>编制索引</strong>下找到<strong>站点地图</strong>，输入您的站点地图网址。例如：<code>http://example.com/sitemap.xml</code>。</p><p>您可以在上方搜索栏输入此网址，让<strong>谷歌</strong>检测您的 Sitemap 是否可以被收录。<br><img src="/posts/ff51cb4c/%E7%BD%91%E5%9D%80%E6%A3%80%E6%9F%A5.png" alt="网址检查"></p><p>点击<strong>测试实际网址</strong></p><p><img src="/posts/ff51cb4c/%E6%88%90%E5%8A%9F.png" alt="成功"></p><div class="success"><p>您应期望看到的结果是：<br><code>是否允许抓取？：是</code><br><code>是否允许编入索引？：是</code></p></div><p>若提交了 Sitemap 但显示<code>无法抓取</code>，则可能是由于 <strong>GSC</strong>的显示 bug，请等待一段时间。</p><div class="danger"><p>据说是这样，目前为止我的 Sitemap 还没有显示成功提交。。。</p></div><h1 id="提交必应">提交必应</h1><h2 id="登录-Bing-Webmaster">登录 Bing Webmaster</h2><p>由此进入：<a href="https://www.bing.com/webmaster/">Bing Webmaster</a><br>可以使用 <strong>Microsoft</strong> 账户登录。</p><h2 id="一键从-GSC-导入名下网站">一键从 GSC 导入名下网站</h2><p>登录您的 <strong>Google</strong> 账户即可。</p><h2 id="或手动添加网站并验证">或手动添加网站并验证</h2><p><a href="#Section">同上</a>。</p><h2 id="Sitemap-提交-3">Sitemap 提交</h2><div class="success"><p><strong>Bing</strong> 办事效率非常高，Sitemap 一下就通过了。</p></div>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/Hexo%E6%95%99%E7%A8%8B/">Hexo教程</category>
      
      
      <category domain="https://samuflore.top/tags/Hexo/">Hexo</category>
      
      <category domain="https://samuflore.top/tags/SEO/">SEO</category>
      
      <category domain="https://samuflore.top/tags/Baidu/">Baidu</category>
      
      <category domain="https://samuflore.top/tags/Google/">Google</category>
      
      <category domain="https://samuflore.top/tags/Bing/">Bing</category>
      
      
      <comments>https://samuflore.top/posts/ff51cb4c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Blog 7：[Hexo教程]更高级的 Markdown 渲染器：Markdown-it</title>
      <link>https://samuflore.top/posts/e11361f1/</link>
      <guid>https://samuflore.top/posts/e11361f1/</guid>
      <pubDate>Fri, 18 Jul 2025 02:29:59 GMT</pubDate>
      
      <description>&lt;div class=&quot;tips&quot;&gt;
&lt;p&gt;我正在使用 Markdown-it 来渲染此博文！&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&quot;序&quot;&gt;序&lt;/h1&gt;
&lt;p&gt;Hexo 默认使用 &lt;strong&gt;hexo-renderer-marked&lt;/strong&gt; 来渲染 Markdown 文件。此渲染器只支持一些基础语法。我们可以将其替换为更高级的 &lt;strong&gt;Markdown-it&lt;/strong&gt; 渲染器。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="tips"><p>我正在使用 Markdown-it 来渲染此博文！</p></div><h1 id="序">序</h1><p>Hexo 默认使用 <strong>hexo-renderer-marked</strong> 来渲染 Markdown 文件。此渲染器只支持一些基础语法。我们可以将其替换为更高级的 <strong>Markdown-it</strong> 渲染器。</p><span id="more"></span><hr><h1 id="安装">安装</h1><p>首先，您需要卸载原有的渲染器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure><p>然后安装新的渲染器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure><p>接着，您需要安装三个 Markdown-it 子插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i markdown-it-checkbox</span><br><span class="line">npm i markdown-it-imsize</span><br><span class="line">npm i markdown-it-expandable</span><br></pre></td></tr></table></figure><div class="warning"><p>请注意：科学上网。</p></div><div class="tips"><p>Markdown-it 内置了许多子插件，您只需手动安装上述三个。</p></div><hr><h1 id="配置">配置</h1><p>在<strong>站点配置文件</strong>的尾部填写 Markdown 渲染器配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">&quot;language-&quot;</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&quot;“”‘’&quot;</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-cjk-breaks</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-deflist</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-mark</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-checkbox</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-imsize</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-expandable</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">success</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">tips</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">warning</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">danger</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">&quot;header-anchor&quot;</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">&quot;left&quot;</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&quot;¶&quot;</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure><div class="tips"><p>要禁用某插件，您可<strong>注释</strong>该行。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - markdown-it-abbr</span></span><br></pre></td></tr></table></figure><p><s>或者直接删了</s></p></div><div class="warning"><p>上述代码的 <code>level</code> 字段表示最上级锚点的层级。当设置为 1 时，表示 <code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code> 都可以作为锚点。用于目录的跳转。</p></div><hr><h1 id="修改CSS">修改CSS</h1><p><a href="#Section">自定义容器</a>的样式需要您手动修改。对于NexT主题，您需要在以下路径的文件中添加CSS样式代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\next\source\css\_common\scaffolding\base.styl</span><br></pre></td></tr></table></figure><p>参考样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tips</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span> rgba(<span class="number">52</span>,<span class="number">152</span>,<span class="number">219</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">4px</span> solid rgb(<span class="number">52</span>,<span class="number">152</span>,<span class="number">219</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">darken</span>(<span class="built_in">rgb</span>(<span class="number">52</span>,<span class="number">152</span>,<span class="number">219</span>),<span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span> rgba(<span class="number">46</span>,<span class="number">204</span>,<span class="number">113</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">4px</span> solid rgb(<span class="number">46</span>,<span class="number">204</span>,<span class="number">113</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">darken</span>(<span class="built_in">rgb</span>(<span class="number">46</span>,<span class="number">204</span>,<span class="number">113</span>),<span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.warning</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span> rgba(<span class="number">241</span>,<span class="number">196</span>,<span class="number">15</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">4px</span> solid rgb(<span class="number">241</span>,<span class="number">196</span>,<span class="number">15</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">darken</span>(<span class="built_in">rgb</span>(<span class="number">241</span>,<span class="number">196</span>,<span class="number">15</span>),<span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.danger</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span> rgba(<span class="number">231</span>,<span class="number">76</span>,<span class="number">60</span>,.<span class="number">3</span>);</span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">4px</span> solid rgb(<span class="number">231</span>,<span class="number">76</span>,<span class="number">60</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">darken</span>(<span class="built_in">rgb</span>(<span class="number">231</span>,<span class="number">76</span>,<span class="number">60</span>),<span class="number">20%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tips"><p>其他主题，您可<strong>自行查找</strong></p></div><hr><h1 id="调用">调用</h1><h2 id="基础">基础</h2><table><thead><tr><th>插件</th><th>描述</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>markdown-it-abbr</td><td>注释</td><td><code>*[HTML]: Hyper Text Markup Language</code></td><td>*[HTML]: Hyper Text Markup Language</td></tr><tr><td>markdown-it-emoji</td><td>表情</td><td><code>:+1:</code></td><td>👍</td></tr><tr><td>markdown-it-footnote</td><td>脚注</td><td><code>文本[^1]文本</code></td><td>文本<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>文本</td></tr><tr><td>markdown-it-ins</td><td>下划线</td><td><code>++Inserted text++</code></td><td><ins>Inserted text</ins></td></tr><tr><td>markdown-it-mark</td><td>突出显示</td><td><code>==Marked text==</code></td><td><mark>Marked text</mark></td></tr><tr><td>markdown-it-sub</td><td>下标</td><td><code>H~2~O</code></td><td>H<sub>2</sub>O</td></tr><tr><td>markdown-it-sup</td><td>上标</td><td><code>X^2^</code></td><td>X<sup>2</sup></td></tr><tr><td>markdown-it-checkbox</td><td>复选框</td><td><code>- []未选中</code><br><code>- [x]已选中</code></td><td><input type="checkbox" id="checkbox1"><label for="checkbox1">未选中</label><br><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">已选中</label></td></tr></tbody></table><h2 id="进阶">进阶</h2><h3 id="折叠">折叠</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++ <span class="strong">**点击此处**</span></span><br><span class="line">这是被隐藏的内容。</span><br><span class="line">+++</span><br></pre></td></tr></table></figure><p>效果：</p><details open><summary><span class="pre-summary">&nbsp;</span><strong>点击此处</strong></summary><p>这是被隐藏的内容。</p></details><p><a id="Section"></a></p><h3 id="自定义容器">自定义容器</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">::: tips</span><br><span class="line"><span class="strong">**提示**</span></span><br><span class="line">这是一个提示</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: warning</span><br><span class="line"><span class="strong">**警告**</span></span><br><span class="line">这是一个警告</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: danger</span><br><span class="line"><span class="strong">**危险**</span></span><br><span class="line">这是一个危险信号</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: success</span><br><span class="line"><span class="strong">**成功**</span></span><br><span class="line">这是一个成功信号</span><br><span class="line">:::</span><br></pre></td></tr></table></figure><p>效果：</p><div class="tips"><p><strong>提示</strong><br>这是一个提示</p></div><div class="warning"><p><strong>警告</strong><br>这是一个警告</p></div><div class="danger"><p><strong>危险</strong><br>这是一个危险信号</p></div><div class="success"><p><strong>成功</strong><br>这是一个成功信号</p></div><hr><h1 id="推荐">推荐</h1><ul class="lvl-0"><li class="lvl-2"><p>查找 Emoji 的写法，您可参考：<a href="https://www.emojiall.com/zh-hans">EMOJIALL</a></p></li><li class="lvl-2"><p>查阅 Markdown-it 文档，您可参考：<a href="https://mdit-plugins.github.io/zh/">Markdown It 插件</a></p></li><li class="lvl-2"><p>了解更多 Markdown 语法，您可参考：<a href="https://markdown.com.cn/">Markdown 教程</a></p></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>这是参考文献。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://samuflore.top/categories/Hexo%E6%95%99%E7%A8%8B/">Hexo教程</category>
      
      
      <category domain="https://samuflore.top/tags/Hexo/">Hexo</category>
      
      <category domain="https://samuflore.top/tags/Tutorial/">Tutorial</category>
      
      <category domain="https://samuflore.top/tags/Markdown/">Markdown</category>
      
      
      <comments>https://samuflore.top/posts/e11361f1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>序</title>
      <link>https://samuflore.top/posts/9eefdea9/</link>
      <guid>https://samuflore.top/posts/9eefdea9/</guid>
      <pubDate>Thu, 17 Jul 2025 15:27:45 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;i class=&quot;fa fa-comment&quot; aria-hidden=&quot;true&quot; style=&quot;color: #6A5ACD; font-size: 1.5rem;&quot;&gt;&lt;/i&gt;&lt;span style=&quot;font-size: 12px; color: #695acd91;&quot;&gt; 随机句子由一言 API 提供&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;hitokoto&quot; style=&quot;text-align:center;font-weight:bold;color:#6A5ACD&quot;&gt;
  “&lt;a href=&quot;#&quot; id=&quot;hitokoto_text&quot;&gt;:D 获取中...&lt;/a&gt;”
&lt;/p&gt;
&lt;script&gt;
  fetch(&#39;https://v1.hitokoto.cn&#39;)
    .then(response =&gt; response.json())
    .then(data =&gt; {
      const hitokoto = document.querySelector(&#39;#hitokoto_text&#39;)
      hitokoto.href = `https://hitokoto.cn/?uuid=${data.uuid}`
      hitokoto.innerText = data.hitokoto
    })
    .catch(console.error)
&lt;/script&gt;
&lt;blockquote&gt;
&lt;p&gt;“创作是并没有什么秘诀，能够交头接耳，一句话就传授给别一个的，倘不然，只要有这秘诀，就真可以登广告，收学费，开一个三天包成文豪学校了。以中国之大，或者也许会有罢，但是，这其实是骗子。”&lt;br&gt;
&lt;strong&gt;《不应该那么写》 鲁迅&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我已经记了若干天的博文，这才想起来应该为整个博客写一篇序。先前一直用&lt;a href=&quot;http://samuflore.top/posts/95afa136/&quot;&gt;两篇小诗&lt;/a&gt;充门面，观赏了几位大佬&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;的博客页面之后，决心要做一些正式的事情了。&lt;br&gt;
于是我又选择了这个将要睡觉的时间开始。&lt;br&gt;
按照我妈的说法，我仿佛永远都选择将要睡觉的这个时间点开始做所谓“重要的事”，譬如突然要给 200G 的压缩包解压缩&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn2&quot; id=&quot;fnref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;，或者安装进度到了70%……总之一条，是不能关电脑，也不能安心上床，结果“搞得大家都睡不了觉”。可是这个时间段恰好是最适合开始做某件事的时候——未必能做完，但是能开个好头。&lt;br&gt;
&lt;strong&gt;所以，现在我要写小序了。&lt;/strong&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><i class="fa fa-comment" aria-hidden="true" style="color: #6A5ACD; font-size: 1.5rem;"></i><span style="font-size: 12px; color: #695acd91;"> 随机句子由一言 API 提供</span></p><p id="hitokoto" style="text-align:center;font-weight:bold;color:#6A5ACD">  “<a href="#" id="hitokoto_text">:D 获取中...</a>”</p><script>  fetch('https://v1.hitokoto.cn')    .then(response => response.json())    .then(data => {      const hitokoto = document.querySelector('#hitokoto_text')      hitokoto.href = `https://hitokoto.cn/?uuid=${data.uuid}`      hitokoto.innerText = data.hitokoto    })    .catch(console.error)</script><blockquote><p>“创作是并没有什么秘诀，能够交头接耳，一句话就传授给别一个的，倘不然，只要有这秘诀，就真可以登广告，收学费，开一个三天包成文豪学校了。以中国之大，或者也许会有罢，但是，这其实是骗子。”<br><strong>《不应该那么写》 鲁迅</strong></p></blockquote><p>我已经记了若干天的博文，这才想起来应该为整个博客写一篇序。先前一直用<a href="http://samuflore.top/posts/95afa136/">两篇小诗</a>充门面，观赏了几位大佬<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的博客页面之后，决心要做一些正式的事情了。<br>于是我又选择了这个将要睡觉的时间开始。<br>按照我妈的说法，我仿佛永远都选择将要睡觉的这个时间点开始做所谓“重要的事”，譬如突然要给 200G 的压缩包解压缩<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，或者安装进度到了70%……总之一条，是不能关电脑，也不能安心上床，结果“搞得大家都睡不了觉”。可是这个时间段恰好是最适合开始做某件事的时候——未必能做完，但是能开个好头。<br><strong>所以，现在我要写小序了。</strong></p><span id="more"></span><h1 id="字与码">字与码</h1><p>我进入六系既成事实，那么接下来的若干年必然是与代码打交道居多。这博客正好可以记录我的编程之旅，也算是为自己留下一点纪念。<br>所谓<strong>码字</strong>一词，在博客的创作过程中，真可谓十分贴切。使用 Markdown 编写博文，甚至于使用 HTML。Markdown 如此之简洁和优雅，几乎融于文字之中，正是<strong>字</strong>与<strong>码</strong>的结合。HTML 则时常将我从<strong>字</strong>里拉回<strong>码</strong>中。我不知道<strong>古法写作</strong>是否会长盛不衰，不过其面临这样一种对手，或许会走入另一条道路上。<br><strong>古法写作</strong>，我杜撰了这个词，但使用起来很奇怪。何谓“古”，很难说清。如果用创作文字之方法区分，则没有明确的界限，或者以 AI 辅佐写作之出现来划分，又显得这个“古”字很“新”了，并不贴切。可是论其本质，那么所谓古法、码字，又殊途同归了，那就是<strong>记录</strong>，<strong>记录</strong>。<br>古代，我们往石头上刻，往竹简上刻，这就叫做“刻录”。后来<strong>蔡伦</strong>改良了造纸术，我们就往纸上记，这就叫做“记录”。记了几千年，后来发明了软盘、磁带、硬盘，我们又回到刻。以上种种，无非是留存人存在过的痕迹。每个人都是时代的一粒沙，无后的，一代人的时间就会消失得无影无踪；好一些的，也不过三四代而已。流芳百世，少之又少。<strong>而文字的生命却是决定于载体</strong>。流传千年的语言不少，而其载体是人，这又回到了人在时代面前之渺小。譬如<strong>拉丁语</strong>，早已成为冢中枯骨。而文字，文字，载体是物，物质世界正是文字世界。在这样宏观的视角来看，似乎并无必要将<strong>字</strong>与<strong>码</strong>划清界限。<br>创作方面，<strong>字</strong>与<strong>码</strong>仿佛又有所相通。这里又可说起<strong>古法写作</strong>了。不论概念，可以明确的是自<strong>生成式人工智能</strong>广泛应用后，早已不是所谓<strong>古法写作</strong>的时代了。然而其方法和宗旨是经久不衰的，并且不仅限于<strong>字</strong>，也是可以推广到<strong>码</strong>上的。倘若今天我们<strong>突然</strong>需要写一篇 5000 字的<strong>法律与科技</strong>结课报告<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，那么不但要用 AI ，还要<strong>严谨地</strong><sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>用，所谓<strong>古法</strong>，在期末周，在水课面前，自然是毫不犹豫地放弃的。然而平时的创作，如果依赖于 AI ，后果确实不堪设想。文笔是一定会生疏的，危害更甚于提笔忘字，到了有口说不出、有笔写不了的地步。<strong>更何况互联网的混乱已经相当程度摧残了各种语言</strong>。<strong>码</strong>的时候，同样会遭遇这种困境。确实，用 <strong>Copilot</strong> 或 <strong>Fitten Code</strong> 代行一些结构高度重复的代码编写，节约时间用于思考。可是人总是顺应惰性，<code>Tab</code> 按个不停，一眨眼，就连思考也被<strong>自动补全</strong>了。这岂不与前述的面临一样的麻烦吗？<br><strong>字</strong>与<strong>码</strong>，这两者的界限，似乎并不那么清晰。<br>总之，我会尽量继续探索这二者——当然，是以一篇篇博文的形式，而非论文。也许一切明了的时候，我会写出一篇总的，来综述我的观点，而不是像这样一篇凌晨一点写的小序——<strong>散</strong>、<strong>乱</strong>、<strong>迷</strong>。不明了的时候，当然，继续更新些<strong>别的</strong>。<br><strong>仿佛找到了一个比游戏更有意思的事情。</strong><br>构建本站的时候，我的想法通常不会有明确的规划。如果您不知道从哪开始，建议您从 <a href="http://samuflore.top/about/"><i class="fa fa-thumbs-up" aria-hidden="true"></i> 此处</a> 开始探索。<br><strong>感谢您的时间。</strong></p><img src="/posts/9eefdea9/luxun.jpg" width="50%"><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://thysrael.github.io/">钟鼓楼</a>、<a href="https://hyggge.github.io/#!">Hyggge’s Blog</a>、<a href="https://x-parker.github.io/">Parker’s Blog</a> ，以及其他大佬。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>我可能正准备游玩 <strong>The Elder Scrolls V: Skyrim</strong> 的某个整合包（ <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>确有其事。 <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      
      <category domain="https://samuflore.top/tags/Introduction/">Introduction</category>
      
      
      <comments>https://samuflore.top/posts/9eefdea9/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
