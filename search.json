[{"title":"[CO Pre] MIPS 汇编入门","url":"/posts/1f9d902/","content":"\n# 序\n这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 MIPS 汇编部分。\n\n<!--more-->\n\n***\n\n# IDE\nMARS（MIPS ASSEMBLER AND RUNTIME SIMULATOR）  \nMARS 是一个轻量级的、用于教学的 MIPS 汇编语言集成开发环境（IDE）。它由密苏里州立大学开发，基于 Java 环境运行，完全绿色且免费。我们的课程即使用此软件来进行 MIPS 汇编语言的学习、编写和运行。\n\n***\n\n# 寄存器简介\n## 什么是寄存器？\n寄存器是一种高速存储器，可以暂存指令、数据、地址等。CPU 中只有有限的寄存器可供使用。  \nMIPS 体系结构中，CPU 对数据的操作是基于寄存器的。内存中的数据需要先使用读取类指令（Load）保存到寄存器中才可使用；操作完成的数据也需要使用装载类指令（Store）保存到内存中。  \n\n## MIPS 中的 32 个通用寄存器\n所谓通用寄存器（General - Purpose Register, GPR），代表它没有明确规定的用途，程序员可以随意对他们赋值、取值，同时他们的值也可以直接参与到各种指令之中。  \n然而，虽然冠有通用的头衔，程序员们还是会以一定的规则来使用它们，这是为了便于程序员之间的交流，同时也是为编译器等工具定下了一定的标准。  \n\n|Registers|Name|Usage|\n|-|-|-|\n|$0|$zero|常量0|\n|$1|$at|保留给汇编器使用的临时变量|\n|$2-$3|$v0-$v1|函数调用返回值|\n|$4-$7|$a0-$a3|函数调用参数|\n|$8-$15|$t0-$t7|临时变量|\n|$16-$23|$s0-$s7|需要保存的变量|\n|$24-$25|$t8-$t9|临时变量|\n|$26-$27|$k0-$k1|留给操作系统使用|\n|$28|$gp|全局指针|\n|$29|$sp|堆栈指针|\n|$30|$fp|帧指针|\n|$31|$ra|返回地址|\n\n{% note info %}\n- `%0` 一般不能用于赋值。即对其赋值不违反语法，但其始终保持为 0。\n- `%1` 保留给汇编器，一般不使用它。\n{% endnote %}\n\n<a id=\"specialReg\"></a>\n\n## 三个特殊寄存器\n- PC（Program Counter）：它用于存储当前 CPU 正在执行的指令在内存中的地址。\n- HI：这个寄存器用于乘除法。它被用来存放每次乘法结果的高 32 位，也被用来存放除法结果的余数。\n- LO：HI 的孪生兄弟。它被用来存放每次乘法结果的低 32 位，也被用来存放除法结果的商。\n\n***\n\n# MIPS 汇编指令集架构\n## 什么是指令？\n指令，即是由处理器指令集架构（Instruction Set Architecture，可以理解为计算机体系结构中对程序相关的部分所做的定义）定义的处理器的独立操作，这个操作一般是运算、存储、读取等。一个指令在 CPU 中真正的存在形式是高低电平，也可以理解为由 01 序列组成的机器码。但因为机器码人类难以阅读和理解，所以指令一般由汇编语言来表示，也就是我们俗称的汇编指令。从这个角度上来说，汇编指令只是指令的一种表示形式而已，其实质是一样的。\n\n## 指令之格式\n指令一般由一个++指令名++开头，后跟其++操作数++，中间由++空格++或++逗号++隔开。操作数一般为 0 至 3 个，且每个指令名有其固定的操作数。一般来说格式如下：  \n\n*指令名  操作数 1  操作数 2  操作数 3*  \n\n或：  \n\n*指令名 操作数 1, 操作数 3(操作数 2)*  \n\n操作数可以是寄存器、立即数[^1]或标签[^2]。每个指令都有其固定的对操作数形式的要求。而标签最终会由汇编器转换为立即数。  \n\n常见指令格式样例：\n```asm\nadd $s0, $a0, $a1\naddi $s0, $a0, 12\nmult $s1, $s2\nbeq $a1, $a2, loop\nblez $s1, -2\njr $ra\nj 0x00003014\n```\n\n::: tips\n前文提到可以用标签代替某个地址，正如上例第 4 行的 `loop` 标签。\n:::\n\n::: warning\n注意：在 MARS 中，跳转指令只能使用标签来进行跳转，不能使用立即数！\n:::\n\n[^1]: 指令中设定好的常数，可以直接参与运算，一般为 16 位 二进制。\n[^2]: 用于使程序更简单清晰。标签用于表示一个地址，以供指令来引用。一般用于表示一个数据存取的地址（类似于数组名）、或者一个程序跳转的地址（类似于函数名，或者 C 语言中 `goto` 的跳转目标）。\n\n## 机器码指令\n### 机器码\n计算机只能理解二进制形式的数据。而我们前面所说的汇编语言，最终就会转化为机器语言——也就是机器码指令， CPU 可以直接识别这种机器语言，从而去完成相应的操作。  \nMIPS 汇编中，所有的指令长度均为 32 位，即 4 字节，或者说 1 字。  \n一段汇编语言可以转换为一段机器码，例如下面这段汇编指令：  \n```asm\n.data\n.text\n.global main\nmain:\naddi $t0, $0, 100\nori $t1, $0, 200\nadd $t2, $t1, $t2\nsub $t3, $t2, $t1\nlui $t4, 233\nori $v0, 1\nori $a0, 2333\nmthi $t1\nsyscall\nnop\nloop:\nj loop\nnop\n```\n其转换后的结果为（16 进制）：  \n```\n20080064\n340900c8\n012a5020\n01495822\n3c0c00e9\n34420001\n3484091d\n01200011\n0000000c\n00000000\n08000c0a\n00000000\n```\n\n### 机器码之指令格式\n- R 型指令\nR 型指令的操作数最多，一般用于运算指令。例如 `add`、`sub`、`sll` 等。其格式如下（左侧为高位，右侧为低位，第二行为位数）：\n\n|op|rs|rt|rd|shamt|func|\n|-|-|-|-|-|-|\n|6|5|5|5|5|6|\n\n- I 型指令\n 型指令的特点是有 16 位的立即数（偏移也是一样的道理）。因此，I 型指令一般用于 `addi`、`subi`、`ori` 等与立即数相运算的指令（这里需要注意：在写汇编语言的时候，需要使用负号来标记负数，而不要和机器码一样认为首位的 1 就代表负数），或 `beq`、`bgtz` 等比较跳转指令，因为它们要让两个寄存器的值相比并让 PC 偏移 offset 这么多，刚好利用了全部的字段。还有存取指令，例如 `sw`、`lw`，它们在使用时需要对地址指定一个偏移值，也会用到立即数字段。  \n\n |op|rs|rt|offset or immediate|\n |-|-|-|-|\n |6|5|5|16|\n\n - J 型指令\n J 型指令很少，常见的为 `j` 和 `jal`。他们需要直接跳转至某个地址，而非利用当前的 PC 值加上偏移量计算出新的地址，因此需要的位数较多。\n \n |op|address|\n |-|-|\n |6|26|\n\n{% note info %}\n严格来说，并非所有的指令都严格遵守上面三种格式，有的如 `eret`、`syscall` 指令一样没有操作数；有的如 `jalr` 指令一样某些字段被固定为某个值。不过，就大部分指令而言，都可按上面三种格式进行解释\n{% endnote %}\n\n- 表格解释\n  - op：也称 opcode、操作码，用于标识指令的功能。CPU 需要通过这个字段来识别这是一条什么指令。不过，由于 op 只有 6 位，不足以表示所有的 MIPS 指令，因此在 R 型指令中，有 func 字段来辅助它的功能。\n  - func: 辅助 op 识别指令。\n  - rs, rt, rd: 通用寄存器的代号，并不单指某一寄存器。范围是 `$0`~`$31`，用机器码表示就是 00000~11111。\n  - shamt: 移位数，用于移位指令。\n  - offset: 地址偏移量。\n  - immediate: 立即数。\n  - address: 跳转目标地址，用于跳转指令。\n\n::: tips\n[MIPS-C 指令集由此查看](https://cscore.e1.buaa.edu.cn/assets/cscore-assets/MIPS-C%E6%8C%87%E4%BB%A4%E9%9B%86_%E6%A0%A1%E5%AF%B9%E5%AE%8C%E6%88%90%E7%89%88_-%E6%8C%87%E4%BB%A4%E6%8E%92%E5%BA%8F.pdf)。\n:::\n\n## 扩展指令和伪指令\n### 扩展指令（Pseudo Instruction）\n对基本指令的转写（例如用标签代替立即数），或对操作数的略写等，被称作扩展指令。  \n扩展指令的功能主要是简化程序。汇编器将一些常用、但标准指令集不提供的功能封装为一条指令；或者改变现有指令的操作数的形式或个数，使其以新的形式出现。需要注意的是，它们只是形式上是一条新指令，而实际上，在汇编器将其汇编之后，还是使用标准指令来实现的。  \n最常用到的一条扩展指令是 `li` 指令，它用来为某个寄存器赋值，比如 `li $a0,100` 就是将 `100` 赋给 `$a0` 寄存器。汇编器在翻译这条扩展指令时会根据需要，将它翻译成不同的基本指令或基本指令的组合。譬如：  \n- 所赋的值少于等于 16 位，则等价于用 `addiu` 指令，比如 `addiu $a0, %0, 0x00001000`。\n- 所赋的值大于 16 位，则等价于用 `lui` 和 `ori` 指令，即先将高 16 位装在在寄存器的前面，再用或运算补充低 16 位，比如 `lui $a1, 0x00001234` 和 `ori $a0, $a1, 0x00004321`。\n\n另一条常用的扩展指令是 `la` 指令，这条指令与 `li` 指令非常类似，都是为寄存器赋值，只不过是使用标签来为寄存器赋值。经过了前面的学习，大家应该已经知道标签本质上对应一个 32 位地址，但 `li` 指令并不能直接使用标签来为寄存器赋值，必须要使用 `la`。比如 `la $t0, fibs` 这条指令就是把 `fibs` 这个标签的地址存入 `$t0` 中。  \n\n### 伪指令（Directives）\n伪指令（Directives）是用来指导汇编器如何处理程序的语句，有点类似于其他语言中的预处理命令。伪指令不是指令，它并不会被编译为机器码，但他却能影响其他指令的汇编结果。常用的伪指令有以下几个：  \n- `.data`：用于预先存储数据的伪指令的开始标志。\n- `.text`：程序代码指令开始的标志。\n- `.word`：以字为单位存储数据。\n`.word num` 初始化一个字，存着 num 这个数\n- `.asciiz`：以字节为单位存储字符串。末尾自动添加 `\\0`。\n- `.space`：申请若干个字节的未初始化的内存空间。\n`.space n` 即申请 n 个字节的未初始化的内存空间。\n\n## MIPS 指令初步\n{% note info %}\n该节学习自[Kamonto's Blog《一本书教你通关计组实验》](https://kamonto.github.io/Kamonto_blog/2025/09/07/%E4%B8%80%E6%9C%AC%E4%B9%A6%E6%95%99%E4%BD%A0%E9%80%9A%E5%85%B3%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%8A%EF%BC%89/)。\n{% endnote %}\n\n### 位运算\n> 四则运算是更复杂程序的基石，而位运算是四则运算的基石。\n> *——麦瑟尔夫*\n\n本节介绍 `and or xor nor andi ori xori` 这几种位运算。  \n\n它们的格式都是 `op rs, rt, rd`，即把 `rt` 和 `rd` 两个寄存器的内容进行运算，运算结果存入 `rd` 寄存器。++运算结果写前面++。  \n\n首先是与运算、或运算、异或运算。正如其名，非常好懂。  \n然后是或非运算，有一个小技巧，就是要对一个寄存器取反，可以利用或非运算来完成（MIPS 指令集没有提供取反指令）： \n\n```asm\nnor $t0, $t0, $0\n```\n\n::: tips\n别忘了 $0 永远是 0。\n:::\n\n如果需要把一个寄存器的值和一个立即数进行运算，则需要用到末尾带“i”的指令（即 immediate），正如与立即数、或立即数、异或立即数。\n\n::: warning\n注意：使用立即数的指令，立即数必须写在第三位。\n:::\n\n### 几条扩展指令\n- `li`：`li rs, immediate`，将立即数赋给寄存器。\n- `move`: `move rs, rt`, 将后一个寄存器的值赋给前一个寄存器。\n- `la`：`la rd, label`，将标签对应的地址（十六进制值）赋给寄存器，后续我们讨论地址和内存的细节内容。\n\n### 加减法\n本节介绍 `add sub addu subu addi addiu` 几种加减法运算。  \n\n四则运算和位运算相比多了两个棘手的问题，即符号和溢出。  \n\n> 首先来谈正负性的问题，其实这根本就不是个问题。如果你是补码领域大神的话，你就会发现，在不考虑位溢出的情况下（这里“不考虑位溢出”的意思是发生溢出时会将溢出位舍去，相反“考虑溢出”的意思是如果发生溢出直接报错），二进制补码的正负性其实是相同的，这也正是补码的优越之处。不信可以看看下面这些例子：  \n>\n> 在 32 位的条件下，`0x3 + 0xffffffff` 的结果是多少？你的做法或许是这样的：首先，你发现 `0xffffffff` 的最高位是 `1` ，于是断定它是负数，将其一段操作转换成 `-1` ，再与 `0x3` 相加，得到结果 `0x2` 。但实际上，我直接把它们两个相加，结果就是 `0x100000002` ，舍去溢出的最高位，直接就得到了 `0x2` 。  \n>\n> 再举一个例子，同样是在 32 位的条件下，`0xfffffffd - 0xffffffff` 的结果是多少？细心的你可能会将这个式子转换成 `(-3) - (-1)` ，结果是 `-2` ，也就是 `0xfffffffe` 。但是我不管正负，直接进行运算，发现被减数小于减数，我直接在被减数前面补一个溢出位 1 ，于是原式变成 `0x1fffffffd - 0xffffffff` ，结果等于 `0xfffffffe` 。  \n>\n> *摘自原书*\n\n这是 `addu`（无符号加） 和 `subu`（无符号减）的原理。因为它们把操作数当作无符号数直接运算，然后直接把溢出部分舍去。++但是其运算结果还是有符号的！！！++  \n\n而 `add` 和 `sub` 则不会简单地舍去溢出位，而是在溢出时抛出异常。如果使用这种运算，需要注意判断是否溢出。  \n\n此外 `add` 和 `addu` 也有它们的立即数版本 `addi` 和 `addiu`（注意不是 `addui`），++而 `subi` 和 `subiu` 是伪指令++，和上面一样它们也必须把立即数放在第三位。  \n\n### 乘除法\n本节介绍 `mult div mfhi mflo mthi mtlo` 几种乘除法运算。  \n\n加减法至多只溢出一位，而乘除法则不然，两个 32 位数字相乘，结果可达 64 位，必须要用新的处理方法。  \n于是我们想到了之前提到的[特殊寄存器](#specialReg) `HI` 和 `LO`，在乘法运算的时候，直接把高 32 位放到 `HI` 寄存器里面，低 32 位放到 `LO` 寄存器里面，就万事大吉了。用法 `mult rs, rt`，即把 `rs` 和 `rt` 两个寄存器的内容相乘。  \n\n::: tips\n为什么不要指定结果保存的位置？  \n因为结果放到了 `HI` 和 `LO` 里面，自然就只需要指定两个操作数的寄存器了。\n:::\n\n这两个是特殊寄存器，不能直接调用，要想使用里面的数，必须提前取出来，这就是 `mfhi` 和 `mflo` 存在的意义。用 `mfxx rs` 把 `HI` 或者 `LO` 寄存器的值存入 `rs` 寄存器。  \n当然也有反过来的用法，即手动把数字写进 `HI` 和 `LO` 寄存器。用 `mthi` 和 `mtlo` 指令。用 `mthi rs` 把 `rs` 寄存器的值存入 `HI` 寄存器，用 `mtlo rs` 把 `rs` 寄存器的值存入 `LO` 寄存器。  \n\n除法也利用这两个寄存器，不过是 `HI` 存++余数++而 `LO` 存++商++。切勿记反。切勿记反。切勿记反。  \n若除数是负数，处理方法与 C 语言中相同：被除数为正数时，余数为 0 或正数；被除数为负数时，余数为 0 或负数。如下表：  \n\n|被除数|除数|商|余数|\n|-|-|-|-|\n|7|3|2|1|\n|7|-3|-2|1|\n|-7|3|-2|-1|\n|-7|-3|2|-1|\n\n### 几个单位\n自此节开始要进入内存的学习，先通过了解单位来入门。  \n\n1. 位（bit）: 1 位代表 1 个 二进制值（0 或 1）。比如二进制数 `0b10110` 就是 5 位。++十六进制数 `0xabcd` 的每一个数字都能转换成 4 位二进制数++，所以这个数是 16 位。\n\n2. 字节（byte）: 8 位组成 1 个字节。一个 32 位的寄存器，其大小就是 4 字节。++字节是地址的基本单位++。\n\n3. 半字（halfword）: 16 位组成 1 个半字。\n\n4. 字（word）: 32 位组成 1 个字。\n\n### 地址\n内存空间连续而庞大，由于其连续，我们从 0 开始为其编号，称为地址。要注意每个地址代表的空间是 8 位，即一字节。也就是说字节是地址的基本单位。  \n举例来说，倘若要把数据 `0x12345678` 存储地址 `0x0`，那么按每个地址存入 8 位的逻辑，`0x0 0x1 0x2 0x3` 四个地址存入了 32 位，刚好存下这串数字。\n#### 小端存储\n小端存储指的是数据的低位字节保存在内存的低地址中。以上面的存储为例，数据的低位字节是 `0x78`，保存在地址 `0x0` 中、`0x56` 存储在 `0x1` 中，以此类推。\n#### 大端存储\n大端存储则相反，数据低位字节存储在内存的高地址中。此处不再举例。\n\n### 按字访存\n本节介绍 `lw sw` 两个访存指令。  \n\n顾名思义，上述两个指令表示 `store word` 和 `load word`，即向内存中存储或读取一个字。  \n`sw rt, offset(rs)` 表示将 `rt` 这个寄存器的内容写入 “`rs` 寄存器中储存的值 + `offset` 这个++立即数++或++标签++表示的地址”表示的地址处。  \n略微有点绕。举例而言，`$t1 = 0x12345678` `$t2 = 0x00000007`，若要把 `$t1` 的值储存到地址 `0x8` 和 `0x4` 那么分别要如何写呢？  \n答案是：\n\n```asm\nsw $t1, 1($t2)\nsw $t1, -3($t2)\n```\n\n这就是所谓“表示的地址 + 偏移量”表示的地址。  \n要注意，括号中只能是一个寄存器。来看以下例子：  \n想要构建一个 `int` 类型数组，首地址为标签 `arr`，那么如何将 `$t1` 存入 `arr[3]` ？  \n首先我们要明确，`int` 类型是 4 字节，即一个数要占用 4 个地址。那么 `arr[3]` 的起始地址是 `arr + 12`。那么你有可能写成下面的形式：\n\n```asm\nsw $t1, 12(arr)\n```\n\n这就掉入了惯性思维的陷阱。`arr` 可以放在括号内吗？甚不然也。因为 `arr` 只是一个标签，而标签在编译时会被翻译成立即数，而立即数是不能放在括号内的。  \n正确的写法应该是：\n\n```asm\nli $t2, 12\nsw $t1, arr($t2)\n```\n\n也就是说，先用一个寄存器把偏移量 12 保存下来，再加上 `arr` 标签得到 `arr + 12`，再用这个地址作为 `sw` 指令的第二个参数。\n\n::: tips\n一般来说我们在括号里写基位置 `base`，括号外是偏移量 `offset`。但是这不是绝对的！上面我们就把偏移量写在内而基位置写在外，得到了一样的效果。\n:::\n\n`lw` 要注意的事项与上面一致，只不过作用是把后面的地址中保存的值取到了前面的寄存器中。  \n\n::: warning\n注意：`lw` 和 `sw` 第二个参数计算出的地址必须合法（在内存范围内，且非负），且为 4 的倍数，否则会抛出异常！\n:::\n\n#### 与 move 和 la 的区别\n这时候你可能会有疑惑：`move $t1, $t2` 和 `lw $t1, 0($t2)` 有区别吗？答案是有的。因为 `move` 做的是把第二个寄存器的值直接赋给第一个寄存器，而 `lw` 做的是根据第二个寄存器的值++去内存空间找相应的地址保存的数据++，再赋给第一个寄存器。  \n`la` 也是如此，`la $t1, label` 把标签表示的地址直接赋给了第一个寄存器，而 `lw $t1, label($0)` 则是根据标签表示的地址去内存中找到数据，赋给第一个寄存器。  \n\n也就是说，要注意地址和地址保存的数的区别。地址本身也是一串数，而这串数相当于一个门牌号，门后面就是这个地址保存的数。\n\n### 按半字、字节访存\n本节将介绍 `sh lh sb lb` 几个访存指令。  \n\n`sh lh` 全称 `store halfword` 和 `load halfword`，用于将一个半字（2 字节，16 位）从寄存器写入内存，或反过来。  \n`sb lb` 全称 `store byte` 和 `load byte`，用于将一个字节（8 位）从寄存器写入内存，或反过来。  \n\n这四条指令用法和 `lw sw` 一致，不再赘述。只有一些细节需要关注：  \n- `sh lh` 要求计算出的地址是 2 的倍数，而 `sb lb` 没有要求。\n- `sh sb` 指令在将第一个寄存器的值存入内存中时，倘若寄存器中的值超过了标定的位数，则会将高位舍去，只存入低位。  \n比如 `$t1 = 0x12345678`。现在执行 `sb $t1 offset(base)`，那么只有 `$t1` 中的低 8 位会被存入内存（`0x78` 小端存储），高 24 位会被舍去。  \n- `lh lb` 指令在寄存器中已经有值的情况下往里面存数据时，会从低到高存入所需的数据，其余直接置 0。  \n比如 `$t1 = 0x12345678`。现在执行 `lb $t1 offset(base)`。如果地址保存的数是 `0xab`，那么 `$t1` 的低 8 位会写入 `0xab` 而高 24 位直接置 0，即变成 `0x000000ab`。\n\n### 跳转指令\n#### 绝对跳转\n本节将介绍 `j jal jr jalr` 几条跳转指令。  \n\n跳转指令有点像 C 语言中的 `goto`，可以将程序运行的位置跳转到指定位置。  \n\n`j`，即 `jump`，只有一种用法就是 `j label`，把`label` 写在目的地的前一行，就可以在运行完 `j` 指令后立即跳转到 `label` 处执行。  \n\n::: warning\n`j` 指令的目的地只能用 `label` 来表示，不能直接用立即数。\n:::\n\n`label` 标识了目的地这行指令的地址。也就是说每写一行指令，都会转换成机器码在内存中保存，占用一个地址。前面所说 `sw sh sb` 指令会往内存写入数据，也占用地址。储存数据区和储存指令区是分开的，前者占用 `0x00000000 - 0x00002fff` 段，被称为 `.data` 段，后者占用 `0x00003000` 往后，被称作 `.text` 段。  \n\n::: tips\nMIPS 语言中的每条指令，转换为机器码都固定为 32 位，所以每条指令的地址 Address 也会按照顺序每条 +4 递增。\n:::\n\n`jal jr`，是一对指令，需要同时出现。`jal label` 同样可以跳转到 `label` 对应的位置，但它会把当前指令的++下一条指令++的地址写入 31 号寄存器 `$ra` 中，即 `PC + 4`，`PC` 即当前指令的地址。`jr $ra` 则又回到　`jal` 的下一行继续执行。  \n\n{% note info %}\n理论上，`jr` 后可以接任意寄存器，它的作用本质上是将寄存器中的数当作地址，实现跳转。但一般和 `jal` 搭配使用。\n{% endnote %}\n\n::: tips\n为什么不跳回到 `jal` 的地址？  \n因为这样会导致 `jal` 再次执行，造成跳转的死循环。\n:::\n\n`jalr`，是 `jal` 和 `jr` 的组合指令。`jalr` 要指定两个寄存器，用来保存 目的地 和 `PC + 4`，例如 `jalr $t1, $t2` 是跳转到 `$t2` 寄存器保存的地址，并把当前指令的++下一条指令++的地址写入 `$t1` 寄存器中。  \n\n","tags":["CO","CO Pre","MIPS","MARS","Assembly Language"],"categories":["計算機組成原理"]},{"title":"[轉載]新川大陆文化史","url":"/posts/10425c0c/","content":"\n{% note info %}\n本文转载自神皇枫秀，敬请留意。\n{% endnote %}\n\n\n# 新川大陆文化史\n\n## 引言\n\n新川大陆的文明发展史是一部多元文化交融的史诗。从远古人类的起源分化，到各文明的兴衰更迭，这片土地见证了种族迁徙、技术革新、宗教演变与政治制度的不断创新。本书记述了从公元前2000年至公元1000年间，除川帝国外主要文明的发展历程，展现了斯特人、瓦伦人、伊塞尔人、米亚人等多个族群在探索、融合与抗争中共同谱写的文明篇章。\n\n<!--more-->\n\n## 第一章：人类起源与早期迁徙（公元前2000年之前）\n\n### 1.1 人类共同祖先的分化\n\n新川大陆的人类起源可追溯至远古时期的古人猿进化。根据《新川大陆民族发展简史》记载，古人猿主要分化为两个方向：\n\n• **兽向进化**：形成**林人**，身形矫健，擅长山林间穿梭游居\n\n• **人向进化**：形成**山人**，依靠智慧聚居于山洞，发展出早期社会组织\n\n山人与林人的生存竞争构成了大陆文明的第一个重要分水岭。山人凭借更先进的工具使用能力和社会组织形式，在竞争中占据优势，迫使林人开始大规模迁徙，进而开启了新川大陆文明多样性的序幕。\n\n### 1.2 林人的三大迁徙路线\n\n**公元前2000年前后**，山人与林人爆发决定性争斗，山人胜利后，林人被迫分为三大支系向不同方向迁徙：\n\n• **北迁支系**：向寒冷的北方极地进发，逐渐适应严寒气候\n\n• **西南迁支系**：进入干旱的沙漠戈壁地区，发展出耐旱生存技能\n\n• **西北迁支系**：深入原始森林密布的西北山地，与野兽和复杂地形抗争\n\n这一迁徙过程不仅是地理空间的拓展，更是文化多样性形成的关键阶段，为后来各文明的独特发展奠定了基础。\n\n### 1.3 山人的内部发展\n\n占据东部肥沃土地的山人，随着人口增长也开始分化为三支：\n\n• **海人**：向东迁至沿海地区，发展渔业和航海文化\n\n• **川人**：向平原地带发展，建立早期农业社会\n\n• **米亚人**：沿河流建村，发展出与水资源密切相关的文化\n\n山人与林人的分化与迁徙，构成了新川大陆文明发展的基本格局，为后续的文明碰撞与融合埋下了伏笔。\n\n## 第二章：远古探索时期（公元前2000年-公元前400年）\n\n### 2.1 北境文明的奠基：斯特人与斯尔吉亚雏形\n\n**公元前1700年前后**，向北迁徙的林人分支在\"神之息\"山谷定居，逐渐演变为**斯特人**。他们选择的定居点位于摩尔吉亚河下游，这片山谷土地肥沃，四周环山，既提供了防御优势，又便于农业发展。斯特人在此建立了早期城镇**坤达帖木儿**，标志着北境第一个文明雏形的诞生。\n\n斯特人发展出独特的山地农业技术，适应了北境较短的生长季节，并形成了以部落长老为核心的社会结构。他们崇拜山神，认为山脉是神灵的化身，这种信仰后来与川人的游牧文化融合，形成了斯尔吉亚文明的精神基础。\n\n### 2.2 西南沙漠的适应：瓦伦人的迁徙与定居\n\n**公元前1600年前后**，向西南迁徙的林人分支演变为**瓦伦人**。他们最初进入的裂空山谷地区气候干旱，生存条件恶劣，族群数量急剧减少。经过多年探索，瓦伦人最终穿越裂空山，发现了水源充沛、土地肥沃的**裂龙山谷**，并在此建立了**拜亚城**。\n\n瓦伦人在裂龙山谷发展出独特的节水农业技术，他们建造了复杂的引水渠系统，将山泉水引入农田，成功在沙漠边缘开辟出绿洲。这种对水资源的精细管理能力，成为后来瓦伦迪亚商业文明的重要特征。\n\n### 2.3 西北山地的开拓者：伊塞尔人的分支发展\n\n**公元前1400年前后**，向西北迁徙的林人演变为**伊塞尔人**，并进一步分为两支：\n\n• **向西分支**：约50年后抵达伊塞尔河上游，建立**伊塞尔城**。该城东南北三面环山，形成天然防御屏障，伊塞尔人在此发展出以农业为主的定居文明。\n\n• **向北分支**：抵达寒冷的**霜狼高原**，开启了长达数百年的流浪生活。在与严酷自然环境的抗争中，他们与当地狼群形成了独特的共生关系，逐渐产生了对**霜狼的信仰**，这种信仰成为他们精神生活的核心。\n\n伊塞尔人的两支发展路径，体现了同一族群在不同环境压力下的文化适应策略，为后来新川大陆文明的多样性做出了重要贡献。\n\n### 2.4 山人的分化与融合\n\n**公元前1800年前后**，占据东部肥沃土地的山人逐渐分化为三个支系：**川人**、**海人**和**米亚人**。这三支在发展过程中命运各异：\n\n**海人**因海洋资源有限和环境变化，于**公元前1100年前后**逐渐消亡，其土地被川人兼并。这一事件成为新川大陆文明发展史上第一次记录的民族消亡事件，反映了环境适应对文明存续的重要性。\n\n**公元前1000年前后**，**川人**发起对**米亚人**的兼并战争。战争导致米亚人分化为两支：一支被川人兼并，逐渐演变为**兰川人**；另一支则开始大规模迁徙，史称\"米亚远行\"，这一迁徙对后来多个文明的发展产生了深远影响。\n\n## 第三章：古典农业时期（公元前400年-公元400年）\n\n### 3.1 水利技术的传播与文明革新\n\n**公元前800年前后**，远行的米亚人与瓦伦人在裂龙山谷相遇。米亚人带来的先进水利技术与瓦伦人的沙漠生存经验相结合，促成了**拜亚城**的重建。这次重建不仅是城市物理空间的改造，更是一次深刻的文化融合，标志着**瓦伦迪亚文明**的正式形成。\n\n米亚人带来的水利技术包括：\n\n• 复杂的引水渠系统设计\n\n• 水坝和水库的建造技术\n\n• 农田灌溉的高效分配方法\n\n这些技术使裂龙山谷的农业产量大幅提高，支持了人口增长和城市扩张，为瓦伦迪亚后来的商业繁荣奠定了物质基础。\n\n### 3.2 霜狼高原的文明融合：蒙里米亚的诞生\n\n**公元前700年前后**，另一支远行的米亚人抵达**霜狼高原**，与在此流浪数百年的伊塞尔人北迁分支相遇。米亚人带来的水利技术使高原农业成为可能，他们在河流源头建立了**蒙德里城**，标志着**蒙里米亚文明**的诞生。\n\n蒙里米亚文明的独特之处在于：\n\n• **霜狼信仰与米亚人宗教观念的融合**：形成了独特的萨满教体系\n\n• **高原农业技术**：开发出适应高寒环境的作物品种和种植技术\n\n• **政教合一的社会结构**：宗教领袖同时掌握政治权力\n\n**公元前307年**，在伊塞尔人入侵的压力下，大先知蒙完成了对宗教的系统诠释，确立了以霜狼为核心的神学体系。**公元前110年**，蒙的第十一代孙统一霜狼高原各部，正式建立政教合一的**蒙里米亚**国家，使蒙里米亚成为古典农业时期最具影响力的文明之一。\n\n### 3.3 北境的民族融合：斯尔人的崛起\n\n**公元前500年前后**，川人内部因生产方式差异发生分裂。从事游牧的一支因与农耕文明的冲突被边缘化，向北迁移。**公元前400年前后**，这支游牧川人与北境的斯特人相遇并逐渐融合，形成了新的民族——**斯尔人**。\n\n斯尔人继承了：\n\n• 斯特人的北境适应能力和骑射技术\n\n• 川人的社会组织能力和军事战略思想\n\n• 双方的文化传统和宗教信仰\n\n**公元101年**，斯尔人凭借军事优势占领**坤达帖木儿**，建立**斯尔吉亚**政权。斯尔吉亚实行军事贵族制度，形成了少数精英统治多数斯特人的社会结构，这种结构后来成为北境政治的典型模式。\n\n### 3.4 伊塞尔文明的动荡与变革\n\n**公元前309年**，伊塞尔人向南扩张，大举进攻霜狼高原的蒙里米亚。然而，不适应高原环境的伊塞尔军队遭遇惨败，这场战争引发了伊塞尔内部的长期混乱。\n\n战争失败后，伊塞尔社会陷入危机：\n\n• 军事贵族与传统祭司的权力斗争加剧\n\n• 资源分配不均引发社会矛盾\n\n• 外部威胁与内部动荡交织\n\n**公元前307年**，在战争阴影下，大先知蒙完成宗教改革，而伊塞尔内部则出现了**铁器技术**引发的社会变革。铁器的传入改变了战争形态和生产方式，导致旧贵族与新兴军事阶层的冲突。旧贵族虽然在权力斗争中暂时获胜，但社会矛盾的积累为后来的动荡埋下了伏笔。\n\n## 第四章：帝国封建时期（公元400年-公元1000年）\n\n### 4.1 双丹的独立与商业文明的兴起\n\n**公元404年**，**切丹**宣布独立，这一事件成为帝国封建时期的开端。切丹家族虽身处川人政权体系，却保留着部分瓦伦人的血脉。他们利用瓦伦迪亚民众的暴乱，扩充私军，最终脱离川人统治，建立独立政权。\n\n切丹政权的成功得益于：\n\n• **战略地理位置**：在沿海地区建立双海港（赤丹港和乌丹港）\n\n• **灵活的外交策略**：利用瓦伦迪亚与川帝国的矛盾，实行中立政策\n\n切丹家族为避免内战，将双海港分别交给两个儿子治理，形成了赤丹港侧重金属加工业、乌丹港专注奢侈品贸易的分工格局。这种模式不仅促进了经济繁荣，也为后来的联邦制度提供了早期实践经验。\n\n### 4.2 瓦伦迪亚的统一与联邦共和制的诞生\n\n**公元409年**，受双丹独立的鼓舞，瓦伦迪亚各城邦通过条约完成统一，创立了独特的**联邦共和制**。这一政治制度的创新包括：\n\n• **城邦代表制度**：各城邦根据人口比例选派代表\n\n• **议会决策机制**：重要事务由城邦代表组成的议会投票决定\n\n• **法律面前平等**：确立了超越城邦界限的公民权利\n\n瓦伦迪亚的统一并非通过军事征服，而是基于共同商业利益的自愿联合。这种和平统一模式在新川大陆文明史上独树一帜，反映了商业文明对政治制度的深刻影响。\n\n### 4.3 斯尔吉亚的军事扩张与北境霸权\n\n斯尔吉亚在建立后迅速发展成为北境强国，其成功的关键因素包括：\n\n**军事制度创新**：\n\n• 建立专业化的骑兵部队，职业军队就此诞生\n\n• 发展先进的弓箭技术和战术\n\n• 高效的信仰提供强力的军事动员\n\n**战略资源控制**：\n\n• 占领万通港口，控制东西贸易的北方海上通道\n\n• 开发东部草原作为战马繁育基地\n\n• 建立覆盖北境的军事要塞网络\n\n斯尔吉亚的军事扩张使其成为强大的军事帝国，其骑兵部队在大陆北部所向披靡，形成了独特的军事文化和贵族统治体系。\n\n### 4.4 伊塞尔的统一与现代化\n\n在经历了长达数百年的分裂与动荡后，**艾**于公元1世纪末崛起，通过军事征服和外交联盟，重新统一了伊塞尔各割据势力。艾的统一不仅结束了内乱，还：\n\n• 建立了中央集权的行政体系\n\n• 改革军事制度，吸收先进战术\n\n• 发展与周边文明的贸易关系\n\n艾的统一标志着**现代伊塞尔文明**的确立，使伊塞尔重新成为大陆西部的重要力量。伊塞尔文明在经历长期分裂后，吸收了多元文化元素，形成了独特的社会结构和文化传统。\n\n## 第五章：跨文明专题研究\n\n### 5.1 技术传播与文明互动\n\n新川大陆文明发展的重要特征是技术的跨文明传播，其中**水利技术**和**金属冶炼技术**的传播最为关键：\n\n**水利技术传播路线**：\n\n• 起源：米亚人\n\n• 传播路径：向西传入瓦伦，随后北上穿越沙漠传入霜狼高原和伊塞尔；\n\n向北被川人吸纳，随后再次向北传入斯尔吉亚。\n\n• 技术演变：从河流治理到水利灌溉，再到水力工业。\n\n**金属冶炼技术传播**：\n\n• 起源：川人的善于冶炼的一支\n\n• 传入路径：自被发现，迅速在川人文化普及，随后向四周辐射，向北进入斯尔吉亚，向西进入伊塞尔，向西南进入瓦伦迪亚。\n\n• 社会影响：改变军事格局，促成新贵族崛起，引发社会结构变革\n\n技术传播不仅是工具和方法的转移，更是知识体系和思维方式的交流，促进了各文明的创新与发展。\n\n### 5.2 宗教演变与精神文化\n\n新川大陆各文明发展出丰富的宗教体系，这些宗教既反映了各民族的生存环境，也塑造了他们的文化特征：\n\n**霜狼信仰**：\n\n• 起源：伊塞尔人北迁分支在霜狼高原的生存体验\n\n• 发展：与米亚人宗教观念融合，形成蒙里米亚国教\n\n• 特征：自然崇拜与祖先崇拜结合，动物图腾（霜狼）为核心象征\n\n**山神信仰**：\n\n• 起源：斯特人在\"神之息\"山谷的定居经历\n\n• 演变：与川人游牧文化融合，形成斯尔吉亚的军事神学\n\n• 影响：强化了军事贵族的统治合法性\n\n宗教不仅是精神寄托，也是社会整合的工具，在蒙里米亚的政教合一和斯尔吉亚的军事动员中发挥了关键作用。\n\n两种信仰均在极度寒冷的自然条件压迫下产生，或许信仰能成为人类在危难面前支撑活下去的精神源泉。\n\n### 5.3 政治制度的多样性与创新\n\n帝国封建时期，新川大陆各文明发展出多样化的政治制度，反映了不同的社会结构和文化传统：\n\n**蒙里米亚的政教合一制**：\n\n• 权力结构：宗教领袖同时担任政治首脑\n\n• 治理方式：以宗教律法为基础，祭司阶层参与行政管理\n\n• 优势与局限：强化社会凝聚力，但限制思想创新\n\n**瓦伦迪亚的联邦共和制**：\n\n• 权力结构：城邦代表组成的议会为最高权力机构\n\n• 决策机制：多数投票制，城邦享有高度自治权\n\n• 优势与局限：促进商业发展和文化多元，但决策效率较低\n\n**斯尔吉亚的军事贵族制**：\n\n• 权力结构：军事精英组成的贵族会议掌握实权\n\n• 社会流动：基于军功的晋升体系，保持军事活力\n\n• 优势与局限：形成强大军事力量，但容易引发对外扩张\n\n**双丹的商业寡头制**：\n\n• 权力结构：富裕商人组成的寡头集团控制政治\n\n• 治理特点：以商业利益为导向，灵活的外交政策\n\n• 优势与局限：促进经济繁荣，但可能忽视社会公平\n\n这些政治制度的多样性反映了新川大陆文明发展的丰富性，也为不同环境下的社会治理提供了多样化的解决方案。\n\n## 第六章：文明互动与历史影响\n\n### 6.1 贸易网络的构建与文化交流\n\n**公元500年后**，新川大陆形成了以覆盖多帝国的贸易网络：\n\n**主要贸易路线**：\n\n• 沙漠商路：自川帝国京师一路向西，穿越沙漠，连接各个大型城市，最终抵达伊塞尔城。这条商路是大陆最重要的陆地贸易。\n\n• 双丹商路：双丹港口作为贸易基站，东连川帝国东海岸五大港口，西连瓦伦，西门。（西帝国唯一港口，西帝国是川文化的扩张）\n\n• 北方航道：自万通港至米亚基斯，是东西贸易最为高效的商路。\n\n• 东部丝绸之路：川帝国盛产的丝绸等奢饰品向北连接斯尔吉亚，进入万通港，向东进入五大港，向西南进入瓦伦，是最重要的奢侈品贸易路线。\n\n贸易不仅促进了商品流通，也带来了文化交流：\n\n• 语言的相互影响：各文明词汇的借用与语法结构的趋同\n\n• 科技知识的传播：农业技术、手工业方法的跨文明交流\n\n### 6.2 军事冲突与文明融合\n\n军事冲突虽然带来破坏，但也促进了文明间的融合：\n\n古典时期三大战争\n\n**伊塞尔-蒙里米亚战争（公元前309年）**：\n\n• 直接结果：伊塞尔失败，蒙里米亚巩固高原统治\n\n• 长远影响：促进军事技术交流，伊塞尔内乱为艾的统一创造条件\n\n**斯尔吉亚扩张（公元100-200年）**：\n\n• 军事策略：骑兵部队的灵活运用，要塞体系的建设\n\n• 文化影响：斯特人与川人文化的深度融合，形成新的文化认同\n\n• 长远影响：夺取万通港，占据东部大草原，为斯尔吉亚的强盛奠定基础\n\n**双丹独立战争（公元404年）**：\n\n• 政治影响：打破川人霸权，开启联邦共和实验\n\n• 经济影响：促进商业网络形成，改变大陆权力格局\n\n### 6.3 主要文明的历史地位与贡献\n\n**蒙里米亚文明**：\n\n• 独特贡献：政教合一制度的实践，高原农业技术的创新\n\n• 文化遗产：丰富的宗教典籍，独特的艺术风格，水利工程技术\n\n**瓦伦迪亚文明**：\n\n• 独特贡献：联邦共和制度的早期实践，商业文化的发展\n\n• 文化遗产：法律体系，商业契约传统，城市规划理念\n\n**斯尔吉亚文明**：\n\n• 独特贡献：骑兵战术的革新，游牧与农耕文化的融合\n\n• 文化遗产：军事训练体系，马术技术，多元文化融合模式\n\n**双丹文明**：\n\n• 独特贡献：商业网络的构建，城邦联盟的治理经验\n\n• 文化遗产：航海技术，金融制度，国际贸易规范\n\n**伊塞尔文明**：\n\n• 独特贡献：在分裂与统一中探索社会整合的路径\n\n• 文化遗产：铁器制造技术，行政管理体系，文学传统\n\n## 第七章：终论\n\n新川大陆的文明发展史是一部多元文化互动、冲突与融合的史诗。从远古时期山人与林人的分化，到古典农业时期的技术传播，再到帝国封建时期的政治创新，各文明在适应环境、应对挑战的过程中，发展出独特的文化特征和社会结构。\n\n蒙里米亚的宗教整合、瓦伦迪亚的商业智慧、斯尔吉亚的军事创新、双丹的贸易网络、伊塞尔的社会变革，共同构成了新川大陆文明的丰富图景。这些文明虽然发展路径各异，但都对大陆的整体发展做出了独特贡献。\n\n新川大陆文明发展的历史启示：\n\n1\\. 环境适应是文明存续的基础，各文明都发展出适应特定环境的生存策略\n\n2\\. 技术创新和传播是文明进步的关键驱动力\n\n3\\. 文化融合能够创造新的文明形态，增强社会活力\n\n4\\. 政治制度的多样性反映了不同社会结构的适应性需求\n\n5\\. 贸易网络的构建促进了物质与文化的交流，推动整体发展\n\n新川大陆的文明发展史表明，文明的进步不是单一模式的复制，而是多元文化在互动中共同演进的过程。这种多元一体的发展模式，为理解人类文明的多样性和统一性提供了重要视角。\n\n## 附录：新川大陆文明年表\n\n• **公元前2000年**：山人与林人爆发争斗，林人被迫迁徙\n\n• **公元前1800年**：山人分化为川人、海人、米亚人\n\n• **公元前1700年**：斯特人建立坤达帖木儿，北境文明诞生\n\n• **公元前1600年**：瓦伦人建立拜亚城，西南文明奠基\n\n• **公元前1400年**：伊塞尔人分化，西支建立伊塞尔城\n\n• **公元前1100年**：海人消亡，土地被川人兼并\n\n• **公元前1000年**：川人兼并米亚人，引发米亚远行\n\n• **公元前800年**：米亚人与瓦伦人融合，瓦伦迪亚文明形成\n\n• **公元前700年**：米亚人抵达霜狼高原，蒙里米亚文明萌芽\n\n• **公元前500年**：川人与兰川人融合，形成新川人\n\n• **公元前400年**：川人游牧分支与斯特人融合，形成斯尔人\n\n• **公元前309年**：伊塞尔进攻霜狼高原失败，陷入内乱\n\n• **公元前307年**：大先知蒙完成宗教改革\n\n• **公元前110年**：蒙里米亚完成政教合一\n\n• **公元前77年左右**：艾统一伊塞尔，伊塞尔文明确立\n\n• **公元101年**：斯尔人占领坤达帖木儿，建立斯尔吉亚\n\n• **公元404年**：切丹独立，双丹文明兴起\n\n• **公元409年**：瓦伦迪亚完成统一，联邦共和制确立\n\n• **公元500年后**：新川大陆跨文明贸易网络形成","tags":["History","Repost"],"categories":["轉載"]},{"title":"[CO Pre]Verilog 入门","url":"/posts/c9f56abd/","content":"# 序\n这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Verilog 部分。\n\n<!--more-->\n\n***\n\n# IDE\n本文使用 ISE 开发与仿真。\n\n***\n\n# Verilog 语法\n## 模块的定义方法\n模块（module）是 Verilog HDL 的基本功能单元，它实际上代表了具有一定功能的电路实体。通俗来讲，其代表了电路中被导线连接的各个功能模块（子电路）。  \n\n以一个与门为例：  \n方法一：  \n```verilog\nmodule AndGate(\n    input i1,\n    input i2,\n    output o\n);// 模块名定义、端口定义及IO说明\n    assign o = i1 & i2; // 模块功能定义\nendmodule// 结束模块定义\n```\n\n方法二：  \n```verilog\nmodule AndGate(i1,i2,o); // 模块名定义及端口定义\n    input i1;\n    input i2; // 也可合并为一句: input i1,i2;\n    output o;\n    // 上为IO说明\n    assign o = i1 & i2; // 模块功能定义\nendmodule // 结束模块定义\n```\n两种方法没有实质上的区别，只是形式上有所不同：方法 1 对方法 2 中的端口定义及 IO 说明进行了合并。  \n模块以 `module` 开始，`endmodule` 结束，中间包括模块名、端口定义、I/O 说明等部分。++模块中的语句除了顺序执行的语句块以外都是并行的++；输入输出端口若不特别说明类型及位宽，++默认为 1 位 `wire` 型++。\n\n## 常用数据类型\n### Wire 型\n`wire` 型数据属于线网 `nets` 型数据，通常用于表示组合逻辑信号，可以将它类比为电路中的导线。它本身并不能存储数据，需要有输入才有输出（这里输入的专业术语叫驱动器），且输出随着输入的改变而即时改变。一般使用 `assign` 语句对 `wire` 型数据进行驱动（`assign` 语句将在下一节中进行讲解）。\n\n`wire` 型的数据分为标量（1 位）和向量（多位）两种。可以在声明过程中使用范围指示器指明位数，如 `wire [31:0] a`;。冒号两侧分别代表最高有效位（MSB, Most Significant Bit）和最低有效位（LSB, Least Significant Bit）。在访问时，可以使用形如 `a[7:4]` 的方式取出 `a` 的第 7-4 位数据。\n\n::: tips\n声明位宽时，如果写作 `wire [0:31] a` 也是可以的。此时高位被指定为第 0 位，低位被指定为第 31 位。为其赋值时 `a = 32'h1234_5678` 1 会实际存储在首位，而 8 会存储在末位，与正常相反。\n:::\n\n{% note warning %}\n信号定义好之后，不仅决定了位宽还决定了方向，例如定义为 `[4:7]` 的 `b` 信号，四个管脚分别为 4，5，6，7，在使用中只能正向接，不能反向接。因此接 `b[4:7]` 是合法的，而 `b[7:4]` 是不合法的；同理接 `c[8:11]` 是合法的，接 `c[11:8]` 是不合法的。（“接”指赋值操作）\n{% endnote %}\n\n{% note info %}\n在 Verilog 里，信号的位宽可以通过 `in[a:b]` 这样的语法来取一部分:\n```verilog\nassign out = in[7:4];//取 in 的第 7-4 位\n```\n这里的 `a` 和 `b` 都必须是++常量++，不能包含变量。比如写成 `assign out = in[m * 4 + 3:m * 4]` 就会报错，因为 `m` 是一个变量。  \n但是，Verilog-2001/SystemVerilog 提供了一种叫 part-select with variable index 的写法:  \n```verilog\nassign out = in[start +: width];//从 start 位开始往高位取 width 位\nassign out = in[start -: width];//从 start 位开始往低位取 width 位\n```\n这里的 start 则可以是变量，而 width 必须是常量。\n{% endnote %}\n\n\n### Reg 型\n`reg` 型是寄存器数据类型，具有存储功能。它也分为标量和向量，类似 `wire` 型，可以类比前面的教程。一般在 `always` 块内使用 `reg` 型变量（`always` 块将在本章后面提到），通过赋值语句来改变寄存器中的值。为了确定何时进行赋值，我们经常需要用到各种控制结构，包括 `while`、`for`、`switch` 等，这与 C 语言中的做法十分相似。  \n\n需要注意的是，`reg` 型变量++不能使用 `assign` 赋值++。而且，`reg` 型++并不一定被综合成寄存器++，它也可和 `always` 关键字配合（下一节会讲到），建模组合逻辑。  \n\n我们可以通过对 `reg` 型变量建立数组来对存储器建模，例如 `reg [31:0] mem [0:1023]`;，其中前面的中括号内为位宽，后面的中括号内为存储器数量。这种写法在我们开始搭建CPU后会用到。  \n我们可以通过引用操作访问存储器型数据元素，类似于位选择操作，例如 `mem[2]` 就是访问 `mem` 中的第 3 个元素。  \n\n::: tips\nVerilog HDL 中++没有++多维数组。\n:::\n\n\n### 数字字面量\nVerilog 中的数字字面量可以按二进制（b 或 B）、八进制（o 或 O）、十六进制（h 或 H）、十进制（d 或 D）表示。\n\n数字的完整表达为 `<位宽>'<进制><值>`，如 `10'd100`。省略位宽时采用默认位宽（与机器有关，一般为 ++32 位++），省略进制时默认为++十进制++，值部分可以用下划线分开提高可读性，如 `16'b1010_1011_1111_1010`。\n\nVerilog 中除了普通的数字以外，还有两个特殊的值：`x` 和 `z`。`x` 为不定值，当某一二进制位的值不能确定时出现，变量的默认初始值为 `x`。`z` 为高阻态，代表没有连接到有效输入上。对于位宽大于 1 的数据类型，`x` 与 `z` 均可只在部分位上出现。  \n\n::: warning\n注意数字的位宽决定了数字的最大值。比如 `3'd101` 就是一个非法的数字，因为 3 位宽的数字最大值为 7。\n:::\n\n::: warning\nVerilog 数字本身并不能添加负号，但写作类似于 `-8'd5` 这样的形式可以看作是对数字的运算，是合法的。\n:::\n\n### Integer 型\n`integer` 数据类型一般为 32 位，与 C 语言中的 `int` 类似，默认为有符号数，在我们的实验中主要用于 `for` 循环（将在本章后面提到）。\n\n### Parameter 型\n`parameter` 类型用于在编译时确认值的常量，通过形如 `parameter 标识符 = 表达式`; 的语句进行定义，如：`parameter width = 8`;。在实例化模块时，可通过参数传递改变在被引用模块实例中已定义的参数（模块的实例化将在后面的章节进行介绍）。`parameter` 虽然看起来可变，但它属于常量，在编译时会有一个确定的值。\n\n`parameter` 可以用于在模块实例化时指定数据位宽等参数，便于在结构相似、位宽不同的模块之间实现代码复用。\n\n## 组合逻辑建模常用语法\n### Assign 语句\n`assign` 语句是连续赋值语句，是组合逻辑的建模利器，其作用是用一个信号来驱动另一个信号。如 `assign a = b`;，其中 `a` 为 `wire` 型（也可由位拼接得到，见运算符部分），`b` 是由数据和运算符组成的表达式。  \n\n`assign` 语句与 C 语言的赋值语句有所不同，这里“驱动”的含义类似于电路的连接，也就是说，`a` 的值++时刻++等于 `b`。这也解释了 `assign a = a + 1`; 这样的语句为什么是不合法的。由于这样的特性，`assign` 语句不能在 `always` 和 `initial` 块中使用。  \n\n`assign` 语句经常与三目运算符配合使用建模组合逻辑。一般来说，`assign` 语句综合出来的电路是右侧表达式化简后所对应的逻辑门组合。  \n\n{% note warning %}\n- `reg` 类型不能被 `assign` 赋值。\n- 未被 `assign` 赋值（驱动）过的 `wire` 类型数据不能被赋给其他的 `wire` 类型数据。未被 `assign` 过的 `wire` 类型就好比什么都没连接的导线，它和其它导线连接是没有意义的。\n- 1 位的变量，不可以被两次 `assign`，多位的变量，每一位只能被一次 `assign`。比如 `wire [3:0] output; assign output[1:0] = 2'b01; assign output[3:2] = 2'b10;` 这是合法的。而 `assign output = 4'b0; assign output[1:0] = 2'b01;` 是不合法的，因为 0 位和 1 位被两次赋值。\n{% endnote %}\n\n### 运算符\n这里只介绍和 C 语言有差异的运算符。  \n\n- Verilog 中没有自增和自减运算符。\n- 操作数中有不定值 `x` 和高阻态 `z` 时，结果中也可能出现。\n- 逻辑右移 `>>` 和算术右移 `>>>`\n    - 它们的区别主要在于前者在最高位补 0，而后者在最高位补符号位。\n- 相等比较运算符 `==` 和 `===`、不等比较运算符 `!=` 和 `!==`\n    - `==` 和 `!=` 可能由于不定值 `x` 和高阻值 `z` 的出现导致结果为不定值 `x`，而 `===` 和 `!==` 的结果一定是确定的 0 或 1（`x` 与 `z` 也参与比较）。\n- 阻塞赋值 `=` 和非阻塞赋值 `<=`\n    - 不同于 `assign` 语句，这两种赋值方式被称为过程赋值，通常出现在 `initial` 和 `always` 块中，++为 `reg` 型变量赋值++。这种赋值类似 C 语言中的赋值，不同于 `assign` 语句，赋值仅会在一个时刻执行。由于 Verilog 描述硬件的特性，Verilog 程序内会有大量的并行，因而产生了这两种赋值方式。这两种赋值方式的详细区别会在[之后的小节内](#assignment)介绍，这里暂时只需记住一点：为了写出正确、可综合的程序，++在描述时序逻辑时要使用非阻塞式赋值 `<=`++。\n- 位拼接运算符 `{}`\n    - 这个运算符可以将几个信号的某些位拼接起来，例如 `{a, b[3:0], w, 3'b101}`;；可以简化重复的表达式，如 `{4{w}}` 等价于 `{w,w,w,w}`；还可以嵌套，`{b, {3{a, b}}}` 等价于 `{b, {a, b, a, b, a, b}}`，也就等价于 `{b, a, b, a, b, a, b}`。\n- 缩减运算符\n    - 运算符 `&`（与）、`|`（或）、`^`（异或）等作为*单目运算符*是对操作数的**每一位汇总运算**，如对于 `reg[31:0] B`; 中的 `B` 来说，`&B` 代表将 `B` 的*每一位*与起来得到的结果。\n\n## 时序逻辑建模常用语法\n### Always 块\n`always` 块有如下两种用法：\n- 若 `always` 之后紧跟 `@(...)`，其中括号内是敏感条件列表，表示当括号中的条件满足时，将会执行 `always` 之后紧跟的语句或顺序语句块（和 C 语言中的语句块类似，只是将大括号用 `begin` 和 `end` 替换了）。这种用法主要用于++建模时序逻辑++。  \n例如：\n```verilog\nalways @(posedge clk)  // 表示在 clk 上升沿触发后面的语句块\nbegin\n// 一些操作\nend\n```\n- 若 `always` 之后紧跟 `@ *` 或 `@(*)`，则表示对++其后紧跟的语句或语句块++内++所有信号++的变化敏感。这种用法主要用于与 reg 型数据和阻塞赋值配合，建模组合逻辑。\n- 若 `always` 紧跟语句，则表示在该语句执行完毕之后立刻再次执行。这种用法主要配合后面提到的时间控制语句使用，来产生一些周期性的信号。   \n\n`always` 的敏感条件列表中，条件使用变量名称表示，例如 `always @(a)` 表示当变量 `a` ++发生变化++时执行之后的语句；若条件前加上 `posedge` 关键字，如 `always @(posedge a)`，表示当 `a` 达到++上升沿++，即从 0 变为 1 时触发条件，下降沿不触发；加上 `negedge` 则是下降沿触发条件，上升沿不触发。每个条件使用逗号 , 或 `or` 隔开，只要有其中一个条件被触发，`always` 之后的语句都会被执行。  \n\n::: tips\n敏感条件是变量时，该变量只要变化就会触发执行，没有对高低电平的要求。\n:::\n\n::: warning\n多个 `always` 块中对同一个变量进行赋值会导致无法综合。\n:::\n\n### Initial 块\n`initial` 块后面紧跟的语句或顺序语句块在硬件仿真开始时就会运行，且仅会运行一次，一般用于对 `reg` 型变量的取值进行初始化。`initial` 块通常仅用于仿真，是*不可综合的*。下面的代码用于给寄存器 `a` 赋初始值 0：\n```verilog\nreg a;\n\ninitial begin\n    a = 0;\nend\n```\n\n{% note warning %}\n`wire` 型数据不能在 `always` 和 `initial` 块中赋值。  \n`wire` 类型本质上模拟硬件电路中的物理导线，它本身不具备存储功能，仅用于传递信号（从驱动源到接收端）。导线的特性是 “即时响应驱动源”—— 驱动源的信号变化会立即通过导线传递，没有时间延迟或状态保持。  \n而 `always` 块描述的是时序逻辑或组合逻辑的 “计算过程”，通常包含条件判断、状态跳转等逻辑，其赋值对象需要具备 “根据逻辑计算结果更新状态” 的能力。`wire` 作为导线，无法承载这种 “计算后更新” 的语义，因此不能作为 `always` 块的赋值目标。\n{% endnote %}\n\n> **语句块**  \n> 块语句的作用是将多条语句合并成一组，使它们像一条语句那样。在使用上一节提到的各种控制语句或者要使用 `always`/`initial` 过程块时，如果要执行多条语句，就可以使用块语句，这就类似于 C 语言中大括号里的语句。\n> 块语句有两种：顺序块和并行块。顺序块的关键字是 `begin` - `end`，并行块的关键字是 `fork` - `join`，关键字位于块语句的起始位置和结束位置，相当于 C 语言中的左大括号和右大括号。块语句也可以嵌套。\n> 1. 顺序块中的语句是一条接一条按顺序执行的，只有前面的语句执行完成之后才能执行后面的语句，除非是带有内嵌延迟控制的非阻塞赋值语句。\n> 2. 如果语句包括延迟，那么延迟总是相对于前面那条语句执行完成的仿真时间的。\n\n### If 语句\nVerilog 中 `if` 语句的语法和 C 语言基本相同，也有 `else if`、`else` 这样的用法。但是，++`if` 语句只能出现在顺序块中++，其后的分支也只能是语句或顺序块。举例如下（下面的例子也使用了 `always` 建模组合逻辑）：\n```verilog\nalways @ * begin\n    if (a > b) begin\n        out = a;\n    end\n    else begin\n        out = b;\n    end\nend\n```\n\n### Case 语句\nVerilog 中的 `case` 语句与 C 语言的写法略有区别，详见下方的示例。`case` 语句同样只能出现在++顺序块++中，其中的分支也只能是语句或顺序块。与 C 语言不同，++`case` 语句在分支执行结束后不会落入下一个分支++，而会++自动退出++。举例如下：\n```verilog\nalways @(posedge clk) begin\n  case(data)\n      0: out <= 4;\n      1: out <= 5;\n      2: out <= 2;\n      3: begin\n          out <= 1;\n      end\n      default: ;\n  endcase\nend\n```\n\n::: tips\nVerilog 中的 `case` 语句默认做的是全等比较，即所有位都相等（包括 `x` 和 `z`）。上例中 `data === 0` 时 `out` 才会赋值为 4。\n:::\n\n### For 语句\n`for` 语句和 C 语言中的类似。  \n#### 循环变量\n`integer` 类型和 `reg` 类型的变量均可以作为循环变量，但 `reg` 型需要注意位宽的设置以免造成++死循环++，譬如：  \n{% note danger %}\n以下代码会造成 Isim 崩溃。\n```verilog\nreg [1:0] tmp;\ninitial begin\n    for (tmp = 2'h0; tmp <= 2'h3; tmp = tmp + 1) begin\n        $display(\"tmp = %d\", tmp);\n    end\n    $display(\"Finished.\")\nend\n```\n{% endnote %}\n\n这是因为 `tmp` 位宽为 2，最大只能到 2'h3，当 `tmp` 等于 2'h3 时，下一轮循环 `tmp` 溢出，回到 2'h0，如此往复导致死循环。\n\n### While 语句\n`while` 语句和 C 语言中的类似。  \n\n::: tips\n在 Verilog 中所有的循环语句只能在 always 或 initial 块中使用。\n:::\n\n## 模块实例化\n对于一个已经存在的模块 `Sample`，以及其定义好的接口 `input a`, `input b`, `output c`，我们可以通过以下方法进行实例化：  \n```verilog\nwire x;\nwire y;\nwire z;\nSample sample_instance1 (x, y, z);//这里，x, y, z 会自动匹配 Sample 模块定义时的形参顺序。\nSample sample_instance2 (.b(x), .a(y), .c(z));//这里，.b, .a, .c 是为形参指定了匹配的实参。\n```\n\n<a id=\"assignment\"></a>\n\n## 非阻塞赋值和阻塞赋值\n考察以下代码：  \n```verilog\nmodule blocked_and_non_blocked(\n    input clk,\n    input a,\n    output reg b_blocked,\n    output reg c_blocked,\n    output reg b_non_blocked,\n    output reg c_non_blocked\n    );\n\n    // 非阻塞赋值\n    always @(posedge clk) begin\n        b_non_blocked <= a;\n        c_non_blocked <= b_non_blocked;\n    end\n    // 阻塞赋值\n    always @(posedge clk) begin\n        b_blocked = a;\n        c_blocked = b_blocked;\n    end\nendmodule\n```\n\n### 非阻塞赋值\n`clk` 上升沿到来的时候，可以认为仿真器为 `<=` 右侧的变量做了一次“快照”，即存储了它们的值。然后将“快照”值赋给了 `<=` 左侧的变量。在上述代码中，`b_non_blocked` 值变为 `a` 的值，而 `c_non_blocked` 值变为原来的 `b_non_blocked` 值。\n\n::: tips\n处在一个 `always` 块中的非阻塞赋值是在块结束时同时并发执行的。\n:::\n\n### 阻塞赋值\n阻塞赋值是++顺序执行++的。在 `begin` - `end` 顺序块中，前一句阻塞赋值完成后，后一句阻塞赋值才会开始。在上述代码中，上升沿到来时，`b_blocked` 值变为 `a` 的值，然后 `c_blocked` 值才变为新的 `b_blocked` 值，即 `a` 的值。\n\n::: warning\n在时序逻辑中的阻塞赋值可能是不可综合的。\n:::\n\n## 有符号数的处理\n`wire`, `reg` 等类型的数据默认是++无符号++的。  \n\n若要声明该数据是有符号的，需要使用 `$signed()`，例如 `$signed(a)`。  \n\n### 一个简单的例子\n```verilog\nmodule comparator(\n    input clk,\n    input reset,\n    input [3:0] a,\n    input [3:0] b,\n    output res\n    );\n\n    assign res = a >= b;\n\nendmodule\n```\n\n我们编写一个 Testbench 来测试，令 `a` 和 `b` 的初始值都为 1，100 ns 后令 `b` 为 -1。  \n我们期望看到 `res` 的值恒为 1，但是实际观测到 100 ns 后 `res` 的值变为 0。  \n这正是因为我们没有声明 `b` 是有符号数。Verilog 默认其为无符号数，当 `b` = -1 时，其补码为 4'b1111，会被认为是 15。  \n将比较代码修改为 `assign res = $signed(a) > $signed(b);`，程序即可达到预期结果。  \n\n值得一提的是，假如将比较代码修改为 `assign res = a > $signed(b);`，得到的结果也达不到预期效果。\n\n在对无符号数和符号数同时操作时，Verilog 会自动地做数据类型匹配，将符号数向无符号数转化。因为在执行 `a > $signed(b)` 时，`a` 是无符号数，`$signed(b)` 是符号数，Verilog 默认向无符号类型转化，得到的结果仍是无符号数的比较结果。  \n\n关于符号数和无符号数的原理，您可参考[这里](https://cscore.e1.buaa.edu.cn/tutorial/verilog/verilog-3/verilog-3-7/#_3)。简单地概括，++一个表达式，只要其子表达式中有任一表达式是无符号，则该表达式就是无符号的++。  \n\n### 一些注意事项\n- 对于++移位运算符++，其++右侧的操作数总是被视为无符号数++，并且++不会对运算结果的符号性产生任何影响++。结果的符号由运算符左侧的操作数和表达式的其余部分共同决定。\n- 对于++三目运算符++，其 `?` 前的布尔表达式是自决定的表达式，不会对最外层表达式的符号造成影响。\n- 算术右移在++左操作数无符号时++高位仍然补 ++0++，与逻辑右移效果相同。\n- 未指定位宽和进制的 0 的有无符号性是根据上下文决定的。而指定了位宽和进制的 0（比如 4'b0000）的符号是确定的。\n\n## 宏定义\n宏定义格式如下：\n```verilog\n`define WORDSIZE 8\n// 省略模块定义\n reg[1:`WORDSIZE] data;\n// 相当于定义 reg[1:8] data;\n```\n\n定义时，需要以反引号（`` ` ``）开头。使用时，也需要加上反引号。\n\n***\n\n# Verilog 例题\n## 电梯调度\n### 简介\n一栋大楼有一部运行的电梯，你需要根据乘客请求和电梯状态来输出。\n\n### 电梯的具体信息\n- 在最开始或者每次 reset 后，电梯默认初始楼层为一楼。保证在输入到来前先进行 reset。\n- 初始运行方向：每次 reset 后，电梯默认向上运行。\n- 运行范围：1 至 7 层。\n- 调度规则：\n    - 如果当前周期没有乘客请求 (乘客请求详细信息见下文)，则电梯将会按照当前的运行方向运动一层，并在下一周期更新楼层；如果位于边界楼层且运行方向越界，则反转运行方向并运动一层。\n    - 如果当前周期有乘客请求，且乘客请求楼层与当前电梯所在楼层不相同，则电梯将会向乘客请求楼层方向移动一层，并在下一周期更新楼层，电梯运行方向也调整为向乘客请求楼层运行的方向 (若与原来方向一致则不用调整) 。\n    - 如果当前周期有乘客请求，且乘客请求楼层与当前电梯所在楼层相同，则电梯将保持不动，并在下一周期维持楼层，电梯运行方向不改变。\n\n### 乘客请求\n- 存在乘客请求的条件：\n    - 若 from = 0 并且++不存在未完成的乘客请求++，则视为当前周期没有乘客请求。反之，如果 from != 0 或者+存在未完成的乘客请求++，则视为当前周期有乘客请求。\n    - 若 from != 0，则视为当前周期有新到来的乘客请求。该乘客请求将会一直存在直到满足取消条件 ( 即使后续周期 from = 0 ) ，在此期间内视为：存在一个未完成的乘客请求。\n    - 若 from = 0 并且++存在一个未完成的乘客请求++，则该乘客请求继续存在直至满足取消条件。\n- 取消乘客请求的条件：\n    - 若当前周期的乘客请求楼层和电梯的当前所在楼层相同，则视为满足该请求的取消条件，在下一个周期开始时取消该请求。\n    - 若当前周期有 reset 信号，则在下一周期取消该乘客请求。\n- 其他规则：输入数据保证在上一个乘客请求满足取消条件之前，不会输入下一个乘客请求。 也就是当 from != 0 时，当前一定不存在未完成的乘客请求。\n\n### 输出要求\n当乘客请求楼层和电梯的当前所在楼层相同时，输出 1 ；否则输出 0 。\n\n### 样例\n![样例](elevator.png)\n如图，在 reset 后电梯默认从一楼向上运行。  \n在电梯运行到三楼时，输入了一楼的乘客请求，于是下个周期电梯向乘客请求楼层 (一楼) 方向运行，回到了二楼。然后再下个周期电梯到了一楼，此时电梯楼层和乘客请求楼层相同，因此输出 out 置为 1 ,同时下个周期电梯保留楼层和运行方向。再下个周期输入为 0，电梯掉头向上运行，同时取消上一个乘客请求。\n\n当电梯继续运行到五楼时，输入了同层五楼的乘客请求，输出 out ++立刻++置为 1 ，同时下一周期电梯保留原楼层和运行方向，同时取消乘客请求。再下个周期输入为 0，电梯正常向上运行至六楼。\n\n::: warning\n请认真阅读波形图，一切逻辑以波形图所示为准！\n:::\n\n### 分析\n本题适合用时序逻辑来解决。按照题意，在没有乘客请求的时候，电梯全自动运行，故首先我们需要解决这个问题。我们应当维护两个变量，它们分别是当前的楼层和电梯运行方向，记作 `cur_floor` 和 `direction`。简单起见，由于楼层只有七层，可以用一个 3 位二进制数表示（001 至 111），方向则用 0 和 1 表示上与下，简略代码如下：  \n\n```verilog\ninitial begin//初始化在一楼，向上\n    ...\nend\n\nalways@(posedge clk) begin\n    if (reset == 1) begin//reset逻辑\n        ...\n    end\n    else begin\n        if (direction == 0) begin//上\n            if (cur_floor == 3'b111) begin//顶楼\n                direction <= 1;\n                cur_floor <= cur_floor - 1;\n            end\n            else begin//未到顶楼\n                cur_floor <= cur_floor + 1;\n            end\n        end\n        else begin//下\n            ...//类似逻辑\n        end\n    end\nend\n```\n\n如果有乘客请求，其实有两种情况需要考虑：\n- 当 `from` 信号出现的时候，电梯尚未到该楼层。\n- 当 `from` 信号出现的时候，电梯已经到该楼层。\n\n如果电梯还没到，则需要想办法保存下这个乘客请求的楼层号，然后及时调整电梯运行方向。当某个上升沿确认 `cur_floor` 等于 `from` 的楼层（当然这个 `from` 是一个副本，因为 `from` 输入可能只持续一个周期就归零了，接下来将把这个副本叫做 `request`）时，让下一个周期保持运行方向和楼层不变。++这是样例中 30ns 时发出 1 楼请求的情况++。可以看到，45ns 的上升沿电梯刚好到 1 楼，同时 `request` 等于 `cur_floor`，`out` 置为 1，下一个周期（55ns - 65ns）电梯保持在 1 楼。   \n\n如果发出乘客请求时，电梯正好处于该楼层，则情况稍微会复杂些。按照样例的解释（一切逻辑以样例为准！），100ns 发出 5 楼的请求，此时时钟信号正处于++下降沿++，而 `out` 被++立刻++置为 1。很明显 `out` 的输出采用的组合逻辑的 `assign` 语句，一检测到 `from` 或 `request` 与 `cur_floor` 相匹配就立刻置为 1（对于第一种情况，当然是检测 `request` 的信号，第二种则是 `from`）。再看电梯停留在 5 楼的时间。105ns 时电梯本准备往 6 楼去，而实际上停留在 5 楼，这就说明 105ns - 115ns 是电梯停留的一周期。也就是说，95ns - 105ns 发生了 `cur_floor` 和 `from` 的判定，即在第二种情况下判定并不是发生在上升沿的，而是立即判定！  \n\n我们如果想要电梯停留在某一层一个周期，可以这样写：  \n```verilog\nif (condition) begin\n    cur_floor <= cur_floor;\n    direction <= direction;\nend\n```\n\n无论怎么说，使用非阻塞赋值就决定了这一逻辑一定会在某个上升沿激活。对于第一种情况，我们可以大胆地让 `cur_floor == request` 作为条件，根据“乘客请求-其他规则”，`request` 尚未解决时不会有新的 `from` 出现。可以预见的是一定会在某个上升沿满足条件，然后下一个上升沿执行上述的等待逻辑。对于第二种情况，则大有不同了，接受 `from` 信号后将其赋给 `request` 必定也使用非阻塞赋值，那么 `request` 的赋值要等到 `from` 信号来临的下一个上升沿，即二者会出现一定的时间差。这对于 `out` 的输出，以及电梯的等待，都是不可接受的。具体到样例中，如果接到 `from` 信号后立刻赋给 `request`，那么 105ns 时 `request` 才会被置为 1。如果还用 `cur_floor == request` 作为条件，5 楼的等待时间将会延长到 115ns - 125ns 周期，这就错了。而且 `out` 与 `from` 和 `request` 挂钩，如果在 `request` 已经被赋值（105ns），再用条件判断将其归零，也许要等到下一个上升沿（115ns），这样， `out` 就会从 100ns 一直激活到 115ns。  \n\n总的来说，面对第二种情况，等待逻辑的判定条件必须是 `cur_floor == from`，而且如果满足该条件，就要立刻发出 `request` 归零的命令，让 `request` 赶在下一个上升沿（105ns）就归零，相当于“反悔给 `request` 赋值”（这样做从波形上来看，`request` 不会被赋值，因为赋值和归零都是在上升沿以外的地方进行的），避免 `out` 激活时间过长。\n\n***\n\n# Verilog 工程的设计开发调试\n## 编写可综合代码\n\n::: warning\n以下规则不适用于 Testbench。\n:::\n\n- 勿使用 Initial 块、勿为 Reg 型（寄存器）赋初值。\n- 一个寄存器只能在++一个++ `always` 块中赋值++一次++。  \n以下代码不可综合：  \n```verilog\nreg a;\nwire b, c;\n\nalways @(posedge clk_1) begin\n    a <= b;\nend\n\nalways @(posedge clk_2) begin\n    a <= c;\nend\n```\n\n{% note info %}\n实际上，Reg 型一般会被综合为 D 触发器，只有一个时钟输入，而上述代码让该触发器处于两个时钟域中。  \n\n何谓赋值一次？如果使用 `if` / `else` / `case` 语句进行条件判断，在不同且互斥的情况下对同一个寄存器进行赋值，是完全合法的。而其他情况是不可被综合的。\n{% endnote %}\n\n- 尽量避免综合后的奇怪故障\n    1. 在时序逻辑中，永远使用非阻塞赋值（`<=`）；在组合逻辑中，永远使用阻塞赋值（`=`）；\n    2. 每个组合逻辑运算结果仅在一个 `always @(*)` 中修改；\n    3. 在 `always @(*)` 中，为每个运算结果赋初值，避免 latch[^1] 的产生。\n    4. 使用位运算代替乘除法。\n\n## Verilog 代码规范\n### 命名\n1. 信号名采用 `snake_case`，`PascalCase` 或者 `camelCase`。全工程采用统一命名方式。\n    - `snake_case`：变量名全小写，单词间以下划线连接。\n    - `PascalCase`：首字母全大写。\n    - `camelCase`：第一个字母小写，后续首字母大写。\n\n2. 低电平有效信号用 `_n` 后缀。\n3. 多路选择器标明规格。例如 4 选 1 的 32 位 MUX可记作 `MUX4_1_32`。\n4. 对于状态机，各状态一定要命名，避免在代码中出现不知所云的数字。\n\n### 组合逻辑的编写\n1. 一个信号只在一个 `always` 块中赋值。\n2. 组合逻辑用 `always @(*)` 块或者 `assign`。\n3. 组合逻辑的 `always` 块只用阻塞赋值。\n4. 确保所有分支都赋值，否则出现锁存器[^1]。\n\n### 时序逻辑\n1. 时序逻辑用 `always @(posedge clock)`。\n2. 时序逻辑的 `always` 块只用非阻塞赋值。\n3. 通常情况下，不要用下降沿触发。\n4. 除了 `always` 敏感列表外，不要用时钟信号。\n5. 使用++同步复位++而非异步复位[^2]。\n\n### 代码风格\n1. 单目运算符与变量间++不++添加空格。\n2. 同一逻辑，但表达式复杂的语句，使用换行进行切割：\n```verilog\n// GOOD\nassign d = (op == 0) ? a + b :\n           (op == 1) ? a - b :\n           (op == 2) ? a & b :\n                       a | b;\n// BAD\nassign d = (op == 0) ? a + b :(op == 1) ? a - b :(op == 2) ? a & b : a | b;\n```\n3. 显式声明数字位宽。\n\n\n[^1]:  如果没有初值，编译器会认为需要保持上一次该变量的值不变，这是符合锁存器（Latch）定义的。\n[^2]: ++同步复位（Synchronous Reset）++：复位信号的生效与时钟同步，只有时钟的有效沿到来时才生效。  \n++异步复位（Asynchronous Reset）++：复位信号的生效与时钟无关，只要复位信号有效，立即执行复位操作，无需等待时钟沿。","tags":["CO","CO Pre","Verilog","ISE"],"categories":["計算機組成原理"]},{"title":"[CO Pre]One-Hot 编码","url":"/posts/9707d4af/","content":"\n# 序\n**独热编码**（One-Hot Encoding），又称**一位有效编码**，是一种将分类变量转换为数值形式的常用方法。其核心思想是，将一个具有 N 个不同类别的分类特征转换为 N 个二元（0 或 1）特征，其中每个新特征对应原始特征中的一个类别。对于每一个样本，只有代表其原始类别的那个新特征值为 1，其余所有新特征值均为0。\n\n<!-- more -->\n\n# 原来的问题\n对于一个人，ta 会具有多种属性，比如性别、职业、国籍等等。现在假设有一组人的样本，他们的属性在如下范围内：\n- 性别：男、女\n- 职业：医生、律师、程序员、学生\n- 国籍：中国、美国、法国\n\n如果将上述属性用数字进行表示，会更有利于计算机处理，例如：  \n\n```\n[\"男\", \"医生\", \"中国] -> [0, 0, 0]\n[\"女\", \"程序员\", \"法国\"] -> [1, 2, 2]\n```\n\n但是，这是不适合机器学习的。  \n在机器学习中，许多算法，特别是线性模型（如线性回归、逻辑回归）和距离度量相关的算法（如K近邻），都是基于数值计算的。如果直接将“医生”、“律师”、“程序员”用数字0、1、2来表示（这种方法称为标签编码 Label Encoding），模型可能会错误地学习到这些类别之间存在有序关系。比如“程序员”是“律师”的 2 倍，这是荒谬的。  \n\n因此，我们需要新的方法。  \n\n# One-Hot 编码\n对于性别这一属性，二者天然是互斥的，所以我们可以用一个二维向量来表示：\n\n```\n[1, 0] 男\n[0, 1] 女\n```\n\n对于职业，则可以用四维向量来表示：\n\n```\n[1, 0, 0, 0] 医生\n[0, 1, 0, 0] 律师\n[0, 0, 1, 0] 程序员\n[0, 0, 0, 1] 学生\n```\n\n独热编码通过将每个类别独立表示为一个特征，完美地解决了这个问题。每个类别都处于一个正交的向量空间中，它们（例如 [1, 0, 0]、[0, 1, 0] 和 [0, 0, 1]）之间的距离是相等的，从而消除了标签编码可能引入的虚假顺序关系，让模型能够更准确地学习特征与目标之间的关系。  \n正如其名“One-Hot”，在每一行数据中，只有一个新特征是“热”的（值为 1）。\n\n\n","tags":["CO","CO Pre","One-Hot Encoding"],"categories":["計算機組成原理"]},{"title":"[CO Pre]Logisim 入门","url":"/posts/e7ebcfa7/","content":"# 序\n这是北京航空航天大学计算机学院 2025 年计算机组成原理预习部分的 Logisim 部分。\n\n<!-- more -->\n\n***\n\n# 什么是 Logisim？\n> Logisim 是一款非常优秀的用于数字电路设计与仿真的教育软件。它提供了丰富的电路库与元件的抽象表示，生成的电路图也比较美观，还提供了时序的模拟功能，能够让我们对 CPU 的结构和运行情况有更直观的理解，并且在开发一些小电路时还有一些其他辅助功能。  \n> [为什么要学习 Logisim？](https://cscore.e1.buaa.edu.cn/tutorial/logisim/logisim-1/logisim-1-1/)  \n\n***\n\n# 这里有什么？\n- Logisim 门电路\n- Logisim 组合电路\n- Logisim 时序电路\n- Logisim 仿真与调试\n- 应用与挑战\n\n***\n\n# Logisim 门电路\n\n## 界面认识\n\n打开 Logisim 后，我们会看到如下的界面：  \n![界面](logisim界面.png)\nLogisim 提供图形界面，可以通过长按拖动的形式新建部件以及进行连线。也可通过 `Ctrl + D` 快速部署选中的部件。\n\n## 元件概览\n\n### Wirings（线路）\n![wiring](wiring.png)  \n\n<a id=\"tunnel\"></a>\n#### Tunnel（隧道）  \n  \n​Tunnel 部件是在整个 Logisim 实验中简化电路布线复杂度效果最好的一个部件，可以让你在纷繁复杂的接线中解脱出来，让你能够更加专心的关注于各个部件的设计，而不被复杂的接线所打扰。  \n​Tunnel 名为隧道，即它可以将标签**相同** Tunnel 之间的数据，通过一个不可见的“隧道”进行传输，在使用过程中，可以链接数据的输入端和输出端，使得数据可以方便简单的传输。[^3]\n\n![Tunnel](Tunnel.png)  \n\n拥有不同标签的 Tunnel 之间，数据传输是独立的。  \n\n#### Probe（探针）\n\n​Probe 作为一个显示线路数据值的部件，可以对多位宽数据进行实时监控，简而言之，就是可以直接显示接线的数值，并且不影响整个电路的运行。  \nProbe 有点类似于输出引脚，可以显示数值，它可以显示**多位宽数据**。  \n\n![Probe](Probe.png)  \n\n<a id=\"splitter\"></a>\n#### Splitter（分叉器）\n  \n​Splitter 是一个多路分叉器，可以将一个数据输入端分成多个输出端，可以将数据进行分流，使得数据可以分别处理。每条岔路都会注明数据来源的**位编号**，位编号从 0 开始，对应数据源最靠右的位，例如：  \n\n![Splitter](Splitter.png)  \n\n要注意，Splitter 分流后，数据的位宽会相应的发生改变，因此输出引脚的位宽也需要改变。  \n\n{% note info %}\nSplitter 的输出引脚也可以当输入来用，这时，原先的输入引脚会输出此时输入的数据的组合（按照位次顺序）。\n{% endnote %}\n\n#### Bit Extender（位扩展）  \n \nBit Extender 有三个主要的参数：  \n- `Bit Width In`：输入数据的位宽\n- `Bit Width Out`：输出数据的位宽\n- `Extension Type`：扩展方式，包括 `Zero`, `One`, `Sign`, `Input`。  \n\n当输入数据的位宽**小于**输出数据的位宽时，Bit Extender 保留全部输入数据，然后补充内容使得输出数据位宽达到要求。  \n- 若 `Extension Type` 为 `Zero`，则补充 0。\n- 若 `Extension Type` 为 `One`，则补充 1。\n- 若 `Extension Type` 为 `Sign`，则补充符号位[^4]。  \n\n当输入数据的位宽**大于**输出数据的位宽时，Bit Extender 从低到高截取需要的位数，其余的舍弃。  \n\n![BE](BE.png)\n\n#### Clock（时钟）\n在 Simulate 菜单中开启 Ticks Enabled 选项，Clock 会自动经历周期，释放信号。  \nClock 可以指定 `High Duration` 和 `Low Duration`，分别表示高电平持续时间和低电平持续时间。单位为 `Tick(s)`。\n\n![Clock](Clock.png)\n\n{% note info %}\nLogisim 对时钟的模拟是理想状态的：在实际电路中，多个时钟会相互漂移，并且永远不会同步移动。 但在 Logisim 中，所有时钟都以相同的速率经历滴答声。\n{% endnote %}\n\n<a id=\"circle\"></a>\nClock 的周期：  \n\n![Clock2](Clock2.png)\n\n### Gates（门）\n![gate](gate.png)\n\n#### Odd Parity（奇校验）\n奇校验门和异或门在++两个输入端++时表现相同。但是如果有++超过两个++指定的输入，异或门将在刚好++只有一个 1 ++的时候输出 1。而奇校验门在++奇数个 1 ++输入时就会输出 1。  \n![OP](OP.png)  \n\n第一列和第二列均为奇数个 1，则输出端的第一列和第二列均为 1。  \n{% note info %}\n这与异或门的 `Multiple-Input Behavior` 字段选择 `When an odd number are on` 是一致的，而其默认选项是 `When one input is on` （只有一个 1 时输出 1）。\n{% endnote %}\n\n#### Even Parity（偶校验）\n偶校验门在输入端有偶数个 1 时输出 1，否则输出 0。  \n![EP](EP.png)  \n\n\n### Plexers（复用器）\n![plexer](plexer.png)\n\n#### Multiplexer(MUX)（多路选择器）  \n在组合电路中，多路选择器（Multiplexer，简称 MUX）是非常重要的一类部件，他们在组合电路中扮演着非常重要的角色。下图是一个典型的 Logisim 中的多路选择器，左侧是多个输入，右侧是相应的输出，通过底部（黑色）的选择信号，对输入的信号进行选择后输出。另外一个端口是部件的使能端，当其为高电平（为 1）时，整个部件使能工作。\n\n![MUX](MUX.png)  \n\n选择信号：当 `Select Bits` 字段为 n 时，选择信号的位宽为 n，此时输入引脚有 2^n^ 个。选择信号的值表示选择++要输出的输入信号的位次++，自上而下，从 0 开始。\n\n#### Demultiplexer(DMX)（多路分配器）\n多路分配器和多路选择器功能恰好相反，即能够将 1 个输入数据，根据需要传送到多个输出端的任何一个输出端。  \n\n![DMX](DMX.png)  \n\n选择信号：当 `Select Bits` 字段为 n 时，选择信号的位宽为 n，此时输出引脚有 2^n^ 个。选择信号的值表示选择要++把输入信号复制到第几个输出引脚上++，自上而下，从 0 开始。\n\n#### Decoder（译码器）\n如下图，右侧是多个输出，底部是黑色的选择信号与使能端。译码器最大的功能在于将二进制编码转换为相应的[独热码（one-hot）](https://samuflore.top/posts/9707d4af/)，如 101 的 3 位二进制编码作为输入就会被转换成 00100000 的 8 位独热码作为输出。因而该元件得名译码器。\n\n![decd](decd.png)\n\n译码器与多路选择器不同之处有两点：\n1. 除选择信号外，多路选择器是多输入，单输出，输出取决于输入与选择信号，译码器则是无输入，多输出，输出模式仅取决于选择信号。\n2. 译码器输出位宽每个信号仅一位，多路选择器可以有多位。\n\n#### Bit Selector（位选择器）\nBit Selector 有两个重要的参数：\n- `Data Bits`: 输入数据的位宽\n- `Output Bits`: 输出数据的位宽  \nBit Selector 有两个输入：data 和 dist。其中，dist 宽度为 ⌈log~2~(⌈data / `Output Bits`⌉)⌉。  \n一个输出为 `Output Bits` 位宽。  \nBit Selector 根据输出数据的位宽将输入数据等分成若干段，每段为 `Output Bits` 位宽。然后根据 `dist` 指定的编号从低到高选出需要的段并输出。\n\n![BS](BS.png)\n\n### Arithmetic（运算器）\n![arithmetic](arithmetic.jpg)  \n\n#### Negator（取反）\nNegator 是一个单输入的运算器。名曰取反，实则求补。即**取反加一**。  \n![negator](negator.png)\n\n#### Shifter（移位）\nShifter 含有两个输入，data 和 dist，它有一个输出，这是根据 dist 位移动数据的结果。data 和输出具有相同的位宽。  \n{%note warning%}\ndata 的位宽和 dist 的位宽需要满足下述数学关系：  \ndist = ⌈log~2~data⌉\n{%endnote%}  \n\nShifter 支持以下几种移位方式：  \n- Logical Left（逻辑左移）: 数据中的所有位向左移动 dist 位，底部空出的位用 0 填充。例如，11001011逻辑左移两次就是00101100（之前的右边两位丢弃）。\n- Logical Right（逻辑右移）: 数据中的所有位向右移动 dist 位，左端空出的位用 0 填充。例如，11001011逻辑右移两次就是00110010（之前的左边两位丢弃）。\n- Arithmetic Right（算术右移）: 数据中的所有位向右移动 dist 位，左端空出的位用数据中**最高位**重复填充。例如，11001011算术右移两次就是11110010（之前最高位为 1，所以用 1 填充）。\n- Rotate Left（循环左移）:   数据中的所有位都向左移动 dist 位，左边被“挤出去”的位填充到右边空出的位。例如，将11001011循环左移两次就是00101111。\n- Rotate Right（循环右移）:  数据中的所有位都向右移动 dist 位，右边被“挤出去”的位填充到左边空出的位。例如，将11001011循环右移两次就是11110010。  \n\n![shifter](shifter.png)  \n{%note info%}\n[本小节摘自 CSDN](https://blog.csdn.net/Hi_KER/article/details/121049347)  \n{%endnote%}\n\n#### Bit Finder（位查找）\nBit Finder 有一个 n 位宽的输入，有一个 1 位宽的输出，表示在输入中是否找到对应的值。对于 n 位的输入，Bit Finder 有一个 ⌈log~2~n⌉ 位宽的输出表示找到的值的编号。  \nBit Finder 有一个 `Type` 参数：  \n- Lowest-order 1: 自**最低位**开始查找 1\n- Highest-order 1: 自**最高位**开始查找 1\n- Lowest-order 0: 自**最低位**开始查找 0\n- Highest-order 0: 自**最高位**开始查找 0  \n\n::: tips\n无论何种查找方式，返回的都是绝对位次，即从右往左数从 0 开始的位次。\n:::\n\n![BF](BF.png)\n\n#### Adder（加法）\nAdder 将两个左端输入值数学相加，并在右端输出结果。\n\n![Adder](Adder.png)\n\n#### Subtractor（减法）\nSubtractor 将两个左端输入值数学相减，并在右端输出结果。\n\n![Subtractor](Subtractor.png)\n\n::: warning\n差值为负，则结果为其补码。\n:::\n\n#### Bit Adder（位加法）\nBit Adder 计算输入中有多少位是 1，并输出为 1 的位的数量。对于 n 位的输入，Bit Adder 有一个 ⌈log~2~n⌉ 位宽的输出表示 1 的位的数量。  \n\n::: warning\nBit Adder 可以指定至多 32 个输入。此时 n~总~ 为所有输入的 n 之和。\n:::\n\n![BA](BA.png)\n\n#### Comparator（比较）\nComparator 比较两个值（无符号值或两个补码值，可选）的大小。Comparator 有 3 个输出，通常，其中一个输出为1，另外两个输出为0。  \n\n![Comparator](Comparator.png)\n\n### Memory（存储）\n![memory](memory.png)\n\n#### Register（寄存器）\nRegister 存储单个多位值，该值以++十六进制++形式显示在其矩形内，并在其输出端输出。当时钟信号输入满足 Register 触发条件时，存储在 Register 中的值就会在该时刻改变为 D 输入的值。时钟信号指示 Register 储存值发生改变的确切条件是通过触发属性配置的，Logisim 中一般有时钟**上升沿**和**下降沿**，**高电平**和**低电平**这四种触发方式。  \n\n使能信号：使能信号输入为 1 时，Register 开始工作，输入信号 D 有效。使能信号输入为 0 时，Register 停止工作，输入信号 D 无效。  \n\n![Register](Register.png)\n\nReset（复位）输入异步地将 Register 的值重置为0（全部为0），也就是说，只要 Reset 为 1，Register 的值就固定为 0，不管时钟和输入是什么。  \n\n关于四种触发方式在周期的位置，请看[此处](#circle)\n\n#### RAM（随机存取存储器）\n::: warning\n在我们的实验中，我们采用的是读与写相互分离的类型，所以在选择 RAM 时，请将数据接口选择为 `Separate load and store ports`。\n:::\nRAM 组件是 Logisim 内置库中最复杂的组件，最多可存储 16,777,216 个值（在 地址位宽度/Address Bit Width 属性中指定），每个值最多可包含 32 位（在 数据位宽度/Data Bit Width 属性中指定）。RAM 可加载和存储数据。此外，用户可以通过 Poke 工具 (Poke Tool) 交互修改单个值，或者可以通过 菜单工具 (Menu Tool) 修改整个内容。  \n储存的数据值在组件中显示。地址以灰色字体形式陈列在显示区域的左边。在内部，每个值都使用十六进制格式列出。当前选定地址的值将以反色（白字黑底）显示。  \n\n![RAM](RAM.png)\n\n{% note info %}\n除了 clr(Clear, 为 1 时复位整个 RAM) 信号和时钟信号，sel(Chip Select, 选择生效的 RAM，即电路中同时刻只有一个 RAM 可用), str(Store, 为 1 时允许在时钟信号为高电平时将 D 输入信号写入 RAM), ld(Load, 为 1 时允许在时钟信号为高电平时从 RAM 中读取数据) 在没有输入的情况下均默认为 1。\n{% endnote %}\n\n#### ROM（只读存储器）\nROM 组件最多可以存储 16,777,216 个值(在地址位宽度属性中指定)，每个值最多可以包含32 位(在 数据位宽度/Address Bit Width 属性中指定)。电路可以访问 ROM 中的储存值，但不能改变它们。用户可以通过 Poke 工具交互修改单个值，或者用户可以通过菜单工具修改整个内容。  \n与 RAM 组件不同，ROM 组件的当前内容是作为组件的属性存储的。因此，如果一个包含ROM 组件的电路被使用了两次，这两个 ROM 组件都持有相同的值。也因为这种行为，ROM 的数据存储在 Logisim 创建的文件中。  \n当前值显示在组件中。显示的地址以灰色显示在显示区域的左边。在内部，每个值都使用十六进制列出。当前选定地址的值将以相反的文本(白底黑)显示。\n\n![ROM](ROM.png)\n\n{% note info %}\nROM 的数据是存储在本地的，以一个 .txt 形式。内含非零地址及其值，第一行固定为 `v2.0 raw`。\n{% endnote %}\n\n### I/O（输入输出）\n![io](io.png)\n### Base（基本组件）\n![base](base.png)\n\n## 一位全加器\n一位全加器由两个输入 A 和 B，一个进位输入 Cin，一个输出 S，一个进位输出 Cout 组成。全加器的表达式为：  \n`S = A ^ B ^ Cin; Cout = A & B | Cin & (A ^ B);`[^1]  \n对于 S 的运算，我们可以作出：[^2]  \n![S](S.png)\n利用已有的运算结果，进一步搭建整个电路：  \n![Full](Full.png)  \n\n<a id=\"swap\"></a>\n## Swap 电路\n现在需要你使用基础的门电路搭建这样一个电路，当输入 S 为 0（低电平）时，输出 O1 等于输入 I1，输出 O2 等于输入 I2。当输入 S 为 1（高电平）时，则交换两输出，即输出 O2 等于输入 I1，输出 O1 等于输入 I2。我们给它取名叫做 swap 电路。  \n\n### 提交要求\n**用 Logisim 完成 swap 电路**  \n- 文件内模块名：`swap`\n- 输入：`I1`(1 bit), `I2`(1 bit), `S`(1 bit)\n- 输出：`O1`(1 bit), `O2`(1 bit)\n- **注意：请从门级电路开始搭建，切勿使用 Plexers 类元件。**\n- **测试电路图（我们将使用下方的电路对你搭建的电路进行测试，测试的原理是将下图的 swap 模块替换为你提交文件中的 swap 模块，随后测试机会仿真运行下图中的电路图，记录其输出并与正确的输出进行对比）**\n\n![test](test.png)\n\n模块样式：  \n\n![swap_circuit](swap_circuit.png)\n\n### 解\n**答案**  \n![swap](swap.png)\n\n**分析**  \n如果 S 为 0 且 I1 为 1，则 O1 为 1，若 I1 为 0，则 O1 为 0。显然，这需要一个与门来实现。  \n![swap1](swap1.png)  \n\n对于 I2 与 O2，是与前者一样的逻辑  \n![swap2](swap2.png)  \n\n如果 S 为 1，则 I1 与 I2 的值交换再赋给 O1 与 O2。对于 I1 而言，首先必须获取其值，然后传递给 O2。由于 S 是 1，则让 S 和 I1 通过与门。考虑到 I2 到 O2 和 I1 到 O2 不会同时为 1，则将两个与门的输出用一个或门连接，再输出到 O2 即可。  \n![swap3](swap3.png)  \n![swap4](swap4.png)\n\n到 O1 的线路如法炮制即可。  \n\n{% note warning %}\n在打包成模块时，注意按要求调整 S, I1, I2, O1, O2 的位置。  \n注意按要求命名。\n{% endnote %}\n\n\n# Logisim 组合电路\n\n## 子电路\n### 子电路使用流程\n1. 创建子电路：通过 Project 栏下的 Add Circuit；\n2. 添加子电路内容；\n3. 设置外观；\n4. 引用。\n\n譬如 Swap 电路，若将其封装成子电路，则可以设计出双重交换电路 2Swap。\n\n![2swap](2swap.png)\n![2swap1](2swap1.png)\n![2swap2](2swap2.png)\n\n## Wire Bundle（线束）\n![wires](wires.png)\n​对于一个完整且正确的电路，是以深绿色，浅绿色，黑色接线构成，绿色接线可以通过深浅直接判断出取值，而黑色接线，并不能直接反映出取值，这里建议大家使用 Wiring 库中的 Probe 元器件，可以对多位数据实时显示监控。\n\n<a id=\"analyze\"></a>\n## 利用 Logisim 进行组合逻辑分析\n​Logisim 中具有逻辑分析的功能，可以实现组合电路，真值表，布尔表达式三者间的两两转换。  \n​打开组合逻辑分析模块的方式：\n1. Window 栏目下的 Combinational Analysis;\n2. Project 栏目下的 Analyze Circuit;\n\n​组合逻辑分析模块，可根据逻辑表达式得到相应的真值表。我们也可以通过输入真值表，再产生相应的表达式，或者产生相应的电路。其中真值表的选值有：0，1，x（浮动）。  \n![analysis](analysis.png)  \n\n并且在生成电路时，我们也可以勾选下列生成电路的附加约束：\n- Use Two-Input Gates Only 只使用二输入门电路；  \n![2-input](2-input.png)\n- Use NAND Gates Only 只使用与非门；  \n![nand](nand.png)\n\n## 排序电路（4bit_sort）\n在前面的学习过程中，我们搭建了一个 1 位的 swap 电路。现在需要我们使用之前的 1 位 swap 电路来搭建一个 4 位 4 输入的排序电路。  \n### 要求\n先使用 1 位的 swap 搭建 4 位的 swap，再使用 4 位的 swap 模块和 Logisim 内置的 comparator 元件搭建排序电路（请不要使用 Plexers 类元件）。\n- 功能描述: 该电路具有 4 个 4 位的二进制数字作为输入和 4 个 4 位的二进制数字作为输出。它的功能是，将 4 个输入的二进制数字进行排序，从上往下数第一个输出端口输出的是 4 个数字中最小的，第二个输出端口输出的是第二小的，以此类推。\n- 输入： A, B, C, D (4 bit)\n- 输出： #1, #2, #3, #4 (4 bit)（#1 对应第一个输出端口，以此类推）\n- 文件内 1 位 swap 模块名：`1bit_swap`\n- 文件内 4 位 swap 模块名：`4bit_swap`\n- 文件内排序电路模块名：`4bit_sort`\n- Hint: 所有的二进制数字均看做是无符号的。\n### 解\n1 位 swap 电路可以参考[这里](#swap)。  \n要构建 4 位 swap 电路，其实就是把 4 bit 输入拆分成四个 1 bit 输入，然后分别交给 1 位 swap 电路，再将四个 1 bit 输出连接起来即可。拆分，也就是使用 Splitter 元件，交换后再用 Splitter 连接起来。有关 Splitter 您可参考[这里](#splitter)。\n\n![4bit_swap](4bit_swap.png)\n\n::: warning\n**注意**  \n图中已封装好的模块是 1 位 swap 模块 `1bit_swap`。\n:::\n\n{% note info %}\n您可使用 Tunnel 元件简化电路。关于 Tunnel 元件您可参考[这里](#tunnel)。\n{% endnote %}\n\n如何实现排序呢？我们可以使用[冒泡排序（Bubble Sort）](https://www.runoob.com/w3cnote/bubble-sort.html)来完成。对于 A, B, C, D 四个输入，我们可以先比较 A 和 B 的大小，由于要求从小到大输出，那么如果 A > B，则交换 A 和 B，然后比较 A 和 C，如果 A > C，则交换 A 和 C，以此类推，直到比较完所有四个输入。每个输入都会与另三各完成一次比较，从而得到四者的顺序。此处我们可以充分利用 Tunnel 元件，将一次比较的结果传递给下次比较的输入。\n\n![4bit_sort](4bit_sort.png)\n\n::: warning\n**注意**  \n图中已封装好的模块是 4 位 swap 模块 `4bit_swap`。\n:::\n\n每轮比较，若结果为大于，则 Comparator 输出 1，该信号作为使能信号激活 `4bit_swap` 模块，将输入的二者交换。完成后，其结果用新的 Tunnel 传递给之后的比较轮次。\n\n***\n\n# Logisim 时序电路\n\n## SR 锁存器（SR Latch）\n{% note warning %}\n部分内容选自[知乎](https://zhuanlan.zhihu.com/p/1938209046684505714)。\n{% endnote %}\n\n我们先来讲解一种简单的电路——SR 锁存器（SR latch），它由两个交叉耦合的或非门（或者，等价地，两个反置输入的与非门）组成，整个电路的状态可以由 S（Set）和 R（Reset）输入来决定，对应得到两个相反的输出 Q 和 ~Q，它的真值表如下：\n\n![SR1](SR1.jpg)\n\n\n一种电路如下：  \n![NOR-SR](NOR-SR.png)\n\n\n::: tips\nQ 为 1 而 ~Q 为 0 时被称为锁存器的 1 状态，Q 为 0 而 ~Q 为 1 时被称为锁存器的 0 状态。\n:::\n\n其中 S~D~ 和 R~D~ 为是电路输入的两个端口，Q^n^ 表示电路当前的输出，Q^n+1^ 表示电路下一个状态的输出。由真值表可以看出，这个电路的输出不仅和当前输入有关，也和上一次的输出有关。  \n观察它的功能一栏，可以看到，通过改变 S~D~ 和 R~D~ 为合适的值，我们可以改变电路的输出，而当 S~D~ 和 R~D~ 为均为 0 时，电路会一直保持原来的输出不变，这看上去很像 U 盘之类的设备（通电时能够修改存储的内容，断电时保持内容不变）。事实上，通过配合合适的外部电路，我们就可以使用这个电路来存储整个电路的状态，从而搭建起更复杂的时序电路。\n\n{% note info %}\n简单来说，初始情况下 S 和 R 均为 0，按下 S 键，锁存器将进入 1 状态(Set)。此时，无论 S 如何变化，锁存器的输出都将不变。因为锁存器已经被设置成 1 了。再按下 R 键，锁存器重置（Reset），输出变为 0。无论 R 如何变化，锁存器的输出都将不变。因为锁存器已经被重置了。0 重置 仍然是 0。\n{% endnote %}\n\n由于复位和置位都是输入端为 1 才发生，故这种 SR 锁存器叫做++高电平有效的SR锁存器++。\n\n还有一种++低电平有效的SR锁存器++，它的输入端 S 和 R 均为低电平有效。真值表如下：\n\n![SR2](SR2.jpg)\n\n它的电路如下：  \n\n![NAND-SR](NAND-SR.png)\n\n## D 锁存器（D Latch）\nD 锁存器是最常用于在数字系统中存储数据的逻辑电路。它基于 SR 锁存器，但没有“未定义”或“无效”状态问题。  \n\n![D_latch](D_latch.png)\n\n::: warning\n**注意**  \n图中封装的电路是++高电平有效的SR锁存器++。\n:::\n\nD 锁存器有两个输入 D 和 E，其中 E 是使能信号。当 E 为 1 时，D 锁存器将 D 输入的值存储在 Q 中，随着 D 变化而变化。当 E 为 0 时，D 锁存器保持当前的 Q 值不变。即锁存 D 输入的值。\n\n{% note info %}\nE 也可以看作是 CLK 时钟信号。此时 D 锁存器将++时间++输入和++数据++输入明确的分隔开，而 SR 锁存器是没有区分的。  \n当 CLK 为 1 时，D 锁存器是透明的（transparent），数据 D 通过 D 锁存器流向 Q。当 CLK 为 0 时，D 锁存器是不透明的（opaque），其阻塞新数据流向 Q，Q 保持原值不变。\n{% endnote %}\n\n## D 触发器（D Flip-Flop）\nD 触发器由反相时钟控制的两个 D 锁存器组成。分别为主锁存器（Master）和从锁存器（Slave）。  \nCLK 为 0 时，主锁存器透明，从锁存器不透明，D 流向从锁存器但无法流入，保持在二者连线处。CLK 为 1 时，主锁存器不透明，从锁存器透明，数据流向 Q，但新的输入无法流入主锁存器。  \n也就是说，D 触发器只会在时钟上升沿将 D 复制到 Q，在其他时间段保持原来的状态。\n\n![D_FF](D_FF.png)\n\n## 有限状态机（FSM）\n### 有限状态机的定义和行为\n#### 有限状态机的构成和基本性质\n有限状态机（Finite State Machine，FSM）又称有限自动状态机，它拥有有限数量的状态，每个状态代表不同的意义，每个状态可以切换到 零-多 个状态。任意时刻状态机有且只能处在一个状态。\n\n{% note info %}\n**数学定义**  \n构成一个有限状态机的六元组为：状态集合，输入集合，输出集合，状态转移函数，输出函数，初始状态。给定以上六个集合，函数或元素，就可以确定一个有限状态机。\n{% endnote %}\n\n据此，有限状态机具有以下特征：\n- 在任何时间点，状态、输入、输出均为++给定的有限种情况之一++。\n- 对于一对确定的当前状态和输入，只有一个++固定且唯一++的次态（下一个周期的状态）。\n- 对于一对确定的当前状态和输入，只有一种++固定且唯一++的输出情况。\n\n#### 有限状态机的时序行为\n状态转移行为可以描述成如下过程：\n- 当第 0 周期开始，状态设定为 state~0~。\n- 第 n 周期结束的瞬间，记此时刻输入为 input~n~。\n- 每当第 n 周期结束，第 n + 1 周期开始时，状态变为状态转移函数给出的次态：state~n+1~ = F~next~(state~n~, input~n~)。\n\n### Moore 和 Mealy 状态机的区别\n区分状态机类型时：当++输出函数的结果会随 input 变化而改变时++，该状态机为 ++Mealy 机++，++否则为 Moore 机++。\n\n![FSM](FSM.png)\n\n## 2^n^ mod 5\n### 要求\n使用 Logisim 搭建电路，该电路串行输入一个二进制无符号数 B（先从高位输入，每输入一个数字就相当于之前输入的数左移一位再加上当前输入的数字），输出 “2 的 B 次幂” 模 5 的余数的电路并提交。\n- 输入： In（1bit 串行输入）\n- 输出：S~0~, S~1~, S~2~, S~3~, S~4~ （独热编码，S~x~ 为 1 时表示 2^In^ ≡ x (mod 5)）\n- 文件内模块名: mod5\n- 状态机类型: Mealy 型有限状态机\n- 注意：切勿使用内置算术器件（如加法器、除法器等）！请搭建有限状态机！\n- 样例：\n输入输出样例中每一行表示相邻上升沿之间的++开区间时间内++的输入和期望输出。\n![mod5_example](mod5_example.png)\n\n### 解\n题目要求使用有限状态机来搭建，且由于输入和输出有关，是 Mealy 型状态机。  \n首先要确定状态集合。2 的幂次方模 5 所产生的余数其实只有 1 到 4，也就是说只有四种状态。我们可以用 2 位的二进制数来表示状态：\n|状态|余数|\n|-|-|\n|00|0|\n|01|1|\n|10|2|\n|11|3|\n\n不难发现，1 % 5 = 1, 2 % 5 = 2, 4 % 5 = 4, 8 % 5 = 3, 16 % 5 = 1……即余数以 4 为周期进行循环。若把被除数写成二进制形式，并观察其末二位，则会发现有这样的规律：\n|余数|状态|末二位|被除数|\n|-|-|-|-|\n|1|00|00|2^0^|\n|2|01|01|2^1^|\n|4|11|10|2^2^|\n|3|10|11|2^3^|\n\n现在，要改变状态，我们会进行一次输入，考察这次输入引起的变化：末二位左移一次，输入值填补在低位。输入只有 1 和 0 两种情况，而现在状态有 4 种，因此我们可以枚举出共计 8 种可能的情况：\n::: warning\n接下来，现在状态的第一位称为 ST1，第二位为 ST2；次态的第一位称为 ST1'，第二位为 ST2'；输入称为 IN；余数称为 S0 到 S4。\n:::\n\n状态转移表如下：\n\n|ST1|ST2|IN|ST1'|ST2'|S0|S1|S2|S3|S4|\n|-|-|-|-|-|-|-|-|-|-|\n|0|0|0|0|0|0|1|0|0|0|\n|0|0|1|0|1|0|0|1|0|0|\n|0|1|0|1|1|0|0|0|0|1|\n|0|1|1|1|0|0|1|0|1|0|\n|1|0|0|1|1|0|0|0|0|1|\n|1|0|1|1|0|0|0|0|1|0|\n|1|1|0|0|0|0|1|0|0|0|\n|1|1|1|0|1|0|0|1|0|0|\n\n::: tips\n可以看出 S0 恒为 0。\n:::\n\n根据 Mealy 型状态机的结构图，我们需要构建三个部分：状态转移逻辑、输出逻辑和寄存器。其顶层结构如下：\n![mod5](mod5.png)\n\n寄存器保存的是++现态++。在上升沿以外的时间段，可以把整个状态机的行为拆分成两步：\n1. 现态从 Q 流向状态转移逻辑 `Trans`，和 In 一起决定次态的值。但是由于时间在上升沿以外，次态滞留在寄存器外，无法改变其值。\n2. 现态从 Q 流向输出逻辑 `Out`，和 In 一起决定输出的值。\n\n当时间来到上升沿，滞留的次态值进入寄存器，完成状态的转移。然后在下一个上升沿到来前，重复上述的 1 和 2 步。\n\n::: tips\n这正好满足了样例说的“每一行表示相邻上升沿之间的++开区间时间内++的输入和期望输出”，因为输出这一步骤就是在两个上升沿之间完成的。\n:::\n\n状态转移逻辑和输出逻辑的实现，最简单的步骤就是根据状态转移表，使用 Logisim 的 [Analyze Circuit](#analyze) 功能来自动生成即可。\n\n## 斐波那契数列\n### 要求\n使用 Logisim 搭建一个根据输入序号 x 计算对应序号斐波那契数 F~x~ 的电路并提交。\n- F~0~ = 0, F~1~ = 1, F~n~ = F~n-1~ + F~n-2~ (n ≥ 2)\n- 输入：N (3bit)\n- 输出：Nth(4bit)\n- 文件内模块名: main\n- 测试要求：每次给定一个固定输入保持不变，电路在 64 个周期内计算出结果并稳定输出，在结果未计算出之前输出端口输出 0。\n\n### 解\n#### 计数逻辑\n要知道第 x 号斐波那契数的值，我们可以从 0 号和 1 号开始，依次计算斐波那契数，直至第 x 号时停止并输出。那么要算多少次呢？如果我们以 0 号和 1 号开始，每一个时钟周期计算一次的话，那么第一个周期算出 2 号，第二个周期算出 3 号……并且，还需要花掉一个上升沿去++初始化++寄存器的值，计数器达到需求时，又需等下一个上升沿才能输出结果。若要求 2 号斐波那契数，计数逻辑到第 3 个上升沿时就会发出停止运算并输出的信号。而第 1 个上升沿被用来初始化，第 2 个上升沿算出 2 号，到第 3 个上升沿算出 3 号，输出的结果就是 3 号斐波那契数了，并不符合我们的需求。因此我们可以往前推一位，以 -1 号和 0 号开始。\n\n::: tips\nF~-1~ = 1, F~0~ = 0。\n:::\n\n这样，第 x 号斐波那契数需要 x 个时钟周期才能算出。换言之，当第 x 个时钟周期结束时，已经算出了第 x 号斐波那契数。而下一个时钟周期的上升沿，必须停止计次，然后输出数字，否则会多算一次。  \n控制运算次数的逻辑可以使用一个计数器（Counter）和一个比较器（Comparator）来实现。计数器从 0 开始，每到一个上升沿加 1。也就是说 x 个时钟周期结束时，计数器的值为 x，在下一个上升沿到来时，传递一个信号（output_signal）给运算斐波那契数的逻辑，令其做完运算后立刻输出结果，并且将结果锁定在寄存器中。每个上升沿，用比较器比较计数器的值和 N 的值，若计数器的值小于等于 N，则 output_signal 为 0，否则为 1。\n\n::: tips\n由于输入格式是 3bit，若计数器的位宽也设置成 3bit，则会在边界情况下失效。比如输入为 111，第七个周期时，计数器的值为 111。在下一个上升沿到来时，计数器的值要么回到 000，要么保持 111，始终无法让其大于输入值，output_signal 始终为 0。因此，需要设置计数器的位宽比输入值多 1 位。然后使用 Bit Extender 把输入扩展到 4bit。\n:::\n\n::: warning\n比较器的 Numeric Type 参数必须设定为 `Unsigned` 即无符号数比较。若为 `2's Complement` 即补码比较，则 output_signal 会逆转。\n:::\n\n![time_control](time_control.png)\n\n#### 运算逻辑\n回到运算斐波那契数的逻辑。由于每个斐波那契数的值只与其前两个值（prev, cur）有关，每次算出新值 = prev + cur，可以用 cur 覆盖 prev，然后用新值覆盖 cur，以此类推就可以持续计算下去。这些步骤在上升沿完成。核心逻辑如下：\n\n![fib_cal](fib_cal.png)\n\n在上升沿以外的时刻，Cur 值流向 Prev 寄存器，但无法进入，滞留在线路中。同时 Prev 和 Cur 值在 Adder 中相加，得出下一个斐波那契数，流向 Cur 寄存器，也无法进入，滞留在线路中。  \n在上升沿，Cur 值进入 Prev 寄存器，并覆盖原有值，同时新的斐波那契数进入 Cur 寄存器，覆盖掉原有值。也就是说，最新的斐波那契数保存在 Cur 寄存器中，并且是每个上升沿到来时更新一次。  \n\n如何初始化两个寄存器呢？由于 F~-1~ = 1, F~0~ = 0，因此我们要把 Prev 寄存器的值设为 1，而 Cur 寄存器默认为零。我们用一个 Maximum Value 为 `1` 的++计数器++来实现。利用到计数器有一个 Carry 输出，当计数器达到最大值时，Carry 输出为 1，否则为 0。再搭配一个二选一 MUX，0 号输入为想要的初始值，1 号输入则是 Cur 隧道。这样就实现了如下效果：\n- 第一个上升沿到来前，MUX 选择初始值，但无法进入 Prev 寄存器，滞留在线路中。\n- 第一个上升沿到来时，初始值进入 Prev 寄存器，实现初始化。MUX 选择 Cur 隧道值。\n\n![init1](init1.png)\n![init2](init2.png)\n\n#### 锁定斐波那契数\n很简单，传入 output_signal，当其为 1 时表示已经算出了所求的，让其通过非门，然后传给两个寄存器的使能信号端口即可。\n\n#### 稳定输出\n在找到要求的斐波那契数前，输出 Nth 要求保持为 0。可以用一个二选一 MUX，0 号输入为 0，1 号输入为 Cur 隧道值。传入 output_signal，当其为 1 时自然就输出了 Cur 寄存器中保存的值。\n\n整个运算逻辑如下：\n![fib_cal2](fib_cal2.png)\n\n顶层电路如下：\n![fibonacci](fibonacci.png)\n\n\n[^1]: 优先级：`&` > `^` > `|`  \n[^2]: Logisim 画布上，高亮代表此线路的真值为 1，不高亮代表此线路的真值为 0。\n[^3]: Tunnel 需要增加标签以区分不同的数据。并且每个标签只允许有一个输入，输出的数量不做限制。但是在有较多 Tunnel 部件的时候，要特别留意标签的名字，防止出现混乱。\n[^4]: 将输入数据的最高位视为符号位，扩展的数值全为符号位的值。","tags":["CO","CO Pre","Logisim"],"categories":["計算機組成原理"]},{"title":"加密文章测试","url":"/posts/7e709353/"},{"title":"[CO Pre]原码、反码与补码","url":"/posts/908cc5fb/","content":"# 序\n计组 Pre 开始了，但是我把上学期学的内容都忘了（  \n所以先从**数制**开始吧。  \n\n<!-- more -->\n\n***\n\n# 机器数\n一个数在计算机中的二进制表示形式被称为**机器数**。  \n机器数是有符号的，计算机中将机器数的最高位（最左边）称为符号位，用以表示符号。0 表示正数，1 表示负数。  \n\n***\n\n# 真值\n机器数的**真值**是指该机器数对应的实际数值。  \n对于一个有符号数，它的机器数未必等于它本身。  \n譬如十进制数 -7，它的机器数为 10000111，但 10000111 如果当作二进制表示，对应的十进制数是 135。故 -7 的机器数的真值应该是 00000111。  \n\n***\n\n# 原码\n**原码**就是**符号位**和**真值**的组合。即用最高位表示符号，其余位表示数字大小。  \n- [+1]原码：0000 0001\n- [-1]原码：1000 0001  \n\n***\n\n# 反码\n**反码**的表示方法如下：  \n- 正数的反码是其原码本身。\n- 负数的反码将其原码的符号位不变，其余各位**按位取反**。  \n比如：  \n- [+1]反码：0000 0001\n- [-1]反码：1111 1110  \n\n***\n\n# 补码\n**补码**的表示方法如下：  \n- 正数的补码是其原码本身。\n- 负数的补码是其反码加 1。  \n::: warning\n**注意**  \n加 1 指的是二进制加法，注意进位。\n:::\n比如：  \n- [+1]补码：0000 0001  \n- [-1]补码：1111 1111   \n\n***\n\n# 为什么要这么复杂？\n数字存储在计算机中，是需要用来运算的。根据四则运算的性质，人们只需要解决**加法**的运算方法就可以了。  \n可是，对于人脑而言，进行有符号数的加法是很简单的，因为大家都能一眼看出数字的符号，再根据符号决定运算。对于计算机而言，倘若要模拟人的运算，就必须拥有识别符号的能力，这无疑是增加了复杂度。  \n于是聪明的人们就想到了把符号位也纳入运算中。  \n\n## 原码运算\n大家都知道，1 - 1 = 0。  \n如果使用原码运算，那么 1 - 1 = 1 + (-1) = 0000 0001 + 1000 0001 = 1000 0010。  \n按照原码的定义，这显然等于 -2。因此，原码是不行的。  \n\n## 反码运算\n仍然是 1 - 1 = 0 这个问题。  \n1 - 1 = 1 + (-1) = 0000 0001[反码] + 1111 1110[反码] = 1111 1111[反码] = 1000 0000[原码] = -0。  \n-0，人们都知道 0 和 -0 是一样的，可如果使用反码运算，-0 和 0 就成了两个数。如果用 -0 和 0 分别进行一些运算：  \n- -0 + 1 = 1111 1111[反码] + 0000 0001[反码] = 1 0000 0000[反码]  \n对于反码的加法运算，倘若位数溢出，则需要把溢出的位数依次补到末尾，称之为**循环进位**。  \n故 1 0000 0000[反码] = 0000 0001[反码] = 0000 0001[原码] = 1。  \n- 0 + 1 = 0000 0000[反码] + 0000 0001[反码] = 0000 0001[反码] = 0000 0001[原码] = 1。  \n\n可见，反码的运算是繁琐而有歧义的，问题就出在 0 和 -0 的区分上。  \n\n## 补码运算\n1 - 1 = 1 + (-1) = 0000 0001[补码] + 1111 1111[补码] = 1 0000 0000[补码]  \n补码运算中，没有循环进位，溢出位舍弃。  \n故 1 0000 0000[补码] = 0000 0000[补码] = 0000 0000[原码] = 0。  \n补码中是没有 0 和 -0 的区分的：0 就是 0000 0000，而 1000 0000 则被用来表示 -128。  \n::: tips\n**为什么是 -128？**  \n-1 + (-127) = 1111 1111 + 1000 0001 = 1000 0000 = -128。\n:::  \n\n补码是可以解决问题的。  \n\n***\n\n关于原码、反码和补码的数学原理探讨，您可参考[这篇文章](https://zhuanlan.zhihu.com/p/118432554)。\n\n\n","tags":["CO","CO Pre","Sign-Magnitude","Ones' Complement","Two's Complement"],"categories":["計算機組成原理"]},{"title":"Blog 9：[Hexo]Hexo NexT 自定义字体","url":"/posts/ec5f1055/","content":"# 序\n三种方法为 Hexo NexT 主题自定义字体。  \n> 今天我才发现我的 NexT 主题是过时已久的 7.x 版本。尝试更新到 8.x，发现变了许多，便决定继续用旧版本了。  \n\n<!-- more -->\n\n***\n\n# 从 Google Fonts 引用  \n\n在**站点配置文件** `_config.yml` 中，搜索 `font` 字段，您将看到以下内容：\n\n```yaml\nfont:\n  enable: true\n\n  # Uri of fonts host, e.g. https://fonts.googleapis.com (Default).\n  host: \n\n  # Font options:\n  # `external: true` will load this font family from `host` above.\n  # `family: Times New Roman`. Without any quotes.\n  # `size: x.x`. Use `em` as unit. Default: 1 (16px)\n\n  # Global font settings used for all elements inside <body>.\n  global:\n    external: true\n    family: \n    size:\n\n  # Font settings for site title (.site-title).\n  title:\n    external: true\n    family: \n    size:\n\n  # Font settings for headlines (<h1> to <h6>).\n  headings:\n    external: true\n    family: \n    size:\n\n  # Font settings for posts (.post-body).\n  posts:\n    external: true\n    family: \n\n  # Font settings for <code> and code blocks.\n  codes:\n    external: true\n    family: \n```\n\n`host` 字段处指定字体的来源，默认使用 Google Fonts。  \n::: tips  \n~~由于不可抗力~~，您可使用 Google Fonts 的镜像站来确保访问速度。例如 `https://fonts.loli.net`。  \n:::  \n\n引用的字体可以分派到五个部分：**全局默认**、**网站标题**、**博文标题**、**博文正文**、**内嵌代码和代码块**。  \n\n::: warning\n由于 `Yaml` 语法限制，此处您每个字段只能指定一种字体。\n:::  \n\n`family` 字段指定字体的名称。譬如 `Noto Serif SC`（思源宋体简体中文）。  \n但是，如果您需要中西文分两种字体，这显然是无法满足要求的。  \n\n***\n\n# 修改 Stylus 样式文件  \n\n::: warning\n下文中将出现两个名为 `base.styl` 的不同文件，敬请注意区分。  \n:::\n\n首先我们必须知道是什么文件在控制 NexT 主题各元素的样式。  \n在 `themes\\next\\source\\css\\_common\\scaffolding\\base.styl` 文件中，我们可以看到类似这样的代码：  \n\n```stylus\nh1, h2, h3, h4, h5, h6 {\n  font-family: $font-family-headings;\n  font-weight: bold;\n  line-height: 1.5;\n  margin: 20px 0 15px;\n}\n```\n\n很明显，这是用来指定 `<h1>` 到 `<h6>` 标签的样式的。于是我们就知道这是用来控制 NexT 主题样式的文件。注意到，这里有一个 `font-family` 字段。Stylus 是为 Node.js 构建的 CSS 预处理器，因此它具有 CSS 的性质。所以这里可以指定多种字体。我们只需在 `$font-family-headings` 前加西文字体的指定即可，比如：  \n```stylus\nh1, h2, h3, h4, h5, h6 {\n  font-family: Times New Roman, $font-family-headings;\n}\n```\n\n这样，就为西文指定了 Times New Roman。  \n\n::: tips\n先指定西文字体，再指定中文字体，以确保中文字体的拉丁字符不会替换西文字体的字形。\n:::\n\n可是什么是 `$font-family-headings` 呢？  \n打开 `themes\\next\\source\\css\\_variables\\base.styl` 文件，我们可以看到：  \n\n```stylus\n// Font families.\n$font-family-chinese      = \"PingFang SC\", \"Microsoft YaHei\";\n\n$font-family-base         = $font-family-chinese, sans-serif;\n$font-family-base         = get_font_family('global'), $font-family-chinese, sans-serif if get_font_family('global');\n\n$font-family-logo         = $font-family-base;\n$font-family-logo         = get_font_family('title'), $font-family-base if get_font_family('title');\n\n$font-family-headings     = $font-family-base;\n$font-family-headings     = get_font_family('headings'), $font-family-base if get_font_family('headings');\n\n$font-family-posts        = $font-family-base;\n$font-family-posts        = get_font_family('posts'), $font-family-base if get_font_family('posts');\n\n$font-family-monospace    = consolas, Menlo, monospace, $font-family-chinese;\n$font-family-monospace    = get_font_family('codes'), consolas, Menlo, monospace, $font-family-chinese if get_font_family('codes');\n```\n\n原来，`$font-family-headings` 是一个变量，它先获取 `_config.yml` 中 `font` 字段的 `headings` 设置。如果没有，则使用 `$font-family-base` 作为默认值。后者获取 `_config.yml` 中 `font` 字段的 `global` 设置。如果没有，则缺省为最通用的**苹方**和**微软雅黑**。  \n\n所以，您如果希望正文中的西文字体是 Times New Roman，而中文是 Noto Serif SC，就可以在 `_config.yml` 中设置 `posts` 字段字体为 `Noto Serif SC`，然后在 ++控制样式++ 的 `base.styl` 的 `body` 处指定 `font-family` 为 `Times New Roman, Noto Serif SC`。其余也类似。  \n\n::: warning\n像上述方法在 Stylus 中指定字体时，只填写字体名称的，当浏览网页之设备有该字体时才能正常显示。如果没有，则会显示为默认字体。\n:::  \n\n如果需要指定的字体在任何设备上都能正常显示，又该如何呢?  \n\n***\n\n# 使用 `@font-face`  \n## 原始方法\n关于 `@font-face`，您可参考[这里](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face)。  \n它的格式如下：  \n\n```stylus\n@font-face {\n  font-family: \"Open Sans\";\n  src:\n    url(\"/fonts/OpenSans-Regular-webfont.woff2\") format(\"woff2\"),\n    url(\"/fonts/OpenSans-Regular-webfont.woff\") format(\"woff\");\n}\n```\n\n`font-family` 字段可以自定义字体的名称方便后续使用。`src` 字段指定字体文件的路径，既可以是本地路径也可以是网络路径。`format` 字段指定字体文件的格式，譬如 TTF。简单来说，您通过它可以自定义一个字体以供使用。  \n\n故您可以将一些字体文件上传到云端，然后以相对路径的形式引用，这样就能在任何设备上都能正常显示。在 `themes\\next\\source` 目录下新建一个 `fonts` 文件夹，然后将字体文件放入其中。然后在 ++控制样式++ 的 `base.styl` 文件中，在 `font-family` 字段前加上 `@font-face`，如下： \n\n```stylus\n@font-face {\n  font-family: \"Mozilla Headline\";\n  src: url(\"../fonts/MozillaHeadline-Regular.otf\");\n}\n```\n\n::: tips\n为什么是 `../fonts/`？Hexo 博客在编译时，默认会将 `source` 目录下的所有文件复制到 `public` 目录下。所有样式会被编译到 `public\\css` 目录下。对于 CSS 文件而言，OTF 文件自然是**上级目录**的 fonts 文件夹下的文件了。\n:::\n\n然后再在 ++控制样式++ 的 `base.styl` 的 `body` 处指定 `font-family` 为 `Mozilla Headline, Noto Serif SC`。这样，所有设备都会在加载网页时加载 MozillaHeadline-Regular.otf 字体文件，然后应用样式。  \n可是，这是最优解吗？  \n\n2009 年，Web 开放字体格式出现并发展。现在正由万维网联盟的 Web 字体工作小组标准化，以求成为推荐标准。此字体格式不但能够有效利用压缩来减少档案大小，并且不包含加密也不受 DRM（数位著作权管理）限制。WOFF 本质上是包含了基于 sfnt 的字体（如 TrueType、OpenType 或开放字体格式），且这些字体均经过 WOFF 的编码工具压缩，以便嵌入网页中。这个字体格式使用zlib压缩，文件大小一般比 TTF 小 40%[^1]。  \n\n如果能用上 WOFF 或 WOFF2 格式，岂不美哉？\n\n## 现代方法\n只要能弄到 WOFF 或 WOFF2 格式的字体文件，按上述方法，就能完成速度优化。这里介绍一种从 Google Fonts 下载 WOFF 或 WOFF2 格式字体的方法。  \n\n首先，在 Google Fonts 上搜索您需要的字体。例如 Mozilla Headline。点击 Get Font，然后点击 Get embed code。  \n\n![Get embed code](图一.png)  \n\n在 import 模式中找到字体的 URL。如下图的 https://fonts.googleapis.com/css2?family=Mozilla+Headline:wght@200..700&display=swap 。  \n\n![Get font URL](图二.png)  \n\n将 URL 复制到浏览器地址栏，访问。可以得到包含 `@font-face` 的 CSS 代码： \n\n```stylus\n/* latin-ext */\n@font-face {\n  font-family: 'Mozilla Headline';\n  font-style: normal;\n  font-weight: 200 700;\n  font-stretch: 100%;\n  font-display: swap;\n  src: url(https://fonts.gstatic.com/s/mozillaheadline/v1/QGY4z-UXahmCOps4kyMKGuSA9pYt2_P-w2kFrS88o6cVYTHDYMVmJQ.woff2) format('woff2');\n  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;\n}\n/* latin */\n@font-face {\n  font-family: 'Mozilla Headline';\n  font-style: normal;\n  font-weight: 200 700;\n  font-stretch: 100%;\n  font-display: swap;\n  src: url(https://fonts.gstatic.com/s/mozillaheadline/v1/QGY4z-UXahmCOps4kyMKGuSA9pYt2_P-w2kFrS88o6cVYTHNYMU.woff2) format('woff2');\n  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\n}\n```\n\n这里已经包含了两个 URL，是将该字体按照不同字符集分成的两个 WOFF2 文件。浏览器访问会自动下载。将下载的文件放到 `fonts` 文件夹中。然后把以上代码复制到 ++控制样式++ 的 `base.styl` 文件中。把 URL 改成相对路径。再在 `font-family` 字段中指定 `Mozilla Headline`，即可。  \n\n::: success\n按照我的理解，直接将此 CSS 代码复制进去就能使用。但是考虑到某些不可抗力，还是建议将字体文件上传到云端，然后以相对路径的形式引用。\n:::\n\n\n\n[^1]: [TTF、TOF、WOFF 和 WOFF2 的相关概念](https://www.cnblogs.com/bianchengsanmei/p/15857883.html)\n\n\n\n","tags":["Hexo","Tutorial","NexT","Font"],"categories":["Hexo教程"]},{"title":"Blog 8：[Hexo教程]Hexo之提交搜索引擎收录","url":"/posts/ff51cb4c/","content":"# 序\n利用`sitemap.xml`来提交**搜索引擎收录**，是搜索引擎优化（SEO）的重要一步。本文将介绍如何利用`sitemap.xml`来提交**百度**、**谷歌**、**必应**的搜索引擎收录。  \n\n<!-- more -->\n\n***\n\n# 准备  \n## 何为 Sitemap？  \n> Sitemap（站点地图）是一种文件的统称，通常Sitemap（站点地图）可以是txt或者XML格式。通过Sitemap（站点地图）你可以告诉搜索引擎关于你的站点中的网页、视频或者其他文件的相关信息，帮助搜索引擎更好的认识和理解你的站点。格式正确的Sitemap（站点地图）文件会帮助搜索引擎更高效地抓取你的网站。XML格式的站点地图，通常会包含更多的信息，比如你可以通过Sitemap（站点地图）文件告诉搜索引擎你认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。例如，网页上次更新的时间和网页是否有任何备用的语言版本。\n> [**知乎**](https://zhuanlan.zhihu.com/p/441973408) \n\n简单来说，Sitemap 使得您可以一次性提交全站的所有 URL 等信息，帮助搜索引擎快速给您的网站建立索引。  \n\n## 何为搜索引擎优化（SEO）？  \n> SEO（Search EngineOptimization，搜索引擎优化）是一种利用搜索引擎的内在规则，优化网站结构和内容，从而提升网站在搜索引擎结果中的自然排名的方法。\n> [**百度百科**](https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132)\n\n搜索引擎收录了无数的网页。当用户搜索时，搜索引擎根据用户的关键字找到所有相关的网页，然后通过一定的算法对这些网页进行排名，将最相关的网页放在搜索结果的前面。搜索引擎优化就是通过一些技术手段，让网站在搜索引擎中排名靠前。  \n那么很显然，您必须首先把整个网站的 URL 都提交给搜索引擎，才能让搜索引擎收录之。进而您再考虑 SEO。  \n\n## 安装插件\n您需安装`hexo-generator-sitemap`插件和`hexo-generator-baidu-sitemap`插件。前者用于生成通用的`sitemap.xml`，后者用于生成**百度**的`baidusitemap.xml`。   \n\n```bash\nnpm install hexo-generator-baidu-sitemap --save\nnpm install hexo-generator-sitemap --save\n```\n\n## 修改配置文件  \n打开**站点配置文件**`_config.yml`，添加以下内容：  \n```yaml\n# 自动生成sitemap\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n## 生成和部署  \n在 Hexo 根目录下，运行：  \n```bash\nhexo cl\nhexo g\nhexo d\n```\n\n此时，在根目录的`public`文件夹中，您会发现其中生成了`sitemap.xml`和`baidusitemap.xml`两个文件。  \n文件的主体部分大致如下：\n```xml\n<url>\n    <loc>http:/example.com/test/123456/</loc>\n    <lastmod>yyyy-mm-dd</lastmod>\n</url>\n```\n\n这就是您需要提交给搜索引擎的 URL 信息：**URL 地址**、**最后更新时间**。  \n\n# 提交百度\n## 登录百度站长平台\n由此进入：[百度站长平台](http://zhanzhang.baidu.com/)  \n并进入**站点管理**页面：  \n![站点管理](站点管理.png)  \n\n<a id=\"Section\"></a>\n## 添加站点并验证  \n输入您网站的域名：  \n![添加站点](添加站点.png)  \n\n在**验证网站**页面，选用**文件验证**方式，并下载指定的验证文件（当前：`baidu_verify_codeva-JSNntnC1KX.html`）：  \n![验证](验证.png)  \n\n将此验证文件放入`themes/next/source`下，然后执行：  \n```bash\nhexo cl\nhexo g\nhexo d\n```\n\n等待 GitHub Pages 部署完成（您可在 GitHub 页面查看进度）。然后点击**完成验证**。  \n\n## 主动推送\n您需安装`hexo-baidu-url-submit`插件。该插件可在您执行`hexo d`时自动向**百度**推送。  \n```bash\nnpm install hexo-baidu-url-submit --save\n```\n\n修改**站点配置文件**`_config.yml`，添加以下内容：  \n```yaml\nbaidu_url_submit:\n  count: 5 ## 提交最新的五个链接\n  host: http://example.com ## 百度站长平台中注册的域名\n  token: your_token ## 准入秘钥\n  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里\n```\n\n::: warning\n`host`字段一定要填写**站长平台注册的域名**。  \n要获取`token`，请点击**普通收录**，点击**API提交**，在**推送接口**一栏可以找到`token=********`字样。\\*为您的`token`。\n:::\n\n::: warning\n请检查**站点配置文件**`_config.yml`中的`url`字段是否正确。形如：  \n``` yaml\n# URL\nurl: http://example.com\nroot: /\npermalink: :year/:month/:day/:title.xml\n```\n\n`url`字段必须是**站长平台注册的域名**。\n:::\n\n最后，加入新的 deployer：  \n```yaml\ndeploy:\n- type: git ## 原来的deployer\n  repo:\n  branch:\n- type: baidu_url_submitter ## 添加这里内容即可\n```\n\n::: warning\n出现了两个`type`字段，因此您**必须**在前面添加`-`字符。\n:::\n\n## 自动推送  \n您可令页面被访问时，其 URL 自动推送给百度。\n修改**主题**目录下的`layout/post.swig`文件，末尾加上：  \n```html\n<script>\n(function(){\n    var bp = document.createElement('script');\n    var curProtocol = window.location.protocol.split(':')[0];\n    if (curProtocol === 'https') {\n        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        \n    }\n    else {\n        bp.src = 'http://push.zhanzhang.baidu.com/push.js';\n    }\n    var s = document.getElementsByTagName(\"script\")[0];\n    s.parentNode.insertBefore(bp, s);\n})();\n</script>\n```\n\n## Sitemap 提交\n::: tips\n百度站长平台貌似已经限制了 Sitemap 提交，暂时未获取提交机会。\n:::\n\n::: warning\n百度似乎无法爬取 GitHub Pages 上的网页，据说需要二次部署至 Coding 上。**待更新**\n:::  \n\n# 提交谷歌  \n## 登录 Google Search Console  \n由此进入：[Google Search Console](https://search.google.com/search-console/about)  \n点击**立即使用**。  \n\n## 添加站点并验证  \n[同上](#Section)。  \n\n## Sitemap 提交  \n在**编制索引**下找到**站点地图**，输入您的站点地图网址。例如：`http://example.com/sitemap.xml`。  \n\n您可以在上方搜索栏输入此网址，让**谷歌**检测您的 Sitemap 是否可以被收录。  \n![网址检查](网址检查.png)  \n\n点击**测试实际网址**  \n\n![成功](成功.png)  \n\n::: success\n您应期望看到的结果是：  \n`是否允许抓取？：是`  \n`是否允许编入索引？：是`\n:::\n\n若提交了 Sitemap 但显示`无法抓取`，则可能是由于 **GSC**的显示 bug，请等待一段时间。\n::: danger\n据说是这样，目前为止我的 Sitemap 还没有显示成功提交。。。\n:::  \n\n# 提交必应  \n## 登录 Bing Webmaster\n由此进入：[Bing Webmaster](https://www.bing.com/webmaster/)  \n可以使用 **Microsoft** 账户登录。  \n\n## 一键从 GSC 导入名下网站  \n登录您的 **Google** 账户即可。  \n\n## 或手动添加网站并验证  \n[同上](#Section)。  \n\n## Sitemap 提交  \n::: success\n**Bing** 办事效率非常高，Sitemap 一下就通过了。 \n:::\n\n","tags":["Hexo","SEO","Baidu","Google","Bing"],"categories":["Hexo教程"]},{"title":"Blog 7：[Hexo教程]更高级的 Markdown 渲染器：Markdown-it","url":"/posts/e11361f1/","content":"::: tips\n我正在使用 Markdown-it 来渲染此博文！\n:::\n\n# 序\nHexo 默认使用 **hexo-renderer-marked** 来渲染 Markdown 文件。此渲染器只支持一些基础语法。我们可以将其替换为更高级的 **Markdown-it** 渲染器。  \n\n<!-- more -->\n\n***\n\n# 安装\n首先，您需要卸载原有的渲染器：  \n```bash\nnpm uninstall hexo-renderer-marked --save\n```\n然后安装新的渲染器：\n```bash\nnpm i hexo-renderer-markdown-it --save\n```\n接着，您需要安装三个 Markdown-it 子插件：\n```bash\nnpm i markdown-it-checkbox\nnpm i markdown-it-imsize\nnpm i markdown-it-expandable\n```\n::: warning\n请注意：科学上网。\n:::  \n::: tips\nMarkdown-it 内置了许多子插件，您只需手动安装上述三个。\n:::\n\n***\n\n# 配置\n在**站点配置文件**的尾部填写 Markdown 渲染器配置：\n```yaml\nmarkdown:\n  preset: \"default\"\n  render:\n    html: true\n    xhtmlOut: false\n    langPrefix: \"language-\"\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: \"“”‘’\"\n  enable_rules:\n  disable_rules:\n  plugins:\n    - markdown-it-abbr\n    - markdown-it-cjk-breaks\n    - markdown-it-deflist\n    - markdown-it-emoji\n    - markdown-it-footnote\n    - markdown-it-ins\n    - markdown-it-mark\n    - markdown-it-sub\n    - markdown-it-sup\n    - markdown-it-checkbox\n    - markdown-it-imsize\n    - markdown-it-expandable\n    - name: markdown-it-container\n      options: success\n    - name: markdown-it-container\n      options: tips\n    - name: markdown-it-container\n      options: warning\n    - name: markdown-it-container\n      options: danger\n  anchors:\n    level: 1\n    collisionSuffix: \"\"\n    permalink: false\n    permalinkClass: \"header-anchor\"\n    permalinkSide: \"left\"\n    permalinkSymbol: \"¶\"\n    case: 0\n    separator: \"-\"\n```\n::: tips\n要禁用某插件，您可**注释**该行。\n例如：\n```yaml\n# - markdown-it-abbr\n```\n~~或者直接删了~~\n:::\n::: warning\n上述代码的 `level` 字段表示最上级锚点的层级。当设置为 1 时，表示 `<h1>` 到 `<h6>` 都可以作为锚点。用于目录的跳转。\n:::\n\n***\n\n# 修改CSS  \n[自定义容器](#Section)的样式需要您手动修改。对于NexT主题，您需要在以下路径的文件中添加CSS样式代码：\n```\nthemes\\next\\source\\css\\_common\\scaffolding\\base.styl\n```\n参考样式：\n```css\n.tips {\n    padding-left: 10px;\n    background-color rgba(52,152,219,.3);\n    border-left 4px solid rgb(52,152,219);\n    color: darken(rgb(52,152,219),20%);\n}\n.success {\n    padding-left: 10px;\n    background-color rgba(46,204,113,.3);\n    border-left 4px solid rgb(46,204,113);\n    color: darken(rgb(46,204,113),20%);\n}\n.warning {\n    padding-left: 10px;\n    background-color rgba(241,196,15,.3);\n    border-left 4px solid rgb(241,196,15);\n    color: darken(rgb(241,196,15),20%);\n}\n.danger {\n    padding-left: 10px;\n    background-color rgba(231,76,60,.3);\n    border-left 4px solid rgb(231,76,60);\n    color: darken(rgb(231,76,60),20%);\n}\n```\n::: tips\n其他主题，您可**自行查找**\n:::\n\n***\n\n# 调用\n## 基础\n\n|插件|描述|语法|效果|\n|-|-|-|-|\n|markdown-it-abbr|注释|`*[HTML]: Hyper Text Markup Language`|*[HTML]: Hyper Text Markup Language|\n|markdown-it-emoji|表情|`:+1:`|:+1:|\n|markdown-it-footnote|脚注|`文本[^1]文本`|文本[^1]文本|\n|markdown-it-ins|下划线|`++Inserted text++`|++Inserted text++|\n|markdown-it-mark|突出显示|`==Marked text==`|==Marked text==|\n|markdown-it-sub|下标|`H~2~O`|H~2~O|\n|markdown-it-sup|上标|`X^2^`|X^2^|\n|markdown-it-checkbox|复选框|`- []未选中`<br>`- [x]已选中`|- [ ] 未选中<br>- [x] 已选中|  \n\n## 进阶\n### 折叠\n```markdown\n+++ **点击此处**\n这是被隐藏的内容。\n+++\n```\n效果：  \n+++ **点击此处**  \n这是被隐藏的内容。  \n+++\n\n<a id = \"Section\"></a>\n### 自定义容器  \n```markdown\n::: tips\n**提示**\n这是一个提示\n:::\n\n::: warning\n**警告**\n这是一个警告\n:::\n\n::: danger\n**危险**\n这是一个危险信号\n:::\n\n::: success\n**成功**\n这是一个成功信号\n:::\n```\n\n效果：  \n::: tips\n**提示**\n这是一个提示\n:::\n\n::: warning\n**警告**\n这是一个警告\n:::\n\n::: danger\n**危险**\n这是一个危险信号\n:::\n\n::: success\n**成功**\n这是一个成功信号\n:::\n\n***\n\n# 推荐\n- 查找 Emoji 的写法，您可参考：[EMOJIALL](https://www.emojiall.com/zh-hans)\n- 查阅 Markdown-it 文档，您可参考：[Markdown It 插件](https://mdit-plugins.github.io/zh/)\n- 了解更多 Markdown 语法，您可参考：[Markdown 教程](https://markdown.com.cn/)\n\n[^1]: 这是参考文献。\n","tags":["Hexo","Tutorial","Markdown"],"categories":["Hexo教程"]},{"title":"序","url":"/posts/9eefdea9/","content":"<i class=\"fa fa-comment\" aria-hidden=\"true\" style=\"color: #6A5ACD; font-size: 1.5rem;\"></i><span style=\"font-size: 12px; color: #695acd91;\"> 随机句子由一言 API 提供</span>\n<p id=\"hitokoto\" style=\"text-align:center;font-weight:bold;color:#6A5ACD\">\n  “<a href=\"#\" id=\"hitokoto_text\">:D 获取中...</a>”\n</p>\n<script>\n  fetch('https://v1.hitokoto.cn')\n    .then(response => response.json())\n    .then(data => {\n      const hitokoto = document.querySelector('#hitokoto_text')\n      hitokoto.href = `https://hitokoto.cn/?uuid=${data.uuid}`\n      hitokoto.innerText = data.hitokoto\n    })\n    .catch(console.error)\n</script>\n\n\n\n> “创作是并没有什么秘诀，能够交头接耳，一句话就传授给别一个的，倘不然，只要有这秘诀，就真可以登广告，收学费，开一个三天包成文豪学校了。以中国之大，或者也许会有罢，但是，这其实是骗子。”    \n**《不应该那么写》 鲁迅**\n\n\n我已经记了若干天的博文，这才想起来应该为整个博客写一篇序。先前一直用[两篇小诗](http://samuflore.top/posts/95afa136/)充门面，观赏了几位大佬[^1]的博客页面之后，决心要做一些正式的事情了。  \n于是我又选择了这个将要睡觉的时间开始。  \n按照我妈的说法，我仿佛永远都选择将要睡觉的这个时间点开始做所谓“重要的事”，譬如突然要给 200G 的压缩包解压缩[^2]，或者安装进度到了70%……总之一条，是不能关电脑，也不能安心上床，结果“搞得大家都睡不了觉”。可是这个时间段恰好是最适合开始做某件事的时候——未必能做完，但是能开个好头。  \n**所以，现在我要写小序了。**  \n\n<!--more-->\n\n# 字与码\n我进入六系既成事实，那么接下来的若干年必然是与代码打交道居多。这博客正好可以记录我的编程之旅，也算是为自己留下一点纪念。  \n所谓**码字**一词，在博客的创作过程中，真可谓十分贴切。使用 Markdown 编写博文，甚至于使用 HTML。Markdown 如此之简洁和优雅，几乎融于文字之中，正是**字**与**码**的结合。HTML 则时常将我从**字**里拉回**码**中。我不知道**古法写作**是否会长盛不衰，不过其面临这样一种对手，或许会走入另一条道路上。  \n**古法写作**，我杜撰了这个词，但使用起来很奇怪。何谓“古”，很难说清。如果用创作文字之方法区分，则没有明确的界限，或者以 AI 辅佐写作之出现来划分，又显得这个“古”字很“新”了，并不贴切。可是论其本质，那么所谓古法、码字，又殊途同归了，那就是**记录**，**记录**。  \n古代，我们往石头上刻，往竹简上刻，这就叫做“刻录”。后来**蔡伦**改良了造纸术，我们就往纸上记，这就叫做“记录”。记了几千年，后来发明了软盘、磁带、硬盘，我们又回到刻。以上种种，无非是留存人存在过的痕迹。每个人都是时代的一粒沙，无后的，一代人的时间就会消失得无影无踪；好一些的，也不过三四代而已。流芳百世，少之又少。**而文字的生命却是决定于载体**。流传千年的语言不少，而其载体是人，这又回到了人在时代面前之渺小。譬如**拉丁语**，早已成为冢中枯骨。而文字，文字，载体是物，物质世界正是文字世界。在这样宏观的视角来看，似乎并无必要将**字**与**码**划清界限。  \n创作方面，**字**与**码**仿佛又有所相通。这里又可说起**古法写作**了。不论概念，可以明确的是自**生成式人工智能**广泛应用后，早已不是所谓**古法写作**的时代了。然而其方法和宗旨是经久不衰的，并且不仅限于**字**，也是可以推广到**码**上的。倘若今天我们**突然**需要写一篇 5000 字的**法律与科技**结课报告[^3]，那么不但要用 AI ，还要**严谨地**[^3]用，所谓**古法**，在期末周，在水课面前，自然是毫不犹豫地放弃的。然而平时的创作，如果依赖于 AI ，后果确实不堪设想。文笔是一定会生疏的，危害更甚于提笔忘字，到了有口说不出、有笔写不了的地步。**更何况互联网的混乱已经相当程度摧残了各种语言**。**码**的时候，同样会遭遇这种困境。确实，用 **Copilot** 或 **Fitten Code** 代行一些结构高度重复的代码编写，节约时间用于思考。可是人总是顺应惰性，`Tab` 按个不停，一眨眼，就连思考也被**自动补全**了。这岂不与前述的面临一样的麻烦吗？  \n**字**与**码**，这两者的界限，似乎并不那么清晰。  \n总之，我会尽量继续探索这二者——当然，是以一篇篇博文的形式，而非论文。也许一切明了的时候，我会写出一篇总的，来综述我的观点，而不是像这样一篇凌晨一点写的小序——**散**、**乱**、**迷**。不明了的时候，当然，继续更新些**别的**。  \n**仿佛找到了一个比游戏更有意思的事情。**  \n构建本站的时候，我的想法通常不会有明确的规划。如果您不知道从哪开始，建议您从 [<i class=\"fa fa-thumbs-up\" aria-hidden=\"true\"></i> 此处](http://samuflore.top/about/) 开始探索。  \n**感谢您的时间。**\n\n<img src = \"./luxun.jpg\" width = \"50%\" >\n\n[^1]: [钟鼓楼](https://thysrael.github.io/)、[Hyggge's Blog](https://hyggge.github.io/#!)、[Parker's Blog](https://x-parker.github.io/) ，以及其他大佬。\n[^2]: 我可能正准备游玩 **The Elder Scrolls V: Skyrim** 的某个整合包（\n[^3]: 确有其事。\n","tags":["Introduction"]},{"title":"Blog 5：[遊記]井冈山","url":"/posts/82cd8a81/","content":"# 序\n> 请注意：本博文按**时间顺序**组织。  \n\n国内旅游我有两个“**东南西北**”的计划，我愿称之为**大**东南西北和**小**东南西北。我正在完成**小**东南西北的**东**。  \n\n<!--more-->\n\n- 大东南西北，意思就是全国的东南西北要至少取四个有代表性的地方旅游一次。\n    - 北：~~目前我在北京上学~~大一寒假去**吉林吉林**滑雪了。\n    - 南：**尚未计划**。\n    - 西：**计划今年国庆去西安旅游**\n    - 东：去过**山东泰安**和**青岛**，以及**上海**、**无锡**\n- 小东南西北，自不用说，就是相对**湖南**的东南西北了。\n    - 北：**湖北武汉**，好吃，但是好危险。\n    - 南：**尚未计划**。\n    - 东：本篇博客的重头戏，**江西吉安**，具体说来是**井冈山**。\n    - 西：**贵州铜仁**，就这个暑假去的，爬**梵净山**，风景很好，但是被淋成落汤鸡了。  \n\n希望大四前可以完成这两个计划吧，毕竟还是很有希望的。\n\n***\n\n# 第 0 天：吉安\n下午好，**江西**~  \n\n![吉安站](吉安站.jpg \"抵达\")\n\n## 出发前\n从18日起，我就要到**井冈山**去和**湘贤汇航**实践队成员参加社会实践活动，直至26日结束。今天提前一天到**吉安**做准备。\n说实话，17日到18日这一小段在**吉安**的时间，算得上是我第一次完完全全**独自**旅行。没有任何同伴，也没有任何计划，只有纯粹的自由。有点奇妙的感觉。  \n*（高铁、Switch满电、无尿、4小时.jpg）*  \n~~坐我边上的女生打农开麦被前排阿姨骂了，害怕~~\n\n## 落地\n我总是喜欢把到达叫做落地，尽管并没有坐飞机。  \n对于人来说，双脚同时踏上地面，才有一种踏实的感觉，这就叫做脚踏实地。对我而言，可能只有整个人都在站台上的时候，我才会觉得真正到了这个地方吧。  \n打个的直奔酒店，环境很不错，司机师傅人也很好，他告诉我从**吉安**到**井冈山**打车要两三百，大学生还是老老实实去坐大巴吧……  \n> “你不是**井冈山**人吧？”\n> “你没有报销吧？有钱人，要去**井冈山**，人家不想坐大巴，又懒得坐火车，嫌麻烦，就打个的，又有报销。”  \n\n太有道理了。~~不过我好像有报销~~  \n师傅确实很友善，走的时候我第一次给一个司机师傅道谢。\n\n> “谢谢师傅啊。”  \n\n初来乍到碰见一个友善的陌生人还是挺不错的。\n\n## 晚餐\n对于我这种人，到了一个新地方那必须要尝尝**地地地道地地道道**的美食。  \n于是直接美团点了~~南昌拌粉~~*（没做攻略是这样的，当地有什么美食都不清白）*。  \n\n![南昌拌粉](南昌拌粉.jpg \"好吃的\") \n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">腐竹，我加了腐竹</p> \n\n作为一个**芙兰**人，我觉得它还是有点**清淡**了。看上去是放了**蛮多**辣椒，但是咸也不咸，辣也不辣，不过**口感倒是独特**。这拌粉吃起来很**清爽**，没有**热干面**那种黏糊糊的感觉，很顺滑。配的汤很不错。  \n\n吃饱喝足要不要出去逛逛，还没想好，先写到这吧。 \n\n## 夜行\n\n那还是要散散步消化消化的。挑个最近的景点直接出发了。  \n\n![导航](导航.jpg \"前往庐陵文化城\")  \n\n> **庐陵**，地名，位于**中国江西省**。**吉安市**在**隋朝**成为**庐陵郡**，故**吉安**古时又称**庐陵**。**元**初取“吉泰民安”之意改称**吉安**。**民国三年庐陵县**改称**吉安县**。———[百度百科](https://baike.baidu.com/item/%E5%BA%90%E9%99%B5/2836483)\n\n**吉安**自古人杰地灵，乃是**吉州福地**、**文章节义之邦**。这么一小段路，给人第一感觉是城建规划良好，道路宽阔，功能完备。此时已日落，气温渐降，市民慢慢从空调房里回到街上散步消食。这种慢悠悠的生活节奏令我很舒服。  \n走着走着突然走上桥了———散漫到这种程度，甚至没看这**庐陵文化城**是沿江而建的。 \n\n![江景](江景.jpg \"不是很清楚\")  \n\n此地已经被打造成类似公园的场所。沿着绿道走有商店、咖啡馆、书店（里面书不多，装潢倒不错）、小吃摊（世界的**冰凉粉**）。夜晚拜访很不错，江边很凉快，游人不多也不少，正好融进风景中。我刻意绕了远路，把两座桥都逛了一遍，准备撤的时候又被一座**神秘建筑**吸引了过去。  \n\n![凤凰](凤凰1.jpg \"神秘建筑\")  \n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">这里是真有凤凰</p>\n\n雕像前有露天剧院般的台阶座椅，已经聚集了许多人在观赏了。  \n不知道怎么，我瞥了一眼一旁的告示牌———没有灯，位置也不醒目，但是上面赫然写着：  \n\n> **凤凰水幕光影秀**\n每晚演出时间：**20:30**  \n\n这时一看表，只有5分钟了，难怪人群都聚集在这。于是找了个空位坐下来歇脚、拍照。 琢磨一下怎么安排明天去**井冈山**的行程。 \n\n> “叔叔，你要买水吗？”\n> “……？”  \n\n我面前正站着一个小孩，正举着一瓶矿泉水看着我。  \n原来已经变成叔叔了，今天睡不着了。  \n\n![凤凰](凤凰2.jpg \"神秘建筑\")  \n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">凤凰展翅</p>\n\n***\n\n# 第 1 天：有惊无险\n\n按照昨天的规划，我还是打算坐大巴去**井冈山**。一看路线，竟有一站距离我宾馆只有 25 分钟步行路程，走走路就能免掉十几块去**吉安西**的网约车费用，岂不美哉。可是这却差点害死我。  \n我在**某度地图**上设定了这个**人民广场站**，还三番五次确认是否有重名的可能。谁料到一出宾馆大门，竟然下起**太阳雨**来，现在想想真可谓一个噩兆。抵达**人民广场站**后我就松懈下来，找了个阴处开始休息。~~一边还喝了几杯米酿~~  \n还有七八分钟的时候，我掏出手机一看，总觉得不对。细看大巴的来车方向，竟然是马路对面，这下彻底晕了。在这边公交站望去，对面看不到有没有站台，但是手机上却明明白白的标着方向。要不要换边，现在做决定。  \n当然，我还是拿起行李又慌慌张张地过马路了。所幸，还是相信了**科学**。  \n\n![基地](基地.jpg \"基地\")\n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">井冈山基地，环境还挺好的</p>  \n\n![天气](天气.jpg \"天气\")  \n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">只是天气的确有点死了</p>  \n\n## 另一条路\n高中以来，我父母，奶奶（准确说是外婆，但是我特别讨厌这个“外”字，从来都是喊奶奶），劝我报考**国防科技大学**，到了**无所不用其极**的地步。甚至，我已经被 **BUAA** 录取了，他们还会在我耳旁念叨，说某同学与我一届，正是报的**国防科大**，每次回来，军装在身，多么漂亮！说某外地考生，斩获高分，仍然放弃名校，要上**国防科大**，其真实性，不可考究，但是他们在我耳边磨过来磨过去，我反正是确信有这样一号人物的。  \n我并非受不了军事化管理，只是觉得大学应当有更多的自由，否则如何对得起这 12 年的不自由？因此我从未考虑过报考它。不过，它的确在我心中蒙着一层神秘的面纱。\n\n![演讲](演讲.jpg \"演讲\")  \n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">今天，机会来了</p>  \n\n甚至是由一位本科就读于**空军工程大学**、在**国防科技大学**读研究生的学长来为我们讲演。这样一位人物，我倒觉得很亲切了，因为我的确认识在**空军工程大学**就读的某同学[^1]，并不像所谓**高分就读**的某同学那么缥缈。  \n阅历丰富，做讲演时各种例证都是手到擒来，观感十分好。一把颠覆了军人在我心中不苟言笑的刻板印象。  \n也许，这真的是另一条道路？  \n\n# 第 2 天：上课、吃饭与昏昏欲睡\n![课程](课程.png \"报告厅昏昏欲睡\")  \n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">教学安排</p>  \n\n## 想睡觉  \n早上六点多有个~~神秘~~早读，第一天入住又不太习惯，导致睡眠实在不充分。困啊……  \n基地的管理倒很松，时间也充裕，每天晚上还有时间更新博客。至于课程的内容，确实，老师已经竭尽全力追求新的讲课方式了，部分内容的确很不错。可惜，困啊……  \n伙食方面则大大超出预期了。菜品种类虽不是很丰富，不过可以任选，而且味道不错。此外，**江西老表**和我们**芙兰**人一样喜欢吃辣椒，甚至食堂还供应了**剁辣椒**，咸香酸辣，岂不美哉！**比起我在北京吃的网购包装辣椒，这简直是天下无双**。*（后半句是 AI 自动补全的，天下无双都被想出来了:frowning:）*  \n\n## 忠贞不渝\n> “只有爱给你解开不死之谜。”\n> **费尔巴哈**  \n\n两千年前，我们讲“山无陵，江水为竭。冬雷震震，夏雨雪。天地合，乃敢与君绝”；两百年前，我们讲“生命诚可贵，爱情价更高；若为自由故，二者皆可抛”；今天，它几乎成了一文不值的垃圾。  \n现代社会也许不会再有**池煜华**这样的人出现了，毕竟大家没有几个 70 年可以“**浪费**”。  \n什么是一诺千金，什么是千金一诺，她也许永远都不会知道了。她甚至不会知道自己已经等了七十年。镜子里的她老了，可她却不老，否则丈夫要怎样认出她来呢？  \n但是什么是爱，什么是眼泪，她一定是知道的。爱让她感受不死，眼泪让她感受活着。  \n后来她再也没有眼泪了，因为她终于等到了**李才莲**。只是镜子、信和家门口的小路已经永远埋没了。  \n\n***\n\n# 第 3 天：风土\n\n## 土\n昨天晚上的课上，一位**井冈山**的老师说，**井冈山人**喜欢说“**好客气**”，并不只是夸赞对方，也同时夸自己。今天在**马源村**，我的的确确感受到了。  \n\n![标语](标语.jpg \"奇怪的标语\")  \n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">神秘标语</p>  \n\n按照安排，我们实践队和同行的**长春中医药大学**的部分队伍成员共同前往当地一家民宿体验做饭。一踏进门，只听见此起彼伏的招呼声：  \n> “娃娃，你们是大学生吧？”\n> “看着好小哟，还以为是高中生。”  \n\n一边要我们**不是炊事员**的没什么事~~就到一边凉快去~~就到外面乘凉。  \n\n> “你们是从哪里来的呀？”\n> “我们是在**北京**上学，但是大部分人都是**湖南**的。”\n> “噢，那你们就是从**北京**来的咯。”\n> “反正不管你们是哪里人，你们现在在**北京**，那就是从**北京**来的嘛。”  \n\n也是享受京:v:待遇了（  \n\n![饭菜](饭菜.jpg \"好吃\")  \n\n稍微有点失望的是饭菜仍然不是很辣。我们自己做的不提，毕竟队伍中有**东北**人。但老乡提前做好的菜也不是很辣。不过疲惫了一上午，食欲大振，三两下便一扫而空。  \n\n> “来我来敬大学生们一杯！”  \n\n原来隔壁桌的**真客人**听到了我们和老板娘的谈话，竟喝至兴头，起身到我们这边来敬酒了。这实在是受宠若惊，于是连连起身，拿着塑料瓶子的**冰红茶**就碰上杯了。**好客气**，的确不是吹的。  \n说起来，这位老板娘，可真值得敬畏。我们采访时，她说这家民宿是她一手创办的，客源很充足。营业八年间创收不断，口碑响亮，甚至有回头客年年光顾，来**井冈山**度假就下榻于此。一边带我们到满是荣誉证书的墙面上，讲起政府扶助他们，减免税收，授予称号，确实是**名利双收**了，令人钦佩。  \n\n![实践队1](实践队1.jpg \"我们与老板娘的合影\")\n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">与老板娘合影</p>  \n\n![实践队2](实践队2.jpg \"与友校合影\")\n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">与长春中医药大学部分队员合影</p>  \n\n这里的人就是这里的大地和山。**湘赣鄂**不缺大地和山，自然不缺这样的人。\n\n## 风\n\n> “野马也，尘埃也，生物之以息相吹也。”\n> 《逍遥游》  \n\n古时候人们认为山有灵气，山上的生灵则承载这些灵气。生物产生的气息，引发雾气飘荡，天气变化，尘埃起伏。无论这套说法有没有道理，至少说明了人类对自然的敬畏之情。  \n也许海拔稍高的山都有同样的“毛病”，那就是说变脸就变脸。浓雾可以在一眨眼内包围四周，大雨可以在一呼吸间倾盆而下。**黄洋界**海拔 1343 米，自然也有这样的现象。只不过这一瞬间把我带回**梵净山**的悲惨回忆里了。  \n不过这里也许真有所谓灵气。当然，有别于儒释道的宗教属性，而是源于人类崇高的理想。  \n\n![迫击炮](迫击炮.jpg \"迫击炮\")  \n<p align=\"center\" style=\"font-size:10px; color:#C0C0C0\">这一炮直指湖南（</p>  \n\n# 第 4 天：朝圣者  \n\n![火炬](火炬.jpg \"井冈山的火炬\")  \n\n## 朝圣之旅  \n> “惊涛拍孤岛，碧波映天晓。虎穴藏忠魂，曙光迎来早。”\n> **毛泽东**\n\n![祭奠](祭奠.jpg \"烈士陵\")  \n\n**肃静。谨祈冥福。**  \n\n## 一个流亡故事  \n>夫天下有大勇者，智不能测，刚不能制，猝然临之而不惊，无朕加之而不怒，此其志甚远，所怀甚大也。所怀者何？天下有饥者，如己之饥；天下有溺者，如己之溺耳。民族危急，别亲离子而赴水火，易面事敌而求大同。风萧水寒，旌霜履血，或成或败，或囚或殁，人不知之，乃至陨后无名。\n><br>铭曰：呜呼！大音希声，大象无形。来兮精魄，安兮英灵。长河为咽，青山为证；岂曰无声？河山即名！\n><br>人有所忘，史有所轻。一统可期，民族将兴。肃之嘉石，沐手勒铭。噫我子孙，代代永旌。\n> **《无名英雄纪念碑铭》**  \n\n“我们最后决定把他的一半骨灰带回**八宝山**，另一半则仍然放在**台北**阴暗的骨灰塔里。”演讲的最后，**刘玉平**老先生和我们说。“因为他的任务还没有完成。”  \n今已不得而知**刘光典**烈士如何在**台湾**南部的群山中，在肉体和精神的双重折磨下坚持斗争四年之久的。不过从其儿子的口中可以瞥见他斩钉截铁说出“**我奉命**”三字时的精神、决心、忠诚。  \n\n![评价](评价.jpg)  \n\n在这样一座精神的孤岛上，困着很多同行的人，他们中间总有受不了苦，向命运投降的。这些人，一边要偷偷卷走大家的钱，先去享乐一番，挥霍一空后，一边还要看着身无分文的同伴说：“你们如此穷困，而我如此富有，何不学我们一样呢？”被骗了钱的，有的忍受不了饥寒，自尽了；有的学了他们，想办法骗走另一些人的钱。但是其他人里面总有一个人会站起来，走到那些人面前，给他们一人一巴掌，叫他们统统滚蛋。\n\n# 第 5 天：最后的晚餐\n\n按照规划，今天是统一教学的最后一天。接下来的两天是各实践队自主调研，25 日是统一汇报展示。26 日上午即可返程。  \n票是已经买好了，现在还需考虑从**井冈山**回**吉安**的交通。  \n这段时间不得不说，整体氛围是非常轻松。可能我还没从惯性思维中解脱出来，以为这种集体培训管理一定非常之严格，并且要求也会非常多。回头看看，才发现原来我已经是大学生了，这种小初高的军训思想，真是太过于刻板了。  \n由于海拔和地形因素，加之连日下雨，这段时间天气非常之凉爽。电是 24 小时供应的，热水是 24 小时供应的。超市、书店、餐厅、咖啡馆一应俱全。论条件，比以往经历的什么研学、军训都要好得多。时间安排上，则更为宽松。白天的活动基本在 17 时完全结束了，甚至可以回宿舍休息半小时再去吃晚餐。晚上则基本无事，不过下雨基本是不停的，也出不了大门。在书店读读书倒是很不错，不然就是在宿舍玩 Switch。只可惜没有带鼠标来。  \nWIFI 也是免费的，可以随时上网。  \n\n明天到**井冈山革命博物馆**，我有采访和记录任务，到时再更新具体情况。  \n\n# 第 6 天：采访记录  \n\n## 井冈山革命博物馆\n\n> L：您好，我们是**北航湘贤汇航**实践队的成员，想询问您几个问题，可以吗？\n> S：可以，大概需要多久时间？\n> O：几分钟就可以。\n> S：好的。\n> L：首先就是刚刚我们两个去体验了一下那个 VR *（金字塔之旅）*，然后我想问一下就是咱们这个博物馆有没有关于**井冈山**的 VR 项目？  \n> S：这个后续有做计划，目前还没有做。  \n> L：AR 项目有吗？  \n> S：这个后续也有计划，目前还没有做。  \n> L：那咱们博物馆有没有和**江西软件职业技术大学**共建一个“大思政课”的实验教学改革创新基地？  \n> S：我不太清楚，可能要专门去了解才知道这方面。  \n> L：好的，那么关于 VR 有没有针对于海外游客进行一些方便他们使用的设置？  \n> S：目前的话还是更针对于国内游客。  \n> L：那有没有进一步的计划，提升咱们博物馆的海外影响力？  \n> S：有的。就是之前有一段时间有日本的代表团或者其他国家代表团，还有研发团，都是有来我们博物馆调研讨论的。对于各种体验项目都有指导。  \n> L：然后还有一个问题，就是咱们这个 VR 的模型，考虑到用户体验的话，肯定要进一步提升这个模型的技术和模型精度，这就会意味着成本的提升。那么咱们博物馆是如何平衡用户体验和研发成本这两种情况？  \n> S：现在也是随着这个技术的不断进展，然后我们也在不断的沟通更多的合作方进行合作，看看有没有更多的更好的产品，这方面做的还是挺快的。但是我们也会考虑成本的问题，毕竟也要看这个效果，和下一步能做的更好的地方。  \n> L：好的，谢谢！\n\n*(握手)*\n\n## 元宇宙公司\n\n![通知](通知.jpg \"倒闭了\") \n\n**调研地点倒闭了**\n\n# 第 7 天：7 月 24 日\n\n今天不写游记。因为**明末：渊虚之羽**暴死了。  \n至今为止，我们的文娱产品，大概都要经历这样的周期律：\n- 无人看好，市场固化\n- 出现一位先锋\n- 外被指抄袭，内被挖墙角\n- 沿用西方先进技术，破釜沉舟，大获成功\n- 国内外获得美誉\n- 模仿先锋的产品如雨后春笋般立项\n- 模仿者暴死\n\n**明末：渊虚之羽**之于**黑神话：悟空**，正如**上海堡垒**之于**流浪地球**。虽然其结果的确可以预料，但不得不说是一种莫大的悲哀。  \n首先作为一款动作游戏，制作组给**明末**的定位就有偏差。自从开始宣发，其 PV ，宣传图，无不散发着一种“卖肉”的感觉。以此吸引玩家，无可厚非。但是既然没有**光荣特库摩**的水准，就必须考量清楚如何平衡吸引的元素和游戏本身的质量。此刻开始我就已经隐约感觉**明末**发售的情况不容乐观了。  \n其次是灾难般的优化。上到 **Rockstar Games** 的 **Grand Theft Auto IV** ，**CD Projekt Red** 的 **Cyberpunk 2077** ，下到什么**浩劫前夕**，优化有问题，是所有人都要得罪的。**明末**可谓玩家、媒体得罪了个遍。  \n再次是定价问题。这倒不能全怪制作方，而要声讨 **505 Games** 这个发行方。暗箱操作给外区**永降**，令人不齿，又首发加入 **XGP**。**游戏科学**坚持自己发行**黑神话**，反而使之成为了“保值货”，实在是高下立判。另外，标准版和豪华版居然没有区别，而价格上差了 50 大洋？这实在是……  \n\n没有人会因为一句“国产”的口号而把整整齐齐 248 块大洋摆在你面前。也许**甲午战争**左右会有，但是即便是那时候的人也都知道：国货稍微差一点，但并不粗制滥造，价格上比洋货便宜点，那是可以接受的；但如果有人要发国难财，那是不得好死的。  \n\n# 第 8 天：结业式\n\n![结业式](结业式.jpg \"结业式\")\n\n结束了，明天回家。  \n顿感时间流逝之快。今天已是放暑假一个月整了，而我除了参加这个社会实践似乎还没做什么正经事。不过后一个月有的忙了，一方面要练车，一方面，还接了一个敲代码的活，也是体验上乙方生活了。\n\n\n[^1]: 同为24届毕业生的 P 君，又被称之为“**天皇**”。\n\n\n","tags":["Travel","Trip","Mount Jinggang","Jiangxi Province","Ji'an City"],"categories":["遊記"]},{"title":"Blog 4：[Hexo教程]Hexo之博文添加图片","url":"/posts/1bea1421/","content":"> 请注意：本文参考了[CSDN](https://blog.csdn.net/m0_43401436/article/details/107191688)的有关教程。\n# 序\n博文美化小妙招（\n<!-- more -->\n***\n# 启用post_asset_folder开关\n在**站内配置文件**``_config.yml``中，``Ctrl + F``搜索字段``post_asset_folder``，将其值设置为``true``。此操作将允许在``hexo new \"filename\"``时，在``source/_posts/``目录下创建同名文件夹，以管理博文中的各种附件。\n***\n\n\n~~# 安装hexo-asset-image插件~~\n~~> 注意**科学上网**~~\n\n~~在Hexo根目录下打开``Git Bash``，输入：~~\n~~```bash~~\n~~npm install https://github.com/CodeFalling/hexo-asset-image --save~~\n~~```~~\n~~等待。~~\n~~> 本机测试时，``npm install hexo-asset-image --save``无法实现上述功能，因而换用。读者可以自行尝试之。~~\n\n::: warning\n**注意**  \n本条更新于8/8/25，``hexo-asset-image`` 插件已经失效。换用 ``hexo-asset-img`` 插件。\n:::  \n\n# 安装hexo-asset-img插件\n\n在 Hexo 根目录下打开 Git Bash，输入：\n```bash\nnpm install hexo-asset-img --save\n```\n等待。\n\n修改站点配置文件 ``_config.yml``。  \n```yaml  \npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\nrelative_link: false\n```\n\n***\n# 在Markdown中引用图片\n在博文中，引用图片的语法如下：\n```markdown\n![\"替换文本\"](图片名称.扩展名 \"描述文本\")\n```\n> - 请注意：``\"替换文本\"``和``\"描述文本\"``是可选的。\n> - 请将图片预先放在上述创建之同名文件夹下。\n> - **只需**填入图片名而**无需**填写路径。这是因为hexo-asset-image插件在Hexo将Markdown渲染为HTML时，会自动补全路径。\n\n例如：\n```markdown\n![title](image.jpg \"description\")\n```\n***\n# 效果\n[![效果](效果.png \"可以参考第三篇Blog~\")](http://samuflore.top/posts/85c2880f/)","tags":["Hexo","Tutorial"],"categories":["Hexo教程"]},{"title":"Blog 3：[插畫]本站背景图","url":"/posts/85c2880f/","content":"原作 [**黄瓜**](https://www.pixiv.net/users/6681779)  \n原题 **89**\n[Pixiv: https://www.pixiv.net/artworks/110724378](https://www.pixiv.net/artworks/110724378)\n![title](background.png \"结界组赛高~\")\n","tags":["Picture","Pixiv"],"categories":["插畫"]},{"title":"Blog 2：[Hexo教程]Hexo之代码块添加复制按钮","url":"/posts/8a8b0861/","content":"  \n::: danger\n**注意**  \n经验证，此方法仅适用于安全域下，否则会报 ``navigator.clipboard Cannot read properties of undefined (reading ‘writeText‘）``。  \n安全域包括本地访问与开启TLS安全认证的地址，如 https 协议的地址、127.0.0.1 或 localhost 。  \n具体情况请参照 [这里](https://blog.csdn.net/qq_58340302/article/details/124480086)。\n:::  \n\n> 请注意：本文**转载**自[Evan Zhong's Blog](https://evannzhongg.github.io/2025/03/26/Add-Copy-Button-to-Code-Blocks-in-Hexo/#Hexo-%E4%B8%BA%E4%BB%A3%E7%A0%81%E5%9D%97%E6%B7%BB%E5%8A%A0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%E6%8C%89%E9%92%AE)，根据目前版本之Hexo和NexT进行了微调。\n# 序\n使用**JavaScript**实现之。\n<!-- more -->\n***\n# 准备\n本JS脚本适用于以下结构的代码块：\n```html\n<figure class=\"highlight\">\n  <table>\n    <tr>\n      <td class=\"gutter\">...</td>\n      <td class=\"code\"><pre><code>...</code></pre></td>\n    </tr>\n  </table>\n</figure>\n```\n> 请注意：这是Hexo中大多数主题默认的代码块渲染结构。\n***\n# 创建JavaScript脚本\n在Hexo博客项目的**根目录**下创建``code-copy.js``文件。参考路径如下：\n```\n/source/js/code-copy.js\n```\n> 请注意：若``source``目录下**没有**``js``文件夹，则**手动创建之**。\n\n并在``code-copy.js``文件中写入以下代码：\n```javascript\ndocument.addEventListener('DOMContentLoaded', () => {\n  document.querySelectorAll('figure.highlight').forEach((figure) => {\n    if (figure.querySelector('.copy-btn')) return;\n\n    const copyBtn = document.createElement('button');\n    copyBtn.className = 'copy-btn';\n    copyBtn.title = '复制';\n\n    // 缩小后的复制图标（14*15）\n    const copyIcon = `\n      <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"14\" width=\"15\" viewBox=\"0 0 24 24\" fill=\"white\">\n        <path d=\"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 18H8V7h11v16z\"/>\n      </svg>\n    `;\n\n    // 成功后显示的勾（14*15）\n    const checkIcon = `\n      <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"14\" width=\"15\" viewBox=\"0 0 24 24\" fill=\"#00cc66\">\n        <path d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z\"/>\n      </svg>\n    `;\n\n    copyBtn.innerHTML = copyIcon;\n\n    // 按钮样式（浅灰底、缩小）\n    Object.assign(copyBtn.style, {\n      position: 'absolute',\n      top: '8px',\n      right: '8px',\n      padding: '4px',\n      background: '#aaa', \n      border: 'none',\n      borderRadius: '4px',\n      cursor: 'pointer',\n      opacity: '0.85',\n      zIndex: 1000,\n      transition: 'opacity 0.2s ease',\n      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.15)'\n    });\n\n    copyBtn.addEventListener('mouseover', () => copyBtn.style.opacity = '1');\n    copyBtn.addEventListener('mouseout', () => copyBtn.style.opacity = '0.85');\n\n    copyBtn.addEventListener('click', () => {\n      const code = figure.querySelector('td.code');\n      const text = code ? code.innerText : '';\n      navigator.clipboard.writeText(text).then(() => {\n        copyBtn.innerHTML = checkIcon;\n        setTimeout(() => {\n          copyBtn.innerHTML = copyIcon;\n        }, 1000);\n      });\n    });\n\n    figure.style.position = 'relative';\n    figure.appendChild(copyBtn);\n  });\n});\n```\n***\n# 引用JS脚本\n打开此文件：\n```\nthemes/next/layout/_partial/footer.swig\n```\n在``footer.swig``文件中，找到``</body>``标签之前，添加以下代码：\n```html\n<script src=\"/js/code-copy.js\"></script>\n```\n> 请注意：如果**找不到**``</body>``标签，则可以尝试在``footer.swig``文件**末尾**添加之。\n***\n# 更新博客\n运行Hexo三部曲：\n```bash\nhexo clean\nhexo g\nhexo d\n```\n可以输入``hexo s``在本地启动服务，访问``https://localhost:4000``查看效果。或者在**GitHub Pages**上查看效果。\n","tags":["Hexo","JavaScript","Tutorial"],"categories":["Hexo教程"]},{"title":"Blog 1：[詩歌]诗二首","url":"/posts/95afa136/","content":"# 川上\n臺前瀧上望、曉霧隱晨輝  \n鳥鳴長天浪、凇華璃光杯  \n黛道負白雪、青枝承芬菲  \n墨川浮一葉、蒼雲何照歸  \n\n# 予楊公之長安\n七十六年題名日、少年滿心在三千  \n而今秦川八百外、一步一顧瀟湘間  \n藤原魂斷蓬萊上、不見西行花滿天  \n月夜襲得心百感、落木生春又一年  \n\n","tags":["Poem"],"categories":["詩歌"]}]